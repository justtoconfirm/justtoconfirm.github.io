<!DOCTYPE html>
<html lang="en-GB">
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Developer Notes - JavaScript Basics</title>

    <link rel="shortcut icon" type="image/ico" href="img/favicon/code.ico" />
    <link rel="stylesheet" href="styles/main.css" />
    <link rel="preload" href="fonts/nunito-v9-latin-regular.woff2" as="font" type="font/woff2" crossorigin />
</head>
<body>

<!-- https://medium.com/@mattbasile/matts-lambda-minute-an-intro-to-javascript-variables-objects-and-arrays-93479541c6ad -->
<!-- https://stackoverflow.com/questions/588040/window-onload-vs-document-onload -->
<!-- https://www.techiediaries.com/javascript/document-ready-vs-window-onload-vs-window-load/ -->
<!-- https://www.tutorialspoint.com/What-is-the-difference-between-window-onload-and-document-onload-in-Javascript -->

<!-- https://developers.google.com/web/fundamentals/performance/lazy-loading-guidance/images-and-video/ -->

<!-- https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals -->
<!-- https://medium.com/@crunchtech/object-destructuring-best-practice-in-javascript-9c8794699a0d -->
<!-- https://medium.com/@abhimanyuchauhan_61309/what-is-this-in-javascript-56e38342a8b1 -->

<!-- https://modernweb.com/45-useful-javascript-tips-tricks-and-best-practices/ -->
<!-- https://medium.com/poka-techblog/simplify-your-javascript-use-map-reduce-and-filter-bd02c593cc2d -->

<header class="header" role="banner">
    <nav class="header__inner">
        <ul class="header__item header__item--links">
            <li class="header__link">
                <span class="header__link--background">
                    <a href="index.html">Home</a>
                </span>
            </li>
            <li class="header__link">
                <span class="header__link--background">
                    <a href="#main">Skip to content</a>
                </span>
            </li>
        </ul>
    </nav>
</header>

<main role="main" id="main">
    <h1>JavaScript Basics</h1>

    <p>JavaScript files usually have the file extension of .js</p>

    <p>The <abbr title="Document Object Model">DOM</abbr> Parser takes HTML code and creates a structured page that we see visually. JavaScript engines such as SpiderMonkey, V8, and Nitro, takes the JavaScript syntax and converts it into readable code. This is client side, the files are downloaded and then processed on the client. The JIT (Just In Time) compiler, like Google's V8 engine, is what converts the JavaScript code into machine language.</p>

    <p>JavaScript has a console within the browser inspector Developer tools (DevTools). Commands entered are passed to the JIT compiler, compiled, run, and the output is returned back to the console.</p>

    <h2>Strict mode</h2>

    <p>Strict mode can be applied on entire scripts using the strict statement. This needs to be placed before any other statement, usually the first line in a JavaScript file. Strict mode is only enabled in scripts where it's defined. This is not shared between different script files. This was introduced in ECMAScript 5 (ES5) and is supported in browsers from: IE10, Firefox version 4, Chrome version 13, Safari version 5.1, and Opera version 12.</p>

    <p>All code writted inside ES2015 (ES6) modules and classes is strict by default.</p>

    <pre>
        <code>
<!-- leave this line empty -->
"use strict";
        </code>
    </pre>

    <p>With strict mode, for example, you cannot use undeclared variables. A variable would always need to have a keyword, such as var, or an error will be thrown. Strict mode basically catches things that are most likely valid but could cause errors.</p>

    <h2>&lt;noscript&gt;</h2>

    <p>The &lt;noscript&gt; tag defines an alternative content for users that have disabled JavaScript in their browsers or have a browser that does not support JavaScript. The &lt;noscript&gt; tag can be used in both the &lt;head&gt; and &lt;body&gt; elements.</p>

    <p>When used inside the &lt;head&gt; element &lt;noscript&gt; must only contain &lt;link&gt;, &lt;style&gt; or &lt;meta&lt; elements.</p>

    <pre>
        <code>
<!-- leave this line empty -->
&lt;script&gt;
document.write("Hello World");
&lt;/script&gt;

&lt;noscript&gt;
    &lt;p&gt;Your browser does not support JavaScript&lt;/p&gt;
&lt;/noscript&gt;

        </code>
    </pre>

    <h2>JavaScript &amp; HTML</h2>

    <p>When a browser comes across a &lt;script&gt; element, it stops to load the script and then checks to see if it needs to do anything. It is often recommended to place the &lt;script&gt; element just before the closing &lt;/body&gt; element within a HTML document.</p>

    <p>A request is often sent to a server, which then returns some HTML. The browser parses the markup and discovers the necessary code (CSS and JavaScript) and resources (images, fonts, etc.) to compose the page. Once complete, the browser has to download and process these files. If we want our JavaScript to be fast, we have to download it and process it quickly.</p>

    <p>Should a &lt;script&gt; element be required to be in the &lt;head&gt; section of the HTML document, apply the async attribute.</p>

    <p>Scripts with the async attribute are executed asynchronously. The script is executed as soon as it is downloaded without blocking the browser. Scripts with the defer attribute are executed in order of how they are added to the HTML, but this also does not block the browser. Defer scripts are only executed after the entire document has been loaded. 90% of browsers support the use of async, while 92% support the use of defer.</p>

    <pre>
        <code>
<!-- leave this line empty -->
&lt;<span class="token-tag">body</span>&gt;

&lt;<span class="token-tag">script</span> <span class="token-attr-name">src</span>="<span class="token-attr-value">js/my-script.js</span>"&gt;&lt;<span class="token-tag">/script</span>&gt;
&lt;<span class="token-tag">/body</span>&gt;
&lt;<span class="token-tag">/html</span>&gt;
        </code>
    </pre>

    <p>The HTML &lt;script&gt; element is used to embed or reference executable code, typically JavaScript code. In HTML5, the type attribute is not required, but in HTML4 it will need to be applied.</p>

    <pre>
        <code>
<!-- leave this line empty -->
<span class="token-punctuation">&lt;!-- HTML5 --&gt;</span>
&lt;<span class="token-tag">script</span> <span class="token-attr-name">src</span>="<span class="token-attr-value">js/my-script.js</span>"&gt;&lt;<span class="token-tag">/script</span>&gt;

<span class="token-punctuation">&lt;!-- HTML4 --&gt;</span>
&lt;<span class="token-tag">script</span> <span class="token-attr-name">type</span>="<span class="token-attr-value">text/javascript</span>" <span class="token-attr-name">src</span>="<span class="token-attr-value">js/my-script.js</span>"&gt;&lt;<span class="token-tag">/script</span>&gt;
        </code>
    </pre>

    <h2>Comments</h2>

    <p>JavaScript supports two types of comments, the single-line comment and block comment.</p>

    <pre>
        <code>
<!-- leave this line empty -->
<span class="token-punctuation">// This is a single-line comment</span>

<span class="token-punctuation">/*
 * This is a multi-line comment
 * over multiple lines.
 */</span>
        </code>
    </pre>

    <h2>Escape Characters</h2>

    <p>Escaping characters means that we do something to them to make sure they are recognised as text and not part of the code. In JavaScript, we do this by adding a backslash just before the character.</p>

    <pre>
        <code>
<!-- leave this line empty -->
var message = 'I\'ve got no right to do this.';
console.log(message);       // I've got no right to do this.
        </code>
    </pre>

    <p>Without the escape character an error will appear within the console.</p>

    <pre>
        <code>
<!-- leave this line empty -->
Uncaught SyntaxError: Unexpected identifier
        </code>
    </pre>

    <h2>Variables</h2>

    <p>A variable allows bits of information (data) to be stored within your script. Before you can use a variable, you need to declare (create) it. To declare a variable you need to use the <strong>var</strong> keyword. The JavaScript interpreter knows that this keyword is used to create a variable. In order to use the variable, you must give it a name. This is sometimes called an identifier. If a variable name is more than one word, it is usually written in camelCase. In this example, the variable is called quantity.</p>
    
    <p>A variable is a container for storing a value and must be declared before it can be used. JavaScript is an untyped language meaning that a JavaScript variable can hold a value of any data type. Unlike many other programming languages, you do not need to declare the data type the variable will hold as JavaScript handles this automatically during the execution of the code.</p>

    <pre>
        <code>
<!-- leave this line empty -->
<span class="token-keyword">var</span> quantity;
        </code>
    </pre>

    <p>Once you have created a variable, you can tell it the information you would like it to store. Programmers say that you assign a value to the variable. We use the assignment operator - the equal sign that follows the name of the variable - to assign a value. Until a value has been assigned to a variable, the value is undefined, an empty container.</p>

    <pre>
        <code>
<!-- leave this line empty -->
<span class="token-keyword">var</span> quantity = <span class="token-number-value">3</span>;
        </code>
    </pre>

    <h3>var</h3>

    <p>The var declaration can be used to assign any unique variable a value. However, the usage of var comes with some rules.</p>

    <p>A var is mutable, meaning we can adjust the value of var whenever we'd like. For example:</p>

    <pre>
        <code>
<!-- leave this line empty -->
var name = "Dan";
name = "Matt";

console.log(name);      // Matt
        </code>
    </pre>

    <p>This flexibility is great, but can be dangerous. That's because var can be overwritten, as this next example show.</p>

    <pre>
        <code>
<!-- leave this line empty -->
var name = "Dan";
var name = "Matt";

console.log(name);      // Matt
        </code>
    </pre>

    <p>This example might look the same, but notice how we've used the var declaration again to reassign our values. This may not seem like a huge deal, but imagine we've written a program with thousands of lines of code and we then accidentally reuse the same var name. Our whole program may break.</p>

    <p>When we use variables we want them to be associated with a certain aspect of our code. Whether that's a function, a block, or globally, we don't want our variables leaking to other parts of our code.</p>

    <p>var is functioned scoped, meaning their scope is contained to the function that they're declared in.</p>

    <pre>
        <code>
<!-- leave this line empty -->
function name() {
    var first = "Dan";
}

console.log(first);     // ReferenceError: first is not defined
        </code>
    </pre>

    <p>We are unable to access the variable outside of the function. This is good as we want our function variables to be unique to the functions we declare them in. However, var is not block scoped meaning if a block is invoked, using { }, the var we declare is not limited to the block it's defined in.</p>

    <pre>
        <code>
<!-- leave this line empty -->
var name = "Matt";

if(true) {
    var name = "Dan";   // Variable reassigned in block
}

console.log(name);     // Dan
        </code>
    </pre>

    <p>Above, we see our global variable reassigned in a block. This is not ideal. If we needed our global variables to remain constant, but everytime a block appeared it got reassigned, it wouldn't be good.</p>

    <h3>let</h3>

    <p>let is similar to var, but it has resolved some of it's issues.</p>

    <p>let is great because its values are mutable and it will not allow us to overwrite it. JavaScript won't run our code if we try to overwrite. This is super useful if we accidentally reuse a variable name.</p>

    <pre>
        <code>
<!-- leave this line empty -->
let name = "Dan";
let name = "Matt";  // Uncaught SyntaxError: Identifier 'name' has already been declared
        </code>
    </pre>

    <p>If we want to change the content of a let variable, we can follow this example:</p>

    <pre>
        <code>
<!-- leave this line empty -->
let name = "Dan";
name = "Matt";

console.log(name);      // Matt
        </code>
    </pre>

    <p>As long as we don't rewrite the whole variable, we can reassign a value by just targeting the unique variable name.</p>

    <p>Unlike var, let is block scoped. When declared inside a { } it will not leak out. The variable in the block is totally ignored and the global scope only responds to global variables.</p>

    <pre>
        <code>
<!-- leave this line empty -->
let name = "Dan";

if(true) {
    let name = "Matt";
}

console.log(name);     // Dan
        </code>
    </pre>

    <p>We can show this as a function also.</p>

    <pre>
        <code>
<!-- leave this line empty -->
let name = "Dan";

function test() {
    let name = "Matt";
}

console.log(name);     // Dan
        </code>
    </pre>

    <p>Our variables are stuck to their scope, which is exactly where we want them.</p>

    <h3>const</h3>

    <p>const allows us to assign a value to a variable and keep it constant no matter what. It is not mutable and it cannot be overwritten.</p>

    <pre>
        <code>
<!-- leave this line empty -->
const name = "Dan";

const name = "Matt";    // Uncaught SyntaxError: Identifier 'name' has already been declared

name = "Bob";   // Uncaught TypeError: Assignment to constant variable
        </code>
    </pre>

    <p>Once we declare it, its here to stay. const is block scoped, meaning that it is locked to its declared area.</p>

    <pre>
        <code>
<!-- leave this line empty -->
const name = "Dan";

if(true) {
    const name = "Matt";
    const nickname = "Big";
}

console.log(name);      // Dan
console.log(nickname);      // Uncaught ReferenceError: nickname is not defined
        </code>
    </pre>

    <p>This power is great for variables we don't want to disturb and need to remain constant throughout our application. It is often better to declare your variables as const for as long as possible, that way we don't leave variables susceptible to mutability throughout our code. For those moments when we want mutability, we should use let.</p>

    <h3>Variable Scope</h3>

    <p>The location where you declare a variable will affect where it can be used within your code. If you declare it within a function, it can only be used within that function. This is known as the variable's scope. A variable created inside a function is called a local variable or function-level variable. It is said to have local scope and it cannot be accessed outside of the function. The JavaScript interpreter creates local variables when the function is called, and removes them as soon as the function has finished its task.</p>

    <p>If you create a variable outside of a function, then it can be used anywhere within the script. This is called a global variable and has global scope. Global variables are stored in memory and become a property of the window object for as long as the web page is loaded into the browser. The window object is supported by all browsers and represents the browser's window. This however means that they take up more memory than local variables and increases the risk of naming conflicts with other variables used. For this reason, you should use local variables wherever possible. Should you forget to declare a variable using the var keyword, the variable will work, but this too will be treated as a global variable and is considered bad practice as this pollutes the global namespace.</p>

    <p>Many sites may use scripts written by multiple developers. Using global variables can cause naming collisions as different scripts can use variables with the same name. Therefore, it is best practice to use local variables where possible.</p>

    <p>Variable declarations, wherever they occur, are processed before any code is executed. This is called hoisting. Because of this, declaring a variable anywhere within your code is the equivalent to declaring it at the top of your code. This means that a variable can appear to be used before it has been declared. For this reason, it is always recommended to always declare variables at the top of their scope, either within the global code or at the top of a function.</p>

    <pre>
        <code>
<!-- leave this line empty -->
<span class="token-punctuation">// Local scope</span>
function getArea(width, height) {
    var area = width * height;
    return area;
}

<span class="token-punctuation">// Global scope</span>
var wallSize = getArea(3, 2);
        </code>
    </pre>

    <h3>Variables &amp; Memory</h3>

    <p>Global variables use more memory. The browser has to remember them for as long as the web page using them is loaded. Local variables are only remembered during the period of time that a function is being executed. Each variable that you declare takes up memory. The more variables a browser has to remember, the more memory your script requires to run. Scripts that require a lot of memory can perform slower, which in turn makes your web page take longer to respond to the user.</p>

    <p>A variable actually references a value that is stored in memory. The same value can be used by more than one variable.</p>

    <pre>
        <code>
<!-- leave this line empty -->
<span class="token-punctuation">// Unique variable values in memory</span>
var width = 15;
var height = 30;

<span class="token-punctuation">// The same value of 'true' in memory</span>
var isBox = true;
var isSquare = true;
        </code>
    </pre>

    <h2>Array</h2>

    <p>An array is a variable that stores multiple values. You should consider using an array whenever you are working with a list or a set of values that are related to each other. Arrays are especially helpful when you do not know how many items a list will contain. For example, an array can be suited to storing the individual items on a shopping list because it is a list of related items.</p>

    <p>To create an array, you create a variable using the <strong>var</strong> keyword followed by the name of the array. The values are assigned to the array inside a pair of square brackets, with each value being separated by a comma. The values in the array do not need to be the same data type, so you can store strings, numbers, and booleans all in the same array. This technique for creating an array is known as an array literal and is the preffered method for creating an array.</p>

    <pre>
        <code>
<!-- leave this line empty -->
var colours = ['white', 'black', 'blue'];

colours;       <span class="token-punctuation">// (3) ["white", "orange", "blue"]</span>
        </code>
    </pre>

    <p>Values in an array are accessed as if they are in a numbered list. Each item in the array is automatically given a number called an index. This can be used to access specific items in the array. Index values start at 0 (not 1), so the first value/item in the array has an index of 0, the second has an index of 1, and so on.</p>

    <p>To access the third item within the array, the array name is specified along with the index number of the item to be accessed. So if we want to access the third item in our array - which is 'blue' - we use index 2. Here you can see we have a new variable called itemThree. It's value is set to be the third colour from the colours array:</p>

    <pre>
        <code>
<!-- leave this line empty -->
var colours = ['white', 'black', 'blue']; 
var itemThree = colours[2];                
        </code>
    </pre>

    <p>Each array has a property called length. This holds the number of items within the array. Let's create a new variable that will store the length of the array. This should return '3':</p>

    <pre>
        <code>
<!-- leave this line empty -->
var colours = ['white', 'black', 'blue']; 
var itemThree = colours[2];         
var totalItems = colours.length;    

itemThree;      <span class="token-punctuation">// blue</span>
totalItems;     <span class="token-punctuation">// 3</span>
        </code>
    </pre>

    <p>Now if we want to update a value in the array, for example to change the colour 'black' to 'orange', we can do it this way:</p>

    <pre>
        <code>
<!-- leave this line empty -->
var colours = ['white', 'black', 'blue']; 
colours[1] = 'orange';
        </code>
    </pre>

    <p>Link to a more detailed document about <a href="javascript-array.html">JavaScript Arrays</a>.</p>

    <p>If we want to get a random value from an Array, we can use the following example as a guideline:</p>

    <pre>
        <code>
<!-- leave this line empty -->
var items = [12, 548, 'a', 2, 256, 'b', 'c', true];
var randomItems = items[Math.floor(Math.random() * items.length)];

console.log(randomItems);
        </code>
    </pre>

    <h2>Map()</h2>

    <p>Say you have received an array containing multiple objects, each one representing a person. You really need an array containing only the id of each person.</p>

    <pre>
        <code>
<!-- leave this line empty -->
// What you have
var officers = [
    { id: 20, name: 'Captain Piett' },
    { id: 24, name: 'General Veers' },
    { id: 56, name: 'Admiral Ozzel' },
    { id: 88, name: 'Commander Jerjerrod' }
];

// Map
var officersIds = officers.map(function (officer) {
    return officer.id
});

console.log(officersIds);      // [20, 24, 56, 88]
        </code>
    </pre>

    <p>There are multiple ways to achieve this, but you can use map() if you want to.</p>

    <pre>
        <code>
<!-- leave this line empty -->
var officersIds = officers.map(function (officer) {
    return officer.id
});
        </code>
    </pre>

    <p>In ES6 syntax, you can use an arrow function:</p>

    <pre>
        <code>
<!-- leave this line empty -->
const officersIds = officers.map(officer => officer.id);
        </code>
    </pre>

    <p>Basically, map() takes 2 arguments, a callback and an optional context. The callback runs for each value in the array and returns each new value in the resulting array.</p>

    <h2>Reduce()</h2>

    <p>Just like .map(), .reduce() also runs a callback for each element of an array. The difference here is that reduce passes the result of this callback (the accumulator) from one array to the other.</p>

    <p>Say you have a list of pilots and their years of experience:</p>

    <pre>
        <code>
<!-- leave this line empty -->
var pilots = [
    {
        id: 10,
        name: "Poe Dameron",
        years: 14,
    },
    {
        id: 2,
        name: "Temmin 'Snap' Wexley",
        years: 30,
    },
    {
        id: 41,
        name: "Tallissan Lintra",
        years: 16,
    },
    {
        id: 99,
        name: "Ello Asty",
        years: 22,
    }
];
        </code>
    </pre>

    <p>We need to know the total years of experience for all of them. With .reduce(), we can do it like this:</p>

    <pre>
        <code>
<!-- leave this line empty -->
var totalYears = pilots.reduce(function (accumulator, pilot) {
    return accumulator + pilot.years;
}, 0);
        </code>
    </pre>

    <p>After running the callback for each element of the array, reduce will return the final value of our accumulator, which is 82.</p>

    <h2>Functions</h2>

    <p>Functions consist of a series of statements that have been grouped together because they perform a specific task. A method is the same as a function, except methods are created inside (and are part of) objects. If different parts of a script repeat the same task, you can reuse the function rather than repeating the same set of statements.</p>

    <p>When naming a function, the name should describe the task it is performing. When you want to use the function, it is known as calling the function. The steps that the function needs to follow in order to perform its task are packaged within a code block. A code block consists of one or more statements contained within curly braces.</p>

    <p>To create (declare) a function, you must give it a name (identifier) followed by paranthesis and then write the statements inside the curly braces of the code block. This is known as a function declaration. We declare the function using the function keyword. Having declared the function, you can then execute it. This is known as 'calling the function'. You can call the same function as many times as you like within the same JavaScript file.</p>

    <pre>
        <code>
<!-- leave this line empty -->
<span class="token-punctuation">// Declare the function</span>
function sayHello() {
    console.log('Hello World');
}

<span class="token-punctuation">// Calling the function</span>
sayHello();
        </code>
    </pre>

    <p>Sometimes you will see a function called before it is declared. This still works because the JavaScript interpreter runs through the script before executing each statement, so it will know that a function declaration appears later in the script.</p>

    <p>Functions sometimes need information that is specific to perform its task. In such cases, when declaring the function you give it parameters inside the function. The parameters act like variables. When you call a function that has parameters, you specify the values it should use in the parenthesis that follow the name. The value you pass into the function parameters are called arguments.</p>

    <p>In the following example, width and height are parameters. When the function is called, the value of '3' and '5' are the arguments passed into these parameters.</p>

    <pre>
        <code>
<!-- leave this line empty -->
<span class="token-punctuation">// Declare function with parameters</span>
function getArea(width, height) {
    return width * height;
}

<span class="token-punctuation">// Calling the function with arguments</span>
getArea(3, 5);
        </code>
    </pre>

    <p>Detailed documentation relating to <a href="javascript-functions.html">JavaScript Functions</a></p>

    <h2>Loop</h2>

    <p>Loops can be used to execute a block of code a number of times. Loops are handy if you want to run the same code over and over again, each time with and different value.</p>

    <h3>For Loop</h3>

    <p>For loops are used to loop through a block of code a number of times. The for loop has the following syntax:</p>

    <pre>
        <code>
<!-- leave this line empty -->
for (i = 0; i < 5; i++) {
    console.log('Count: ' + i);
}
        </code>
    </pre>

    <p>This will output the following in the console:</p>

    <pre>
        <code>
<!-- leave this line empty -->
Count: 0
Count: 1
Count: 2
Count: 3
Count: 4
        </code>
    </pre>

    <p>The for loop is the most compact form of looping. It includes the following parts:</p>

    <ul>
        <li>The <strong>loop initialization</strong>, where we initialize our counter to a starting value. This statement is executed before the loop begins. <strong>(i = 0;)</strong></li>
        <li>The <strong>test statement</strong> which will test if a given condition is true or not. If the condition is true, then the code inside the loop will be executed. <strong>(i < 5;)</strong></li>
        <li>The <strong>iteration statement</strong> where you can increase or decrease the counter. <strong>(i++)</strong></li>
    </ul>

    <p>All three parts are separated by semicolons.</p>

    <h3>While Loop</h3>

    <p>The while loop loops through a block of code for a long as a specified condition is true.</p>

    <pre>
        <code>
<!-- leave this line empty -->
var i = 0;

while (i < 3) {
    i++;
}

console.log(i);     // Expected outcome: 3
        </code>
    </pre>

    <h2>DOM Selectors</h2>

    <p><abbr title="Document Object Model">DOM</abbr> Selectors, as the name suggests, is used to select HTML elements within a document using JavaScript. There are five ways in which you can select elements in a DOM using selectors:</p>

    <pre>
        <code>
<!-- leave this line empty -->
getElementsByTagName();
getElementsByClassName();
getElementById();
querySelector();
querySelectorAll();
        </code>
    </pre>

    <p>These methods are all properties of the document object. In order to use one, we need to prefix those elements with the document object.</p>

    <pre>
        <code>
<!-- leave this line empty -->
document.getElementsByTagName();
document.getElementsByClassName();
document.getElementById();
document.querySelector();
document.querySelectorAll();
        </code>
    </pre>

    <p>For example, say we want to return all elements in our HTML document that matches the specified tag if &lt;h1&gt;.</p>

    <pre>
        <code>
<!-- leave this line empty -->
document.getElementsByTagName('h1');
        </code>
    </pre>

    <p>This may return a collection of items matching the tag name of 'h1'. Say we have a &lt;li&gt; item from five on the page, we can use the index to access the specific item we require. So for example, we want to access the second &lt;li&gt; element on the page:</p>

    <pre>
        <code>
<!-- leave this line empty -->
document.getElementsByTagName('li')[1];
        </code>
    </pre>

    <p>Using the querySelector() we can return the first element that matches the CSS selector. If we take the &lt;li&gt; element once again, this will return the very first &lt;li&gt; element on the page that matches the specified CSS selector in the document.</p>

    <pre>
        <code>
<!-- leave this line empty -->
document.querySelector('li');
        </code>
    </pre>

    <p>As with the querySelector() method, you can use querySelectorAll() to return all the elements that match the specified CSS selector in the document.</p>

    <pre>
        <code>
<!-- leave this line empty -->
document.querySelectorAll('li');
        </code>
    </pre>

    <p>You have to use CSS selectors and not normal HTML selectors within the parameters of the methods.</p>

    <pre>
        <code>
<!-- leave this line empty -->
// Valid
document.querySelector('.class-name');

// Will not work
document.querySelector('class-name');
        </code>
    </pre>

    <p>These methods should all work in Internet Explorer 8 (IE8) and above.</p>

    <p>You may also want to use a variable.</p>

    <pre>
        <code>
<!-- leave this line empty -->
var elem = document.querySelector('.class-name');
console.log(elem);
        </code>
    </pre>

    <h2>window.onload</h2>

    <p>By default, it is fired when the entire page loads, including its content (images, CSS, scripts, etc.). In some browsers, it now takes over the role of document.onload and fires when the <abbr title="Document Object Model">DOM</abbr> is ready as well. This is one of the most common event developers check for before running their JavaScript, to check whether the page has completely loaded.</p>

    <pre>
        <code>
<!-- leave this line empty -->
window.onload = function() {
    alert('Hello World');
}
        </code>
    </pre>

    <p>You can see the Window object by opening the console in devTools and typing 'window'.</p>

    <h2>document.onload</h2>

    <p>This is called when the DOM is ready which can be prior to images and other external content being loaded. In jQuery, we can use the ready function to handle the checking of the document being ready, like so:</p>

    <pre>
        <code>
<!-- leave this line empty -->
$(document).ready(function() {
    // Code here 
});

$(function() {
    // Code here
});
        </code>
    </pre>

    <h2>JSON</h2>

    <h3>JSON.stringify()</h3>

    <p>A common use of <abbr title="JavaScript Object Notation">JSON</abbr> is to exchange data to/from a web server. When sending data to a web server, the data has to be a string. This method will convert a JavaScript object or value to a <abbr title="JavaScript Object Notation">JSON</abbr> string. You can convert a JavaScript/<abbr title="JavaScript Object Notation">JSON</abbr> object inot a string with JSON.stringify().</p>

    <p>This method is used to convert objects into <abbr title="JavaScript Object Notation">JSON</abbr>. We can use JSON.parse to convert JSON back into an object.</p>

    <p>Imaging we have this JavaScript object:</p>

    <pre>
        <code>
<!-- leave this line empty -->
var obj = {
    name: "John",
    age: 30,
    city: "New York"
};
        </code>
    </pre>

    <p>Use the function to convert it into a string.</p>

    <pre>
        <code>
<!-- leave this line empty -->
var obj = { 
    name: "John", 
    age: 30, 
    city: "New York" 
};
var myJSON = JSON.stringify(obj);

// We've got a string!
alert(typeof myJSON);

document.getElementById("demo").innerHTML = myJSON;
        </code>
    </pre>

    <p>myJSON is now a string and ready to be sent to a server.</p>

    <p>The same process can be applied to a JavaScript array.</p>

    <pre>
        <code>
<!-- leave this line empty -->
var arr = [ "John", "Peter", "Sally", "Jane" ];
var myJSON = JSON.stringify(arr);
document.getElementById("demo").innerHTML = myJSON;
        </code>
    </pre>

    <p>In JSON, date objects are not allowed, The JSON.stringify() method will convert any dates into strings.</p>

    <pre>
        <code>
<!-- leave this line empty -->
var obj = { 
    name: "John",
    today: new Date(), 
    age: 30, 
    city: "New York" 
};
var myJSON = JSON.stringify(obj);
document.getElementById("demo").innerHTML = myJSON;
        </code>
    </pre>

    <p>The JSON.stringify() method is included in all major browsers and in the latest JavaScript (ECMAScript) standard.</p>

    <h2>The "This" keyword</h2>

    <p>One can think of the "this" keyword as a shortcut which refers to the object from where the function was invoked. As "this" refers to an object from where the function was invoked, we can access all the values and properties of the object. Any changes made to "this" will also update the object being referred.</p>

    <p>As you may know, the environment (or the scope) in which any JavaScript line is being executed is called "The Execution Context". The JavaScript runtime maintains a stack of these execution contexts and the execution context present at the top of this stack is currently being executed. The object that "this" refers to changes every time when the execution context is changed. By default, the execution context is global. If a code is being executed as part of a simple function call then the "this" variable will refer to the global object, in this case, the browser and it's global window object.</p>

    <pre>
        <code>
<!-- leave this line empty -->
function foo() {
    console.log(this === window);
}

foo();      // true
        </code>
    </pre>

    <p>By calling the function, the value of "true" is returned. This proves that "this" refers to the global object, which is the window object in a browser.</p>

    <p>If strict mode is enabled for any function then the value of "this" will be undefined. In strict mode, global object refers to undefined in place of the window object.</p>

    <pre>
        <code>
<!-- leave this line empty -->
function foo() {
    'use strict';
    console.log(this === window);
}

foo();      // false
        </code>
    </pre>

    <p>To summarise, the "this" keyword refers to the object it belongs to.</p>

    <pre>
        <code>
<!-- leave this line empty -->
console.log(this);
        </code>
    </pre>

    <p>The above code example, when run inside the DevTools console, will output the following, the window object by default:</p>

    <pre>
        <code>
<!-- leave this line empty -->
Window {postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, parent: Window, …}
        </code>
    </pre>

    <p>The above example gives us the window object. This happens because the execution context here is global, meaning it is not blocked by any function or object. Let's look at another example.</p>

    <pre>
        <code>
<!-- leave this line empty -->
var testObject = {
    value: 'This is an object scope',
    testFunc: function() {
        console.log(this);
    }
}

testObject.testFunc();
        </code>
    </pre>

    <p>As we can see in the above example, the value of this points to the testObject. This is because the value of "this" depends on the objects that invokes it, in this case the testObject.</p>

    <pre>
        <code>
<!-- leave this line empty -->
var testObject = {
    value: 'This is an object scope',
    testFunc: function() {
        console.log(this);
    }
}

var delegate = testObject.testFunc;
delegate();
        </code>
    </pre>

    <p>The output has now changes and "this" points to the global window object. This happened because the value of the invoking object changed from the testObject to the global object.</p>

    <h2>Checking JavaScript Availability</h2>

    <p>It shouldn't be assumed that JavaScript is always available. We can place a class of no-js on the &lt;html&gt; element like so:</p>

    <pre>
        <code>
<!-- leave this line empty -->
&lt;html class="no-js"&gt;
        </code>
    </pre>

    <p>We can use an inline script in the &lt;head&gt; before any style sheets are requested that removes the no-js class from the &lt;html&gt; element if JavaScript is on:</p>

    <pre>
        <code>
<!-- leave this line empty -->
&lt;script&gt;
document.documentElement.classList.remove("no-js");
&lt;/script&gt;
        </code>
    </pre>

    <p>When JavaScript is unavailable, we can use CSS to provide styling. This is often perfect for Lazy Loading implementations that make use of JavaScript.</p>

    <pre>
        <code>
<!-- leave this line empty -->
.no-js .hidden {
    display: none;
}
        </code>
    </pre>

    <h2>Template literals</h2>

    <p>' or " denotes a string and ` denotes a template literal (formally template string). Template literals have some abilities that normal strings do not. Basically, they allow embedded expressions. Most importantly, you get interpolation.</p>

    <p>Template literals are enclosed by the back tick (` `) known as a grave accent character instead of single or double quotes.</p>

    <pre>
        <code>
<!-- leave this line empty -->
var value = 123;
console.log('test ${value}')    // test ${value}
console.log(`test ${value}`)    // test 123
        </code>
    </pre>

    <p>They can contain placeholders, indicated by the dollar sign and curly braces. The expression in the placeholders and the text between them get passed to a function.</p>

    <pre>
        <code>
<!-- leave this line empty -->
(${expression})
        </code>
    </pre>

    <p>They are not supported in all JavaScript engines, so a transpiler like Babel may need to be used.</p>

    <h2>Create a Timestamp</h2>

    <p>Here is a simple example of how to generate a timestamp.</p>

    <pre>
        <code>
<!-- leave this line empty -->
var timestamp = Math.floor((new Date().getTime()) / 1000);

console.log(timestamp);     // Example: 1550060339
        </code>
    </pre>

    <h2>Ternary Operator</h2>

    <p>Ternary operator has the following syntax:</p>

    <pre>
        <code>
<!-- leave this line empty -->
(condition) ? result if true : result if false
        </code>
    </pre>

    <p>The condition is checked first, if it's true, the first result is executed else the second result is executed.</p>

    <p>A ternary operator eliminates the usage of If/Else statements.</p>

    <pre>
        <code>
<!-- leave this line empty -->
// Without the ternary operator
var condition = true;

if (condition) {
    console.log('True');
} else {
    console.log('False');
}

// With the ternary operator
console.log(condition ? 'True' : 'False');      // True
        </code>
    </pre>

    <p>A ternary is used to shorten the If/Else statement. In this example, the variable result would get the 'cute' value, because the value of animal is 'puppy'. If the animal had another value, result would be 'still fluffy'. You should always expect else conditions, otherwise a syntax error will occur.</p>

    <pre>
        <code>
<!-- leave this line empty -->
var animal = 'puppy';
var result = (animal === 'puppy') ? 'cute' : 'still fluffy';

console.log(result);    // "cute"
        </code>
    </pre>

    <h2>Code Splitting</h2>

    <p>Code splitting helps you to break up your JavaScript so you only load the code the user needs upfront and lazy-load the rest. This helps avoid shipping monolithic main.js files to your users containing JavaScript for the whole site versus just what the page needs.</p>

    <p>The best approach to introducing code splitting is using dynamic import() syntax. This example uses JavaScript Modules to statically 'import' some code. Because we're not loading this code dynamically, it will end up in our default JavaScript bundle.</p>

    <pre>
        <code>
<!-- leave this line empty -->
import { add } from './math';
console.log(add(30, 15));
        </code>
    </pre>

    <p>After switching to dynamic import(), we can lazily pull in the math utilities when they are needed. This could be when the user is about to use a component (when the functionality is needed).</p>

    <pre>
        <code>
<!-- leave this line empty -->
const btn = document.getElementById('load');
btn.addEventListener('click', () => {
    import('./math').then(math => {
        console.log(math.add(30, 15));
    });
});
        </code>
    </pre>

    <p>When a JavaScript module bundler like <a href="webpack.html">Webpack</a> sees this import() syntax, it starts code splitting your app. This means dynamic code can get pushed out into a separate file that is only loaded when it's needed.</p>

    <p>You should also use compression, minification and other JavaScript optimisation techniques to ship fewer bytes of JavaScript to your users and improve the performance of your application.</p>

    <h2>Set CSS Outline of Elements</h2>

    <p>Often you may want to see where all the elements of your page appear. Addy Osmani has shared a very handy script that can be executed within the browser console to outline every element on the page:</p>

    <pre>
        <code>
<!-- leave this line empty -->
[].forEach.call($$("*"), function(a) {
  a.style.outline =
    "1px solid #" + (~~(Math.random() * (1 << 24))).toString(16);
});
        </code>
    </pre>
</main>

</body>
</html>