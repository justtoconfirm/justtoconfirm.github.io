<!DOCTYPE html>
<html lang="en-GB">
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Developer Notes - NodeJS</title>

    <link rel="shortcut icon" type="image/ico" href="img/favicon/code.ico" />
    <link rel="stylesheet" href="styles/main.css" />
    <link rel="preload" href="fonts/nunito-v9-latin-regular.woff2" as="font" type="font/woff2" crossorigin />
</head>
<body>

<!-- https://stackify.com/learn-nodejs-tutorials/ -->
<!-- https://hackernoon.com/how-to-use-nodejs-without-frameworks-and-external-libraries-97eb6acac9e3 -->
<!-- https://www.tutorialspoint.com/nodejs/index.htm -->
<!-- https://nodejs.org/en/ -->
<!-- https://medium.com/the-node-js-collection/making-your-node-js-work-everywhere-with-environment-variables-2da8cdf6e786 -->
<!-- https://medium.freecodecamp.org/the-definitive-node-js-handbook-6912378afc6e -->
<!-- https://www.tutorialspoint.com/nodejs/nodejs_restful_api.htm -->
<!-- https://codeburst.io/build-simple-medium-com-on-node-js-and-react-js-a278c5192f47 -->
<!-- https://hackernoon.com/9-npm-packages-to-explore-in-your-next-node-js-application-2018-ec4aac0ca723 -->
<!-- https://dev.to/nburgess/creating-a-react-app-with-react-router-and-an-express-backend-33l3 -->
<!-- https://www.airpair.com/javascript/node-js-tutorial -->

<header class="header" role="banner">
    <nav class="header__inner">
        <ul class="header__item header__item--links">
            <li class="header__link">
                <span class="header__link--background">
                    <a href="index.html">Home</a>
                </span>
            </li>
            <li class="header__link">
                <span class="header__link--background">
                    <a href="#main">Skip to content</a>
                </span>
            </li>
        </ul>
    </nav>
</header>

<main role="main" id="main">
    <h1>NodeJS</h1>

    <p>NodeJS, also known as Node or Node.js, is defined as a dynamic, cross-platform and open-source JavaScript framework or runtime environment that is built on the Google Chrome V8 JavaScript engine. The V8 engine is built in C++. Its job is to convert JavaScript code into machine code. NodeJS, developed by Ryan Dahl in 2009, was initially implemented as a client-side scripting language. Now, it is used to execute JavaScript code and scripts that run server-side to create dynamic web pages/applications.</p>

    <p>Node is only an environment, or runtime, within which to run normal JavaScript outside of the browser. We can use it to build desktop application (with frameworks like Electron), write web or app servers, and more.</p>

    <p>The Node run-time environment includes everything you may need to execute a program written in JavaScript.</p>

    <p>Unlike PHP, there is no separation between the web server and code and we do not have to customise large configuration files to get the behaviour we want. With Node, we can create the web server, customise it, and deliver content. All this can be done at code level.</p>

    <p>For example, NodeJS could be combined with a React to build a web application. React and Redux can be used to build the frontend, NodeJS with ExpressJS used for the backend, and MongoDB as the database.</p> 

    <p>Express is the most popular web framework for Node. You may also see Socket.IO being used, which is a realtime framework that enables bi-directional communication between web clients and the server.</p>

    <h2>Install Node &amp; NPM</h2>

    <p>There are native installers for Node on Windows and Mac OS (formally Mac OS X). Sometimes you want to use different versions of Node, and that's where NVM (Node Version Manager) comes in. With NVM, you can have multiple versions of Node installed on your system and switch between them easily. We can use CURL to install NVM from within the terminal:</p>

    <pre>
        <code>
<!-- leave this line empty -->
$ curl-o-https://raw.githubusercontent.com/creationix/nvm/v0.33.8/install.sh | bash
        </code>
    </pre>

    <p>This command will install NVM version 0.33.8, so you may want to install the latest version at the time you install. Once installed, you will need to close and reopen your terminal, or use the following terminal command to restart the terminal without closing:</p>

    <pre>
        <code>
<!-- leave this line empty -->
$ source ~/.profile
        </code>
    </pre>

    <p>Now you can verify that NVM is installed and working properly.</p>

    <pre>
        <code>
<!-- leave this line empty -->
$ nvm --version
        </code>
    </pre>

    <p>With NVM, you can then install the version of Node you require. As an example, lets install Node version 0.10.31</p>

    <pre>
        <code>
<!-- leave this line empty -->
$ nvm install v0.10.31
        </code>
    </pre>

    <p>If we want to set the default version of Node:</p>

    <pre>
        <code>
<!-- leave this line empty -->
$ nvm alias default 0.10.31
        </code>
    </pre>

    <p>To install and switch to a different version of Node using NVM:</p>

    <pre>
        <code>
<!-- leave this line empty -->
$ nvm install v0.8.10
$ nvm use v0.8.10
        </code>
    </pre>

    <p>To check the version of Node installed, open your terminal.</p>

    <pre>
        <code>
<!-- leave this line empty -->
$ node --version
        </code>
    </pre>

    <p>Create a JavaScript file named main.js on your machine. Within this file, add the following code:</p>

    <pre>
        <code>
<!-- leave this line empty -->
console.log("Hello, World");
        </code>
    </pre>

    <p>Now use Node to execute the main.js file to see the result. This should be output within your terminal.</p>

    <pre>
        <code>
<!-- leave this line empty -->
$ node main.js
        </code>
    </pre>

    <h2>NPM &amp; Node Modules</h2>

    <p>NPM stands for Node Package Manager. It is the largest software package library in the world, with over 600,000 packages. The NodeJS installation comes with a Command Line Interface (CLI) for NPM which allows developers to interact with packages locally on their machines.</p>

    <p>The Node Package Manager (NPM) provides two main functionalities:</p>

    <ul>
        <li>An online repository for Node packages/modules which are searchable.</li>
        <li>A command line utility that allows Node packages/modules to be installed/managed.</li>
    </ul>

    <p>NPM came bundled with Node following version 0.6.3 and to verify the vesion of NPM installed, open the terminal to see the result.</p>

    <pre>
        <code>
<!-- leave this line empty -->
$ npm --version
        </code>
    </pre>

    <h3>The package.json file</h3>

    <p>Before you can install an NPM package, you may need a package.json file to be created.</p>

    <pre>
        <code>
<!-- leave this line empty -->
$ npm init -y
        </code>
    </pre>

    <p>If you want a special Christmas treat to appear in your terminal, enter the following:</p>

    <pre>
        <code>
<!-- leave this line empty -->
$ npm xmas
        </code>
    </pre>

    <h3>Installing Packages/Modules</h3>

    <p>The require directive is used to load Node modules. For instance, say we want to install the Express (Express.js) framework module. Express is a web application framework that wraps a NodeJS web server. It offers a simple API, middleware, and routing. Express can be used for building RESTful APIs, serving single page applications (SPA) and serving static content (HTML, images, etc.).</p>

    <p>Express has detailed <a href="https://expressjs.com/" target="_blank" rel="noopener noreferrer">documentation</a> on the main website.</p>

    <p>We first use NPM to install the module:</p>

    <pre>
        <code>
<!-- leave this line empty -->
$ npm install express
        </code>
    </pre>

    <p>Now, we can use this module in your JavaScript file using the require directive:</p>

    <pre>
        <code>
<!-- leave this line empty -->
var express = require('express');
        </code>
    </pre>

    <p>Java or Python uses the import function to load other libraries, while PHP and Ruby use require. Node implements the CommonJS interface for modules. In Node, you can load other dependencies using the require keyword. For example, we can require some native modules:</p>

    <pre>
        <code>
<!-- leave this line empty -->
var http = require('http');
var dns = require('dns');
        </code>
    </pre>

    <p>We can also require relative files:</p>

    <pre>
        <code>
<!-- leave this line empty -->
var myFile = require('./myFile');       // Loads myFile.js
        </code>
    </pre>

    <p>When using require, including when installing packages from NPM, there is no need to specify the absolute or relative path.</p>

    <p>Node modules are not automatically injected into the global scope, but instead we assign them to a variable of your choice. This means that you don't have to care about two or mor modules that have functions with the same name.</p>

    <p>By default, NPM installs any dependency in local mode. Here local mode refers to the package being installed within the node_modules directory. Globally installed packages/dependencies are stored in the system directory.</p>

    <p>If we wanted, as an example, to install Express globally we just need to add a flag.</p>

    <pre>
        <code>
<!-- leave this line empty -->
$ npm install express -g
        </code>
    </pre>

    <p>It is usually recommended, where possible, to avoid installing packages globally. Ideally, we should install Express as a dependency:</p>

    <pre>
        <code>
<!-- leave this line empty -->
$ npm install express --save
        </code>
    </pre>

    <p>This will then be listed as a dependency within your package.json file and Express will be installed within the node_modules directory within your project folder.</p>

    <h3>NPM tools</h3>

    <p>We can use the terminal to list down all the locally installed modules.</p>

    <pre>
        <code>
<!-- leave this line empty -->
$ npm ls
        </code>
    </pre>

    <p>Check for outdated packages:</p>

    <pre>
        <code>
<!-- leave this line empty -->
$ npm outdated
        </code>
    </pre>

    <p>The install command does not update existing packages since NPM already finds satisfying versions installed on the file system. Instead of the install command, you can use update to freshen already installed packages. When you run update, NPM checks to see if exists newer versions in the repository and installs them, You may need to use the --save or --save-dev flags to ensure the package.json file gets updated also.</p>

    <pre>
        <code>
<!-- leave this line empty -->
$ npm update
        </code>
    </pre>

    <p>Should we want to update our NPM packages to the latest version, we can use the following command:</p>

    <pre>
        <code>
<!-- leave this line empty -->
$ npm install package@latest --save
$ npm install package@latest --save-dev
        </code>
    </pre>

    <p>To update the version displayed in your package.json file, use the following NPM command:</p>
    <!-- https://docs.npmjs.com/cli/version.html -->

    <pre>
        <code>
<!-- leave this line empty -->
$ npm version patch
$ npm version minor
$ npm version major
        </code>
    </pre>

    <p>For example, using 'patch' would increase the version of package.json from 1.0.0 to 1.0.1. This should follow the <a href="https://semver.org/" target="_blank" rel="noopener noreferrer">Semantic versioning</a> model.</p>

    <h2>Setting engines property</h2>
    <!-- http://www.marcusoft.net/2015/03/packagejson-and-engines-and-enginestrict.html -->

    <p>Within your package.json you may want to specify the recommended versions of Node and NPM (Node Package Manager) to use:</p>

    <pre>
        <code>
<!-- leave this line empty -->
"engines": {
    "node": "^10.0",
    "npm": "^6.0"
},
        </code>
    </pre>

    <p>This will ensure we get warning or errors displayed in the terminal if we are using the wrong version, or lesser version, of Node and NPM.</p>

    <p>You can also set the "engineStrict" property to be 'true' in your package.json to be sure that your module will definitely not run properly on versions of Node and NPM other than those specified.</p>

    <pre>
        <code>
<!-- leave this line empty -->
"engineStrict": true,
        </code>
    </pre>

    <p>This flag is set to 'false' as default, leaving the engines node to be "advisory only".</p>

    <h2>Pre-Commit</h2>
    <!-- https://www.npmjs.com/package/pre-commit -->

    <p>Within your package.json file, you can add a pre-commit hook installed for git. This will ensure that your NPM test, or other specified scripts, passes before you can commit your changes. This is configured within the package.json file like so:</p>

    <pre>
        <code>
<!-- leave this line empty -->
"pre-commit": {
    "run": [
        "precommit-msg",
        "test:commit-hook"
    ]
},
        </code>
    </pre>

    <p>It's advised to install the pre-commit module as a devDependency in your package.json file as you only need it during development.</p>

    <pre>
        <code>
<!-- leave this line empty -->
$ npm install pre-commit --save-dev
        </code>
    </pre>

    <p>pre-commit will try and run your npm test command. It can also be used to run other build scripts that you've listed before code is committed using git.</p>

    <pre>
        <code>
<!-- leave this line empty -->
{
    "name": "437464d0899504fb6b7b",
    "version": "0.0.0",
    "description": "ERROR: No README.md file found!",
    "main": "index.js",
    "scripts": {
        "precommit-msg": "echo 'Running pre-commit checks...' && exit 0",
        "test": "echo \"Error: I SHOULD FAIL LOLOLOLOLOL \" && exit 1",
        "foo": "echo \"fooo\" && exit 0",
        "bar": "echo \"bar\" && exit 0"
    },
    "pre-commit": [
        "precommit-msg",
        "foo",
        "bar",
        "test"
    ]
}
        </code>
    </pre>

    <h2>Modules</h2>

    <p>When creating you own modules, all you have to do is take care when exporting something. The first approach would be to export a single object:</p>

    <pre>
        <code>
<!-- leave this line empty -->
var person = {
    name: 'John',
    age: 20
}

module.exports = person;
        </code>
    </pre>

    <p>The second approach requires adding properties to the exports object:</p>

    <pre>
        <code>
<!-- leave this line empty -->
exports name = 'John';
exports age = 20;
        </code>
    </pre>

    <p>Modules do not share scope, so if you want to share a variable between different modules, you must include it into a separate module that is then required by the other modules. Modules are also only loaded once, afetr that they are cached by Node.</p>

    <h2>A Sample NodeJS application</h2>

    <p>The most common NodeJS example of 'Hello World', is a simple web server. To run the following code, create a file named server.js and save the following code:</p>

    <pre>
        <code>
<!-- leave this line empty -->
const http = require('http')

const hostname = '127.0.0.1'
const port = 3000

const server = http.createServer((req, res) => {
    res.statusCode = 200
    res.setHeader('Content-Type', 'text/plain')
    res.end('Hello World\n')
})

server.listen(port, hostname, () => {
    console.log(`Server running at http://${hostname}:${port}/`)
})
        </code>
    </pre>

    <p>To run this snippet, open your terminal.</p>

    <pre>
        <code>
<!-- leave this line empty -->
$ node server.js
        </code>
    </pre>

    <p>The simple server will be running. Open <a href="http://127.0.0.1:3000" target="_blank" rel="noopener noreferrer">http://127.0.0.1:3000</a> to view the simple 'Hello World' example in your browser.</p>

    <p>To stop the server, use the keyboard shortcut of CTRL + C</p>

    <p>In this example, we are using the http module that Node includes. The createServer() method of http creates a new HTTP server and returns it. The server is set to listen on a specified port and hostname. When the server is ready, the callback function is called, in this case informing us that the server is running.</p>

    <h2>Node &amp; Callbacks</h2>

    <p>A callback is a function that is called at the completion of a given task. Node makes heavy use of callbacks. All the APIs of Node are written in such a way that they support callbacks. Node can therefore process a high number of requests without waiting for any function to return results.</p>

    <p>Node is single-threaded and uses a concurrency model based on an event loop. It is non-blocking, so doesn't make the program wait, but instead registers a callback and lets the program continue. This means it can handle concurrent operations without multiple threads of execution, so it can scale pretty well.</p>

    <h2>Uses for Node</h2>

    <p>Node is ideal for I/O bound applications, but not so great for CPU-heavy applications. Good examples include:</p>

    <ul>
        <li>Data-intensive realtime applications (DIRT)</li>
        <li>Single Page Applications (SPA)</li>
        <li>JSON APIs</li>
        <li>Data-streaming applications</li>
    </ul>
</main>

</body>
</html>