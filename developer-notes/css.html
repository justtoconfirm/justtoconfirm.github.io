<!DOCTYPE html>
<html lang="en-GB">
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Developer Notes - CSS</title>

    <link rel="shortcut icon" type="image/ico" href="img/favicon/code.ico" />
    <link rel="stylesheet" href="styles/main.css" />
    <link rel="preload" href="fonts/nunito-v9-latin-regular.woff2" as="font" type="font/woff2" crossorigin />
</head>
<body>

<!-- https://developer.mozilla.org/en-US/docs/Learn/CSS/Introduction_to_CSS/Syntax -->
<!-- https://www.sitepoint.com/optimizing-css-performance/ -->
<!-- https://www.creativebloq.com/features/10-amazing-new-css-techniques -->
<!-- https://www.fifteendesign.co.uk/blog/an-introduction-to-css-flex-and-browser-compatibility-part-1/ -->

<!-- https://developer.mozilla.org/en-US/docs/Learn/CSS/Introduction_to_CSS/How_CSS_works -->

<!-- https://www.smashingmagazine.com/2019/02/css-browser-support/ -->

<!-- https://medium.com/@geoffrey.signorato/understand-the-concept-of-css-transitions-in-2-min-d731b8371f7f -->

<header class="header" role="banner">
    <nav class="header__inner">
        <ul class="header__item header__item--links">
            <li class="header__link">
                <span class="header__link--background">
                    <a href="index.html">Home</a>
                </span>
            </li>
            <li class="header__link">
                <span class="header__link--background">
                    <a href="#main">Skip to content</a>
                </span>
            </li>
        </ul>
    </nav>
</header>

<main role="main" id="main">
    <h1>CSS (Cascading Style Sheets)</h1>

    <p>CSS describes how HTML elements are to be displayed/styled and can be used to control the layout or structure of multiple web pages. A CSS rule-set consists of a selector and a declaration block.</p>

    <p>The selector points to the HTML element you want to style. The declaration block contains one or more declarations (statements) separated by semicolons. Each declaration includes a CSS property name and a property value, separated by a colon. The declaration block is surrounded by curly braces.</p>

    <p>CSS should be written across multiple lines. This reduces the chance of merge conflicts when using version control, because each CSS declaration exists on it's own line. Code can therefore be compared more easily as a single line only ever carries one change. If a CSS selector only has one declaration, then this will still confirm to this practice.</p>

    <pre>
        <code>
<!-- leave this line empty -->
/* Multiple declarations on single lines */
.icon {
    display: inline-block;
    width: 16px;
    height: 16px;
    background-image: url(/img/sprite.svg);
}

/* Acceptable CSS as single declaration */
.icon--home { background-position: 0 0; }
.icon--person { background-position: -16px 0; }
.icon--files { background-position: -16px -16px; }
        </code>
    </pre>

    <p>At its most basic level, CSS consists of two building blocks:</p>

    <ul>
        <li>Properties - Human-readable identifiers that indicate which stylistic feature you want to change (e.g. font, width, background colour).</li>
        <li>Values - Each specified property is given a value, which indicates how you want to change those stylistic features.</li>
    </ul>

    <pre>
        <code>
<!-- leave this line empty -->
selector {
    property: value;
}
        </code>
    </pre>

    <p>A property paired with a value is called a CSS declaration. CSS declarations are placed within curly braces. This is referred to as the CSS Declaration Block. The declaration block is paired with a selector to produce CSS Rulesets (sometimes known as CSS Rules).</p>

    <p>In the following example all &lt;p&gt; elements will be centrally-aligned with a colour applied. The &lt;p&gt; element is the selector and within the declaration block, you will find the declarations of 'color' and 'text-align' properties with their associated values.</p>

    <pre>
        <code>
<!-- leave this line empty -->
p {
    color: #00ff00;
    text-align: center;
}
        </code>
    </pre>

    <p>Should any properties or values not be recognised, the browser will simply ignore them.</p>

    <h2>Adding CSS to HTML</h2>

    <p>To add CSS to HTML it is recommended to use an external stylesheet. This is simply a file containing your CSS code that has the file extension of '.css' and can then be included within your HTML document. The CSS stylesheets can be grouped together in a single directory, usually named something like 'styles' within a project directory.</p>

    <p>External stylesheets allow you to change the look of an entire website by changing just a single CSS file.</p>

    <p>Begin by creating an external stylesheet named 'style.css'. We can then include our stylesheet within the HTML document. Each HTML page must include a reference to the external stylesheet file inside the &lt;link&gt; element. The &lt;link&gt; element is placed inside the &lt;head&gt; section of your HTML.</p>

    <pre>
        <code>
<!-- leave this line empty -->
&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="utf-8" /&gt;

    &lt;title&gt;My Website&lt;/title&gt;

    &lt;!-- CSS stylesheets --&gt;
    &lt;link rel="stylesheet" href="styles/style.css" /&gt;
&lt;/head&gt;
        </code>
    </pre>

    <p>Should you see an external CSS stylesheet with the filename that contains 'min', this is likely to be a minified file.</p>

    <pre>
        <code>
<!-- leave this line empty -->
&lt;link rel="stylesheet" href="styles/style.min.css" /&gt;
        </code>
    </pre>

    <h2>Comments</h2>

    <p>Comments in CSS begin with /* and end with */</p>

    <pre>
        <code>
<!-- leave this line empty -->
/* This is a comment in CSS */
        </code>
    </pre>

    <h2>CSS Box Model</h2>

    <p>All HTML elements can be considered as boxes. In CSS, the term "box model" is used when talking about design and layout. The CSS box model is essentially a box that wraps around every HTML element. It consists of: margin, border, padding, and the actual content.</p>

    <ul>
        <li>Content - the content of the box, where text, images and other content appears.</li>
        <li>Padding - clears an area around the content but inside the defined border. Is transparent.</li>
        <li>Border - border that goes around the padding and content.</li>
        <li>Margin - clears an area outside the border. Is transparent.</li>
    </ul>

    <p>The box model allows us to add a border around elements and to define space between elements.</p>

    <h2>Selecting Elements</h2>

    <p>An explination as to how we can use CSS to select HTML elements. Here is a simple HTML structure to demonstrate.</p>

    <pre>
        <code>
<!-- leave this line empty -->
&lt;div class="container"&gt;
    &lt;!-- Child element(s) --&gt;
    &lt;p&gt;Paragraph one.&lt;/p&gt;
    &lt;p&gt;Paragraph two.&lt;/p&gt;

    &lt;div class="container-summary"&gt;
        &lt;!-- Grandchild elements(s) --&gt;
        &lt;p&gt;Paragraph three.&lt;/p&gt;
    &lt;/div&gt;

    &lt;!-- Child element(s) --&gt;
    &lt;p&gt;Paragraph four.&lt;/p&gt;
    &lt;p&gt;Paragraph five.&lt;/p&gt;
&lt;/div&gt;
        </code>
    </pre>

    <h3>Space</h3>

    <p>This is called a descendent selector. In this example, it will target all &lt;p&gt; tags within the container &lt;div class="container"&gt; and set the font-weight to be bold.</p>

    <pre>
        <code>
<!-- leave this line empty -->
.container p {
    font-weight: bold;
}
        </code>
    </pre>

    <h3>The Child Combinator (&gt;)</h3>

    <p>The child combinator (&gt;), will only target direct children of a particular element. Only elements that are nested directly within the &lt;div class="container"&gt; element, and not any paragraphs nested further within - such as within &lt;div class="container-summary"&gt; (a grandchild element) - will have the styling applied.</p>

    <p>Styling will only be applied to child elements and not grandchild elements of the parent.</p>

    <pre>
        <code>
<!-- leave this line empty -->
.container > p {
    font-weight: bold;
}
        </code>
    </pre>

    <h3>Adjacent Sibling Combinator (+)</h3>

    <p>Combines two sequences of simple selectors having the same parent and the second one must come immediately after the first. It will only select the first element that is immediately preceded by the former selector. In our example, it will target only 'Paragraph four.' because the &lt;p&gt; element comes just after the &lt;div class="container-summary"&gt; element in our HTML.</p>

    <pre>
        <code>
<!-- leave this line empty -->
.container-summary + p {
    font-weight: bold;
}
        </code>
    </pre>

    <h3>~ Sign</h3>

    <p>Select all elements that preceded the former selector. Therefore, we can use this selector to target all &lt;p&gt; elements that come after the &lt;div class="container-summary"&gt; element.</p>

    <pre>
        <code>
<!-- leave this line empty -->
.container-summary ~ p {
    font-weight: bold;
}
        </code>
    </pre>

    <h3>Universal Selectors</h3>

    <p>Universal selectors like *, [disabled] and [type="text"], check every element in the DOM for a match. This can be very expensive for the browser. This is often used for box-sizing and other globals.</p>

    <pre>
        <code>
<!-- leave this line empty -->
* {
    box-sizing: border-box;
}
        </code>
    </pre>

    <h2>Shorthand Properties</h2>

    <p>Some properties such as font, background, padding, border, and margin are called shorthand properties. This is because they allow you to set several property values in a single line using one property. This saves you time and makes your code smaller.</p>

    <pre>
        <code>
<!-- leave this line empty -->
padding: 10px 15px 15px 5px;
        </code>
    </pre>

    <p>The above shorthand does the same as the following:</p>

    <pre>
        <code>
<!-- leave this line empty -->
padding-top: 10px;
padding-right: 15px;
padding-bottom: 15px;
padding-left: 5px;
        </code>
    </pre>

    <h2>Links</h2>

    <p>Links can be styled with any CSS property (e.g. color, font-family, background, etc.). In addition, links can be styled differently depending on what state they are in. The four links states are:</p>

    <ul>
        <li>a:link - a normal, unvisited link.</li>
        <li>a:visited - a link the user has visited.</li>
        <li>a:hover - a link when the user mouses over it.</li>
        <li>a:active - a link the moment it is clicked.</li>
    </ul>

    <p>When setting the style for link states, there are some order rules:</p>

    <ul>
        <li>a:hover MUST come after a:link and a:visited</li>
        <li>a:active MUST come after a:hover</li>
    </ul>

    <pre>
        <code>
<!-- leave this line empty -->
a:link {
    color: #ff00ff;
}

a:visited {
    color: #00ff00;
}

a:hover {
    text-decoration: none;
}

a:active {
    color: #0000ff;
}
        </code>
    </pre>

    <h2>Text Colour</h2>

    <p>The color property is used to set the colour of text on your page. The default colour for a page is defined in the body selector. The colour can be specified by:</p>

    <ul>
        <li>Colour name - like "red"</li>
        <li>HEX value - like "#ff0000"</li>
        <li>RGB value - like "rgb(255, 0, 0)"</li>
    </ul>

    <pre>
        <code>
<!-- leave this line empty -->
body {
    color: #ff0000;
}

h1 {
    color: rgb(255, 0, 0);
}
        </code>
    </pre>

    <h2>CSS Display Property</h2>

    <p>The CSS display property specifies if, or how, an element is displayed. Every HTML element has a default display value depending on what type of element it is. The default display value for most elements is block or inline.</p>

    <p>You can override the an element's default display value. Changing an inline element to a block element, or vice versa, can be useful for changing how your page looks and still following web standards. Setting the display property of an element only changes how the element is displayed and not what kind of element it is. An inline element with 'display: block;' is not allowed to have other block elements inside it.</p>

    <p>A common example is making a &lt;li&gt; element inline for horizontal menus/lists:</p>

    <pre>
        <code>
<!-- leave this line empty -->
li {
    display: inline;
}
        </code>
    </pre>

    <h3>Block Element</h3>

    <p>A block-level element always starts on a new line and takes up the full width available (stretches out to the left and right as far as it can). Examples of block-level elements:</p>

    <ul>
        <li>&lt;div&gt;</li>
        <li>&lt;h1&gt; to &lt;h6&gt;</li>
        <li>&lt;p&gt;</li>
        <li>&lt;header&gt;</li>
        <li>&lt;footer&gt;</li>
        <li>&lt;section&gt;</li>
    </ul>

    <h3>Inline Elements</h3>

    <p>An inline element does not start on a new line and only takes up as much width as necessary. Examples include:</p>

    <ul>
        <li>&lt;span&gt;</li>
        <li>&lt;a&gt;</li>
        <li>&lt;img&gt;</li>
    </ul>

    <h3>Hiding Elements</h3>

    <p>The display property is used to specify how an element should be displayed. The visibility property specifies whether or not an element should be visible.</p>

    <p>Hiding an element can be done by setting the display property to 'none'. The element will be hidden and the page will be displayed as if the element is not there.</p>

    <pre>
        <code>
<!-- leave this line empty -->
p {
    display: none;
}
        </code>
    </pre>

    <p>Setting the visibility property to 'hidden' will hide the element, but the element will still take up the same space as before and this can affect the layout of your page.</p>

    <pre>
        <code>
<!-- leave this line empty -->
p {
    visibility: hidden;
}
        </code>
    </pre>

    <h2>CSS Performance</h2>

    <p>Loading a CSS file blocks the page rendering, so this should be considered if you have a large stylesheet or multiple stylesheets. Using Google page analysis tools, you may often see suggestions such as 'inline critical CSS' or 'reduce render-blocking stylesheets'. CSS performance can therefore be improved with the following steps:</p>

    <ul>
        <li>Extract the styles used to render elements above the folder and add those to a &lt;style&gt; element in the HTML &lt;head&gt;.</li>
        <li>Load the main CSS file asynchronously using JavaScript, perhaps after the page has loaded.</li>
    </ul>

    <h3>Progressive Rendering</h3>

    <p>Rather than using a single site-wide CSS stylesheet, progressive rendering is a technique that defines individual stylesheets for separate components. Each is loaded immediately before a component is referenced in the HTML.</p>

    <p>Each &lt;link&gt; still blocks rendering, but for a shorter time because the file is smaller. The page becomes usable sooner, because each component renders in sequence.</p>

    <p>Progressive rendering could benefit large sites where individual pages are constructured from a selection of different components.</p>

    <pre>
        <code>
<!-- leave this line empty -->
&lt;head&gt;
    &lt;!-- core styles used across components --&gt;
    &lt;link rel="stylesheet" href="base.css" /&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;!-- header component --&gt;
    &lt;link rel="stylesheet" href="header.css" /&gt;
    &lt;header&gt; ... &lt;/header&gt;

    &lt;!-- primary content --&gt;
    &lt;link rel="stylesheet" href="content.css" /&gt;
    &lt;main&gt;
            &lt;!-- form styling --&gt;
            &lt;form&gt; ... &lt;/form&gt;
    &lt;/main&gt;

    &lt;!-- footer component --&gt;
    &lt;link rel="stylesheet" href="footer.css" /&gt;
    &lt;footer&gt; ... &lt;/footer&gt;
&lt;/body&gt;
        </code>
    </pre>

    <h2>Feature Query</h2>

    <p>CSS has developed a way for you to test for browser support of new CSS features, with Feature Queries. A Feature Query behaves in much the same way as a Media Query, except that instead of asking the browser something about the device being used to view the site, a Feature Query asks the browser if it supports a particular CSS feature. This makes it easier to use new features in a safe, progressively enhanced way.</p>

    <pre>
        <code>
<!-- leave this line empty -->
/* CSS rules for browsers that support grid layout */
@supports (display: grid) {
    .item {
        /* CSS from browsers which do not support grid layout */
    }
}

/* Not supported */
@supports not (display: grid) {
    .item {
        /* CSS from browsers which do not support grid layout */
    }
}
        </code>
    </pre>

    <p>Browser support for Feature Queries is good, but not supported in Internet Explorer (IE11) and below. As long as you test for support and then write the code for supporting browsers, you can overwrite anything you need for older browsers.</p>

    <p>It is likely that most modern and new features you want to use are not supported by Internet Explorer (IE) so, at present, you will almost always start by writing CSS for browsers without support then test with a feature query. The feature query should test for support.</p>

    <p>Browsers which support feature queries will return true if they have support and so the code inside the query will be used. This will overwrite the code for older browsers.</p>

    <p>Anything new that comes into CSS you can use Feature Queries to test for and allows us to use new features much more quickly.</p>

    <h2>Selector Support</h2>

    <p>Currently Feature queries can only test CSS properties and values. We may want to also test support for selectors. For example, if you visit <strong>about:config</strong> in Firefox and enable the flag <strong>layout.css.supports-selector.enabled</strong>, you can test to see if various selectors are supported. For example, the test for the :has selector:</p>

    <pre>
        <code>
<!-- leave this line empty -->
@support selector(:has) {
    .item {
        /* CSS for support of :has */
    }
}
        </code>
    </pre>

    <p>This is a specification in development currently.</p>

    <h2>CSS Reset</h2>

    <p>A CSS Reset allows you to start with a clean code base, making it easier to style your website with more predictable outcomes. A CSS Reset resets or overrides the default styles of the browser. You can write your own, or use an existing CSS reset that maybe available.</p>

    <h2>DRY - Don't Repeat Yourself</h2>

    <p>CSS is best written when it follows the DRY (Don't Repeat Yourself) principle. This helps us to avoid writing the same bits of code over and over again. One way to keep our CSS DRY is to group things together.</p>

    <pre>
        <code>
<!-- leave this line empty -->
/* This is not DRY CSS */
.menu li {
    color: red;
}

.menu li a {
    color: red;
}

/* This is DRY CSS */
.main li,
.main li a {
    color: red;
}
        </code>
    </pre>

    <h2>!important Declaration</h2>

    <p>The !important declaration is almost always a bad thing to use within your CSS. It is generally misused to override CSS declarations to apply new styling. Often it is used to combat specificity problems as a result of poorly architected CSS, to force styling to be applied. Proactive use of !important is when it is used before you encounter any specificity problems; when it is used as a guatantee rather than as a fix. Therefore !important should be used to always ensure something is styled a certain way and don't get accidentally overridden by something more specific.</p>

    <p>In this example, two helper (or utility) CSS classes are very specific in their intentions. You would only use them should you want something to be rendered at 50% width or not rendered at all. If you don't require this behaviour, you wouldn't use either class.</p>

    <pre>
        <code>
<!-- leave this line empty -->
.one-half {
    width: 50% !important;
}

.hidden {
    display: none !important;
}
        </code>
    </pre>

    <h2>Selector Intent</h2>

    <p>It is important when writing CSS that we scope our selectors correctly. Selector Intent is the process of deciding and defining what you want to style and how you will go about selecting it.</p>

    <p>For example, you want to style your website's main navigation menu. The following selector would possibly be an unwise choice:</p>

    <pre>
        <code>
<!-- leave this line empty -->
header ul { }
        </code>
    </pre>

    <p>The selector's intent is to style any &lt;ul&gt; element inside any &lt;header&gt; element. Our intent was to style only the main navigation of the website. Potentially, you can have any number of header elements on a page and in-turn they can house any number of possible &lt;ul&gt; elements, so a selector like this runs the risk of applying very specific styling to a very wide number of elements.</p>

    <p>A better approach would be an a selector that is selecting the right thing for the right reason:</p>

    <pre>
        <code>
<!-- leave this line empty -->
.site-nav { }
        </code>
    </pre>

    <h2>Naming Conventions</h2>

    <p>It's better to strive for reusable, recyclable CSS classes rather than writing for specific use cases when considering naming.</p>

    <pre>
        <code>
<!-- leave this line empty -->
/* Runs the risk of becoming out of date; hard to maintain */
.blue {
    color: blue;
}

/* Depends on location to render correctly */
.header span {
    color: blue;
}

/* Too specific */
.header-color {
    color: blue;
}

/* Portable and easily maintained - much better */
.highlight-color {
    color: blue;
}
        </code>
    </pre>

    <h2>Single Responsibility Principle</h2>

    <p>The single reponsibility principle is a paradigm that states that all pieces of code - in CSS, the classes - should focus on doing one thing and one thing only. In CSS, our classes should be small and focus on providing very specific and limited functionality.</p>

    <p>In this next example, our CSS classes handle quite a lot: layout, structure, and styling. This also includes a lot of repetition between classes.</p>

    <pre>
        <code>
<!-- leave this line empty -->
.error-message {
    display: block;
    padding: 10px;
    border-top: 1px solid #f00;
    border-bottom: 1px solid #f00;
    background-color: #fee;
    color: #f00;
    font-weight: bold;
}

.success-message {
    display: block;
    padding: 10px;
    border-top: 1px solid #0f0;
    border-bottom: 1px solid #0f0;
    background-color: #efe;
    color: #0f0;
    font-weight: bold;
}
        </code>
    </pre>

    <p>We can break these classes into smaller classes creating general abstraction:</p>

    <pre>
        <code>
<!-- leave this line empty -->
.box {
    display: block;
    padding: 10px;
}

.message {
    border-style: solid;
    border-width: 1px 0;
    font-weight: bold;
}

.message--error {
    background-color: #fee;
    color: #f00;
}

.message--success {
    background-color: #efe;
    color: #0f0;
}
        </code>
    </pre>

    <h2>CSS Performance</h2>

    <p>CSS is not the largest asset to consider during development, but it is one of the first the browser discovers. The browser is blocked from rendering the page until the CSS is downloaded and parsed, so it's always worthwhile to consider the performance of your CSS to make your stylesheets as lean as possible.</p>

    <h2>Shallow Selectors</h2>

    <p>Used correctly, shallow selectors can reduce kilobytes off the file size of your CSS stylesheets. As well as keeping your CSS tidy, the browser will also render the elements targeted by shallow selectors faster. Browsers read selectors from right to left. The deeper the selectors are, the longer it takes for the browser to render or re-render those elements.</p>

    <pre>
        <code>
<!-- leave this line empty -->
/* Deep selector example */
nav ul li.nav-item { }

/* Shallow selector example */
.nav-item { }
        </code>
    </pre>

    <h2>CSS Browser Support</h2>

    <p>Even in a world where the majority of browsers are Chromium-based, those browsers are not all running the same version of Chromium as Google Chrome. This means that other Chromium-based browsers might be a few versions behind Google Chrome.</p>

    <p>If you use a CSS property or value that a browser does not understand, the browser will ignore it. If the browser does not understand that line of CSS, it just skips it and gets on with the next thing it understands. Feature queries allow us to directly ask the browser what they support and then act on the response, just like a media query. Feature queries basically test for support of a CSS property and value. The content inside the feature query will only run of the browser responds with true - it supports the feature.</p>

    <h2>CSS Transition</h2>

    <p>CSS transitions allow you to change property values smoothly from one value to another, over a given duration.</p>

    <p>Browser support:</p>

    <ul>
        <li>IE10 and above</li>
        <li>Chrome 26 and above</li>
        <li>Firefox 16 and above</li>
        <li>Safari 6.1 and above</li>
    </ul>

    <p>Imagine you have an image. By default, this image has an opacity of 0.7. When hovering, this image will then have an opacity of 1.</p>

    <pre>
        <code>
<!-- leave this line empty -->
img {
    opacity: 1;
}

img:hover {
    opacity: 0.7;
}
        </code>
    </pre>

    <p>CSS transitions will give you the opportunity to do the same with style. We can therefore add a transition to our image.</p>

    <pre>
        <code>
<!-- leave this line empty -->
img {
    opacity: 1;
    transition: opacity .4s;
}

img:hover {
    opacity: 0.7;
}
        </code>
    </pre>

    <p>Transitions will make the transition between two properties smoother. You must always specify the property value at the start and then the finish. You may see this example being used:</p>

    <pre>
        <code>
<!-- leave this line empty -->
img {
    opacity: 1;
    transition: all .4s;
}
        </code>
    </pre>

    <p>You can write 'all' for all your transitions, but this will impact performance. If you only want the opacity (you only want to apply opacity), don't be lazy, specify it and avoid using 'all'.</p>

    <p>To continue with performance, you can use the will-change CSS property so the browser will know that this element will be subject to opacity changes and will prepare itself to handle it even smoother.</p>

    <p>will-change is intended to be used as a last resort in order to try to deal with existing performance problems. It should not be used to anticipate performance problems. It is also not supported in both IE (Internet Explorer) or Edge.</p>

    <pre>
        <code>
<!-- leave this line empty -->
img {
    opacity: 1;
    transition: all .4s;
    will-change: opacity;
}
        </code>
    </pre>

    <p>You can also change the way a transition is animating by changing its curve. You can choose between: ease, linear, ease-in, ease-out, ease-in-out, and cube-bezier.</p>

    <pre>
        <code>
<!-- leave this line empty -->
img {
    opacity: 1;
    transition: all .4s ease-in-out;
}
        </code>
    </pre>
</main>

</body>
</html>