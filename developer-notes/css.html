<!DOCTYPE html>
<html lang="en-GB">
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Developer Notes - CSS</title>

    <link rel="shortcut icon" type="image/ico" href="img/favicon/code.ico" />
    <link rel="stylesheet" href="styles/main.css" />
    <link rel="preload" href="fonts/nunito-v9-latin-regular.woff2" as="font" type="font/woff2" crossorigin />
</head>
<body>

<!-- REALLY USEFUL -->
<!-- https://toddmotto.com/stop-toggling-classes-with-js-use-behaviour-driven-dom-manipulation-with-data-states/ -->

<!-- https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Fonts/Variable_Fonts_Guide -->

<!-- https://developer.mozilla.org/en-US/docs/Learn/CSS/Introduction_to_CSS/Syntax -->
<!-- https://www.sitepoint.com/optimizing-css-performance/ -->
<!-- https://www.creativebloq.com/features/10-amazing-new-css-techniques -->
<!-- https://www.fifteendesign.co.uk/blog/an-introduction-to-css-flex-and-browser-compatibility-part-1/ -->

<!-- https://developer.mozilla.org/en-US/docs/Learn/CSS/Introduction_to_CSS/How_CSS_works -->

<!-- https://medium.com/@geoffrey.signorato/understand-the-concept-of-css-transitions-in-2-min-d731b8371f7f -->

<!-- Really useful -->
<!-- https://www.smashingmagazine.com/2018/12/common-css-issues-front-end-projects/ -->

<!--
CSS Selectors

https://codeburst.io/the-most-unused-css-selectors-ea8f75aacf10
https://medium.com/@aljullu/8-css-selectors-dos-and-don-ts-1e0d23fcf96c
-->

<!-- vh and vw -->
<!-- Browsers that support vw and vh include Chrome 49+, IE11, Edge 16+, Firefox 49+, Safari 11.1+, iOS Safari 10.3+ and Chrome for Android 66+. -->
<!-- fallback for vh and vw -->
<!-- https://stackoverflow.com/questions/23350510/how-to-write-css-fallbacks-for-vh-vw -->
<!-- height: 41px;
height: 5.2vh; -->
<!-- The browser sees height: 41px, as expected. It parses that, and knows what to do with it. Then, it sees height: 5.2vh. If the browser understands the vh unit, it will use that instead of 41px, just like color: blue;  color: red; would end up being red. If it doesn't understand the vh unit, it will ignore it, and, because we defined the fallback first, the fact that the browser ignores the vh unit doesn't matter.-->
<!-- https://css-tricks.com/the-trick-to-viewport-units-on-mobile/ -->

<header class="header" role="banner">
    <nav class="header__inner">
        <ul class="header__item header__item--links">
            <li class="header__link">
                <span class="header__link--background">
                    <a href="index.html">Home</a>
                </span>
            </li>
            <li class="header__link">
                <span class="header__link--background">
                    <a href="#main">Skip to content</a>
                </span>
            </li>
        </ul>
    </nav>
</header>

<main role="main" id="main">
    <h1>CSS (Cascading Style Sheets)</h1>

    <p>CSS describes how HTML elements are to be displayed/styled and can be used to control the layout or structure of multiple web pages. A CSS rule-set consists of a selector and a declaration block.</p>

    <p>When a browser encounters CSS, it renders what is within the stylesheet, however, if the browser encounters something like a property that it does not understand, it will simply be ignored.</p>

    <p>This design principle of CSS means that you can happily use new features in the knowledge that nothing bad will happen to a browser that doesn't have support. This is the basic idea behind progressive enhancement.</p>

    <p>You can use tools such as <a href=https://www.caniuse.com" target="_blank" rel="noopener noreferrer">caniuse</a> to check the status of features in CSS. A new feature that is not supported by all browsers can be used providing it does not break anything. Browsers that do not provide support will simply ignore the feature and new browsers will benefit from the new feature. Eventually it is hoped that older browsers will catch up and begin supporting newer features therefore we are future proofing our code.</p>

    <p>The selector points to the HTML element you want to style. The declaration block contains one or more declarations (statements) separated by semicolons. Each declaration includes a CSS property name and a property value, separated by a colon. The declaration block is surrounded by curly braces.</p>

    <p>CSS should be written across multiple lines. This reduces the chance of merge conflicts when using version control, because each CSS declaration exists on it's own line. Code can therefore be compared more easily as a single line only ever carries one change. If a CSS selector only has one declaration, then this will still confirm to this practice.</p>

    <pre>
        <code>
<!-- leave this line empty -->
/* Multiple declarations on single lines */
.icon {
    display: inline-block;
    width: 16px;
    height: 16px;
    background-image: url(/img/sprite.svg);
}

/* Acceptable CSS as single declaration */
.icon--home { background-position: 0 0; }
.icon--person { background-position: -16px 0; }
.icon--files { background-position: -16px -16px; }
        </code>
    </pre>

    <p>At its most basic level, CSS consists of two building blocks:</p>

    <ul>
        <li>Properties - Human-readable identifiers that indicate which stylistic feature you want to change (e.g. font, width, background colour).</li>
        <li>Values - Each specified property is given a value, which indicates how you want to change those stylistic features.</li>
    </ul>

    <pre>
        <code>
<!-- leave this line empty -->
selector {
    property: value;
}
        </code>
    </pre>

    <p>A property paired with a value is called a CSS declaration. CSS declarations are placed within curly braces. This is referred to as the CSS Declaration Block. The declaration block is paired with a selector to produce CSS Rulesets (sometimes known as CSS Rules).</p>

    <p>In the following example all &lt;p&gt; elements will be centrally-aligned with a colour applied. The &lt;p&gt; element is the selector and within the declaration block, you will find the declarations of 'color' and 'text-align' properties with their associated values.</p>

    <pre>
        <code>
<!-- leave this line empty -->
p {
    color: #00ff00;
    text-align: center;
}
        </code>
    </pre>

    <p>Should any properties or values not be recognised, the browser will simply ignore them.</p>

    <h2>Adding CSS to HTML</h2>

    <p>To add CSS to HTML it is recommended to use an external stylesheet. This is simply a file containing your CSS code that has the file extension of '.css' and can then be included within your HTML document. The CSS stylesheets can be grouped together in a single directory, usually named something like 'styles' within a project directory.</p>

    <p>External stylesheets allow you to change the look of an entire website by changing just a single CSS file.</p>

    <p>Begin by creating an external stylesheet named 'style.css'. We can then include our stylesheet within the HTML document. Each HTML page must include a reference to the external stylesheet file inside the &lt;link&gt; element. The &lt;link&gt; element is placed inside the &lt;head&gt; section of your HTML.</p>

    <pre>
        <code>
<!-- leave this line empty -->
&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="utf-8" /&gt;

    &lt;title&gt;My Website&lt;/title&gt;

    &lt;!-- CSS stylesheets --&gt;
    &lt;link rel="stylesheet" href="styles/style.css" /&gt;
&lt;/head&gt;
        </code>
    </pre>

    <p>Should you see an external CSS stylesheet with the filename that contains 'min', this is likely to be a minified file.</p>

    <pre>
        <code>
<!-- leave this line empty -->
&lt;link rel="stylesheet" href="styles/style.min.css" /&gt;
        </code>
    </pre>

    <h2>Comments</h2>

    <p>Comments in CSS begin with /* and end with */</p>

    <pre>
        <code>
<!-- leave this line empty -->
/* This is a comment in CSS */
        </code>
    </pre>

    <h2>CSS Box Model</h2>

    <p>All HTML elements can be considered as boxes. In CSS, the term "box model" is used when talking about design and layout. The CSS box model is essentially a box that wraps around every HTML element. It consists of: margin, border, padding, and the actual content.</p>

    <ul>
        <li>Content - the content of the box, where text, images and other content appears.</li>
        <li>Padding - clears an area around the content but inside the defined border. Is transparent.</li>
        <li>Border - border that goes around the padding and content.</li>
        <li>Margin - clears an area outside the border. Is transparent.</li>
    </ul>

    <p>The box model allows us to add a border around elements and to define space between elements.</p>

    <h2>Selecting Elements</h2>

    <p>An explination as to how we can use CSS to select HTML elements. Here is a simple HTML structure to demonstrate.</p>

    <pre>
        <code>
<!-- leave this line empty -->
&lt;div class="container"&gt;
    &lt;!-- Child element(s) --&gt;
    &lt;p&gt;Paragraph one.&lt;/p&gt;
    &lt;p&gt;Paragraph two.&lt;/p&gt;

    &lt;div class="container-summary"&gt;
        &lt;!-- Grandchild elements(s) --&gt;
        &lt;p&gt;Paragraph three.&lt;/p&gt;
    &lt;/div&gt;

    &lt;!-- Child element(s) --&gt;
    &lt;p&gt;Paragraph four.&lt;/p&gt;
    &lt;p&gt;Paragraph five.&lt;/p&gt;
&lt;/div&gt;
        </code>
    </pre>

    <h3>Space</h3>

    <p>This is called a descendent selector. In this example, it will target all &lt;p&gt; tags within the container &lt;div class="container"&gt; and set the font-weight to be bold.</p>

    <pre>
        <code>
<!-- leave this line empty -->
.container p {
    font-weight: bold;
}
        </code>
    </pre>

    <h3>The Child Combinator (&gt;)</h3>

    <p>The child combinator (&gt;), will only target direct children of a particular element. Only elements that are nested directly within the &lt;div class="container"&gt; element, and not any paragraphs nested further within - such as within &lt;div class="container-summary"&gt; (a grandchild element) - will have the styling applied.</p>

    <p>Styling will only be applied to child elements and not grandchild elements of the parent.</p>

    <pre>
        <code>
<!-- leave this line empty -->
.container > p {
    font-weight: bold;
}
        </code>
    </pre>

    <h3>Adjacent Sibling Combinator (+)</h3>

    <p>Combines two sequences of simple selectors having the same parent and the second one must come immediately after the first. It will only select the first element that is immediately preceded by the former selector. In our example, it will target only 'Paragraph four.' because the &lt;p&gt; element comes just after the &lt;div class="container-summary"&gt; element in our HTML.</p>

    <pre>
        <code>
<!-- leave this line empty -->
.container-summary + p {
    font-weight: bold;
}
        </code>
    </pre>

    <h3>~ Sign</h3>

    <p>Select all elements that preceded the former selector. Therefore, we can use this selector to target all &lt;p&gt; elements that come after the &lt;div class="container-summary"&gt; element.</p>

    <pre>
        <code>
<!-- leave this line empty -->
.container-summary ~ p {
    font-weight: bold;
}
        </code>
    </pre>

    <h3>Universal Selectors</h3>

    <p>Universal selectors like *, [disabled] and [type="text"], check every element in the DOM for a match. This can be very expensive for the browser. This is often used for box-sizing and other globals.</p>

    <pre>
        <code>
<!-- leave this line empty -->
* {
    box-sizing: border-box;
}
        </code>
    </pre>

    <h3>Repetitive</h3>

    <p>You can select elements using CSS that have repetitive suffix.</p>

    <pre>
        <code>
<!-- leave this line empty -->
div[id$="_LoginPanel"] {
    /* CSS stuff here */
}
        </code>
    </pre>

    <p>This is useful if you want to target a specific element that has a dynamic suffix like this:</p>

    <pre>
        <code>
<!-- leave this line empty -->
&lt;div id="01234_LoginPanel"&gt; ... &lt;/div&gt;
        </code>
    </pre>

    <p>You can also target elements with specific prefixes:</p>

    <pre>
        <code>
<!-- leave this line empty -->
div[class^="myPanel_"] {
    /* CSS stuff here */
}
        </code>
    </pre>

    <p>And here is the HTML:</p>

    <pre>
        <code>
<!-- leave this line empty -->
&lt;div id="myPanel_12345"&gt; ... &lt;/div&gt;
        </code>
    </pre>

    <p>But perhaps you want to check if an element contains a parameter, maybe a suffix and prefix:</p>

    <pre>
        <code>
<!-- leave this line empty -->
div[class*="logoutPanel"] {
    /* CSS stuff here */
}
        </code>
    </pre>

    <p>The HTML may look something like this:</p>

    <pre>
        <code>
<!-- leave this line empty -->
&lt;div id="1gdug_logoutPanel_1234"&gt; ... &lt;/div&gt;
        </code>
    </pre>

    <h2>Pseudo Selectors</h2>

    <p>Pseudo class selectors are CSS selecors with a colon preceding them. Links often use pseudo classes for styling interaction.</p>

    <pre>
        <code>
<!-- leave this line empty -->
a:hover {}
a:active {}
a:focus {}
a:visited {}

div:first-child {}
div:last-child {}
div:checked {}
        </code>
    </pre>

    <p>These selectors come in handy when accessing specific elements as well as focusing on element states.</p>

    <h3>::first-letter</h3>

    <p>Pseudo class selector allowing you to target the first letter of a paragraph or element.</p>

    <pre>
        <code>
<!-- leave this line empty -->
p::first-letter {
    /* CSS styling here */
}
        </code>
    </pre>

    <p>You can chain together pseudo selectors to target only the first paragraph.</p>

    <pre>
        <code>
<!-- leave this line empty -->
p:first-child::first-letter {
    /* CSS styling here */
}
        </code>
    </pre>

    <h3>:first-of-type</h3>

    <p>pseudo selector used to select the first of any type within the current parent element and target it using CSS.</p>

    <pre>
        <code>
<!-- leave this line empty -->
article:first-of-type {
    /* CSS styling here */
}

article:last-of-type {
    /* CSS styling here */
}
        </code>
    </pre>

    <h3>:only-of-type</h3>

    <p>This structural pseudo class can be used to target elements that do not have any siblings within its parent class. As an example, lets target all &lt;ul&gt; elements that have a single list item &lt;li&gt;</p>

    <pre>
        <code>
<!-- leave this line empty -->
li:only-of-type {
    /* CSS styling here */
}
        </code>
    </pre>

    <p>You could do ul li, but this would target all list items.</p>

    <h3>:empty</h3>

    <p>This pseudo class represents an element that has no content within it. When you use an editor, for example, you may have multiple empty elements such as &lt;p&gt;&lt;/p&gt; in your rendered HTML. If you don't want the empty elements to appear on the page.</p>

    <pre>
        <code>
<!-- leave this line empty -->
p:empty {
    display: none;
}
        </code>
    </pre>

    <h3>[attr=value]</h3>

    <p>Attribute selectors let you target an element based on its attributes. In this example, we've used an attribute selector that will target all the links whose href attribute ends with .pdf</p>

    <pre>
        <code>
<!-- leave this line empty -->
a[href$=".pdf"] {
    /* CSS styling here */
}
        </code>
    </pre>

    <h2>How to use CSS selectors</h2>

    <p>Use one class selectors where possible. This will keep specificity low and will avoid using too generic classes. This will also help avoid code conflicts with other developers' code.</p>

    <pre>
        <code>
<!-- leave this line empty -->
.button.active {
    /* Bad code */
}

.button-active {
    /* Good code */
}
        </code>
    </pre>

    <p>Decouple selectors from HTML structure. This allows you to change HTML structure and keep your CSS working.</p>

    <pre>
        <code>
<!-- leave this line empty -->
.header nav li button {
    /* Bad code */
}

.header-button {
    /* Good code */
}
        </code>
    </pre>

    <p>Order selectors by HTML occurance. Order them in the same order they appear in the HTML.</p>

    <pre>
        <code>
<!-- leave this line empty -->
/* Bad */
footer {}
header {}

/* Good */
header {}
footer {}
        </code>
    </pre>

    <p>Order selectors by specificity. A CSS rule should never be overwritten by another rule appearing before.</p>

    <pre>
        <code>
<!-- leave this line empty -->
/* Bad */
.list-item:first-child {}
.list-item {}
.list-item:last-child {}

/* Good */
.list-item {}
.list-item:first-child {}
.list-item:last-child {}
        </code>
    </pre>

    <p>Avoid using tag selectors if possible to keep specificity as low as possible. Never use id selectors and avoid !important</p>

    <pre>
        <code>
<!-- leave this line empty -->
/* Bad */
.content #intro .icon {}

/* Good */
.intro-icon {}
        </code>
    </pre>

    <p>Selectors should descrive purpose, not style.</p>

    <pre>
        <code>
<!-- leave this line empty -->
/* Bad */
.blue-text {
    /* Bad code as this can become color: red, and doesn't make any sense
}

/* Good */
.highlighted-text {
    /* CSS code here */
}
        </code>
    </pre>

    <h3>Naming Convention</h3>

    <p>This is a hyphen delimiter. You can also use a more structured naming convention such as BEM.</p>

    <pre>
        <code>
<!-- leave this line empty -->
/* Bad code */
.redBox {
    fontWeight: 10em;
}

/* Good code */
.red-box {
    font-weight: 10em;
}
        </code>
    </pre>

    <p>One way to mitigate issues when using CSS and JavaScript is to use a js-* class name (JavaScript hook) to denote a relationship with the DOM element in question. This helps to separate the CSS styling from the JavaScript functionality.</p>

    <pre>
        <code>
<!-- leave this line empty -->
&lt;div class="site-navigatation js-site-navigation"&lt;&lt;/div&gt;
        </code>
    </pre>

    <h3>The "rel" attribute</h3>

    <p>The rel attribute defines the relationship that the linked resource has to the document from which it's referenced.</p>

    <pre>
        <code>
<!-- leave this line empty -->
&lt;div class="site-navigation" rel="js-site-navigation"&gt; ... &lt;/div&gt;
        </code>
    </pre>

    <p>The JavaScript would look something like this:</p>

    <pre>
        <code>
<!-- leave this line empty -->
var nav = document.querySelector("[rel='js-site-navigation']");
        </code>
    </pre>

    <p>The CSS would remain the same and you may come across this in some codebases. JavaScript hooks should not use data-attributes, as they are used to store custom data.</p>

    <h2>Shorthand Properties</h2>

    <p>Some properties such as font, background, padding, border, and margin are called shorthand properties. This is because they allow you to set several property values in a single line using one property. This saves you time and makes your code smaller.</p>

    <pre>
        <code>
<!-- leave this line empty -->
padding: 10px 15px 15px 5px;
        </code>
    </pre>

    <p>The above shorthand does the same as the following:</p>

    <pre>
        <code>
<!-- leave this line empty -->
padding-top: 10px;
padding-right: 15px;
padding-bottom: 15px;
padding-left: 5px;
        </code>
    </pre>

    <h2>Links</h2>

    <p>Links can be styled with any CSS property (e.g. color, font-family, background, etc.). In addition, links can be styled differently depending on what state they are in. The four links states are:</p>

    <ul>
        <li>a:link - a normal, unvisited link.</li>
        <li>a:visited - a link the user has visited.</li>
        <li>a:hover - a link when the user mouses over it.</li>
        <li>a:active - a link the moment it is clicked.</li>
    </ul>

    <p>When setting the style for link states, there are some order rules:</p>

    <ul>
        <li>a:hover MUST come after a:link and a:visited</li>
        <li>a:active MUST come after a:hover</li>
    </ul>

    <pre>
        <code>
<!-- leave this line empty -->
a:link {
    color: #ff00ff;
}

a:visited {
    color: #00ff00;
}

a:hover {
    text-decoration: none;
}

a:active {
    color: #0000ff;
}
        </code>
    </pre>

    <h2>Text Colour</h2>

    <p>The color property is used to set the colour of text on your page. The default colour for a page is defined in the body selector. The colour can be specified by:</p>

    <ul>
        <li>Colour name - like "red"</li>
        <li>HEX value - like "#ff0000"</li>
        <li>RGB value - like "rgb(255, 0, 0)"</li>
    </ul>

    <pre>
        <code>
<!-- leave this line empty -->
body {
    color: #ff0000;
}

h1 {
    color: rgb(255, 0, 0);
}
        </code>
    </pre>

    <h2>CSS Display Property</h2>

    <p>The CSS display property specifies if, or how, an element is displayed. Every HTML element has a default display value depending on what type of element it is. The default display value for most elements is block or inline.</p>

    <p>You can override the an element's default display value. Changing an inline element to a block element, or vice versa, can be useful for changing how your page looks and still following web standards. Setting the display property of an element only changes how the element is displayed and not what kind of element it is. An inline element with 'display: block;' is not allowed to have other block elements inside it.</p>

    <p>A common example is making a &lt;li&gt; element inline for horizontal menus/lists:</p>

    <pre>
        <code>
<!-- leave this line empty -->
li {
    display: inline;
}
        </code>
    </pre>

    <h3>Block Element</h3>

    <p>A block-level element always starts on a new line and takes up the full width available (stretches out to the left and right as far as it can). Examples of block-level elements:</p>

    <ul>
        <li>&lt;div&gt;</li>
        <li>&lt;h1&gt; to &lt;h6&gt;</li>
        <li>&lt;p&gt;</li>
        <li>&lt;header&gt;</li>
        <li>&lt;footer&gt;</li>
        <li>&lt;section&gt;</li>
    </ul>

    <h3>Inline Elements</h3>

    <p>An inline element does not start on a new line and only takes up as much width as necessary. Examples include:</p>

    <ul>
        <li>&lt;span&gt;</li>
        <li>&lt;a&gt;</li>
        <li>&lt;img&gt;</li>
    </ul>

    <h3>Hiding Elements</h3>

    <p>The display property is used to specify how an element should be displayed. The visibility property specifies whether or not an element should be visible.</p>

    <p>Hiding an element can be done by setting the display property to 'none'. The element will be hidden and the page will be displayed as if the element is not there.</p>

    <pre>
        <code>
<!-- leave this line empty -->
p {
    display: none;
}
        </code>
    </pre>

    <p>Setting the visibility property to 'hidden' will hide the element, but the element will still take up the same space as before and this can affect the layout of your page.</p>

    <pre>
        <code>
<!-- leave this line empty -->
p {
    visibility: hidden;
}
        </code>
    </pre>

    <h2>CSS Performance</h2>

    <p>Loading a CSS file blocks the page rendering, so this should be considered if you have a large stylesheet or multiple stylesheets. Using Google page analysis tools, you may often see suggestions such as 'inline critical CSS' or 'reduce render-blocking stylesheets'. CSS performance can therefore be improved with the following steps:</p>

    <ul>
        <li>Extract the styles used to render elements above the folder and add those to a &lt;style&gt; element in the HTML &lt;head&gt;.</li>
        <li>Load the main CSS file asynchronously using JavaScript, perhaps after the page has loaded.</li>
    </ul>

    <h3>Progressive Rendering</h3>

    <p>Rather than using a single site-wide CSS stylesheet, progressive rendering is a technique that defines individual stylesheets for separate components. Each is loaded immediately before a component is referenced in the HTML.</p>

    <p>Each &lt;link&gt; still blocks rendering, but for a shorter time because the file is smaller. The page becomes usable sooner, because each component renders in sequence.</p>

    <p>Progressive rendering could benefit large sites where individual pages are constructured from a selection of different components.</p>

    <pre>
        <code>
<!-- leave this line empty -->
&lt;head&gt;
    &lt;!-- core styles used across components --&gt;
    &lt;link rel="stylesheet" href="base.css" /&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;!-- header component --&gt;
    &lt;link rel="stylesheet" href="header.css" /&gt;
    &lt;header&gt; ... &lt;/header&gt;

    &lt;!-- primary content --&gt;
    &lt;link rel="stylesheet" href="content.css" /&gt;
    &lt;main&gt;
            &lt;!-- form styling --&gt;
            &lt;form&gt; ... &lt;/form&gt;
    &lt;/main&gt;

    &lt;!-- footer component --&gt;
    &lt;link rel="stylesheet" href="footer.css" /&gt;
    &lt;footer&gt; ... &lt;/footer&gt;
&lt;/body&gt;
        </code>
    </pre>

    <h2>Prefixes</h2>

    <p>Prefixes are no-longer as required as they once were. CSS properties that begin with a dash were considered as prototype properties and were not initially intended for production browser releases but have stuck around. When using tools such as Autoprefixer we have to consider if this is required at all as extra code is generated as a result which can impact performance slightly.</p>

    <h2>Feature Query</h2>

    <p>CSS has developed a way for you to test for browser support of new CSS features, with Feature Queries. A Feature Query behaves in much the same way as a Media Query, except that instead of asking the browser something about the device being used to view the site, a Feature Query asks the browser if it supports a particular CSS feature. This makes it easier to use new features in a safe, progressively enhanced way.</p>

    <p>You don't need to use a feature query to test for every property you want to use, only something which would indicate support for the features you are planning to use.</p>

    <p>You should first write your CSS for browsers which do not support the feature then test for support of the property you want to use. If the browser confirms it has support it will overwrite the fallback code with your new code.</p>

    <p>This is pretty much the same process that you might adopt when using media queries for responsive design following a mobile-first approach. In that approach, you start with your layout for smaller screens then add or overwrite things for larger ones as you move up through your breakpoints.</p>

    <p>This way of working means that you don't need to worry about browsers which do not support Feature Queries. It is likely that the new features we want to use are also not supported in IE (as with support for Feature Queries), so you'll always start by writing your CSS for browsers without the support for the new feature then test with a Feature Query. The Feature Query will test for the support.</p>

    <p>Feature queries can be used in-place of tools such as Modernizr, but is only supported in the most modern browsers.</p>

    <pre>
        <code>
<!-- leave this line empty -->
/* CSS rules for browsers that support grid layout */
@supports (display: grid) {
    .item {
        /* CSS from browsers which do not support grid layout */
    }
}

/* Not supported */
@supports not (display: grid) {
    .item {
        /* CSS from browsers which do not support grid layout */
    }
}
        </code>
    </pre>

    <p>Browser support for Feature Queries is good, but not supported in Internet Explorer (IE11) and below. As long as you test for support and then write the code for supporting browsers, you can overwrite anything you need for older browsers.</p>

    <p>It is likely that most modern and new features you want to use are not supported by Internet Explorer (IE) so, at present, you will almost always start by writing CSS for browsers without support then test with a feature query. The feature query should test for support.</p>

    <p>Browsers which support feature queries will return true if they have support and so the code inside the query will be used. This will overwrite the code for older browsers.</p>

    <p>Anything new that comes into CSS you can use Feature Queries to test for and allows us to use new features much more quickly.</p>

    <p>A good example when using feature queries maybe to check for the availability to use <a href="css-variables.html">CSS variables</a>. Here is an example:</p>

    <pre>
        <code>
<!-- leave this line empty -->
/* Use CSS variable */
/* support: http://caniuse.com/#feat=css-variables */
@supports (background-color: var(--bg-color)) {
    body {
        background-color: var(--bg-color);
    }
}

@supports not(background-color: var(--bg-color)) {
    body {
        background-color: #ff6347;
    }
}
        </code>
    </pre>

    <h2>Selector Support</h2>

    <p>Currently Feature queries can only test CSS properties and values. We may want to also test support for selectors. For example, if you visit <strong>about:config</strong> in Firefox and enable the flag <strong>layout.css.supports-selector.enabled</strong>, you can test to see if various selectors are supported. For example, the test for the :has selector:</p>

    <pre>
        <code>
<!-- leave this line empty -->
@support selector(:has) {
    .item {
        /* CSS for support of :has */
    }
}
        </code>
    </pre>

    <p>This is a specification in development currently.</p>

    <h2>CSS Reset</h2>

    <p>A CSS Reset allows you to start with a clean code base, making it easier to style your website with more predictable outcomes. A CSS Reset resets or overrides the default styles of the browser. You can write your own, or use an existing CSS reset that maybe available.</p>

    <h2>DRY - Don't Repeat Yourself</h2>

    <p>CSS is best written when it follows the DRY (Don't Repeat Yourself) principle. This helps us to avoid writing the same bits of code over and over again. One way to keep our CSS DRY is to group things together.</p>

    <pre>
        <code>
<!-- leave this line empty -->
/* This is not DRY CSS */
.menu li {
    color: red;
}

.menu li a {
    color: red;
}

/* This is DRY CSS */
.main li,
.main li a {
    color: red;
}
        </code>
    </pre>

    <h2>!important Declaration</h2>

    <p>The !important declaration is almost always a bad thing to use within your CSS. It is generally misused to override CSS declarations to apply new styling. Often it is used to combat specificity problems as a result of poorly architected CSS, to force styling to be applied. Proactive use of !important is when it is used before you encounter any specificity problems; when it is used as a guatantee rather than as a fix. Therefore !important should only be used to ensure something is styled a certain way and it won't get accidentally overridden by something more specific.</p>

    <p>In this example, two helper (or utility) CSS classes are very specific in their intentions. You would only use them should you want something to be rendered at 50% width or not rendered at all. If you don't require this behaviour, you wouldn't use either class.</p>

    <pre>
        <code>
<!-- leave this line empty -->
.one-half {
    width: 50% !important;
}

.hidden {
    display: none !important;
}
        </code>
    </pre>

    <h2>Selector Intent</h2>

    <p>It is important when writing CSS that we scope our selectors correctly. Selector Intent is the process of deciding and defining what you want to style and how you will go about selecting it.</p>

    <p>For example, you want to style your website's main navigation menu. The following selector would possibly be an unwise choice:</p>

    <pre>
        <code>
<!-- leave this line empty -->
header ul { }
        </code>
    </pre>

    <p>The selector's intent is to style any &lt;ul&gt; element inside any &lt;header&gt; element. Our intent was to style only the main navigation of the website. Potentially, you can have any number of header elements on a page and in-turn they can house any number of possible &lt;ul&gt; elements, so a selector like this runs the risk of applying very specific styling to a very wide number of elements.</p>

    <p>A better approach would be an a selector that is selecting the right thing for the right reason:</p>

    <pre>
        <code>
<!-- leave this line empty -->
.site-nav { }
        </code>
    </pre>

    <h2>Naming Conventions</h2>

    <p>It's better to strive for reusable, recyclable CSS classes rather than writing for specific use cases when considering naming.</p>

    <pre>
        <code>
<!-- leave this line empty -->
/* Runs the risk of becoming out of date; hard to maintain */
.blue {
    color: blue;
}

/* Depends on location to render correctly */
.header span {
    color: blue;
}

/* Too specific */
.header-color {
    color: blue;
}

/* Portable and easily maintained - much better */
.highlight-color {
    color: blue;
}
        </code>
    </pre>

    <h2>Single Responsibility Principle</h2>

    <p>The single reponsibility principle is a paradigm that states that all pieces of code - in CSS, the classes - should focus on doing one thing and one thing only. In CSS, our classes should be small and focus on providing very specific and limited functionality.</p>

    <p>In this next example, our CSS classes handle quite a lot: layout, structure, and styling. This also includes a lot of repetition between classes.</p>

    <pre>
        <code>
<!-- leave this line empty -->
.error-message {
    display: block;
    padding: 10px;
    border-top: 1px solid #f00;
    border-bottom: 1px solid #f00;
    background-color: #fee;
    color: #f00;
    font-weight: bold;
}

.success-message {
    display: block;
    padding: 10px;
    border-top: 1px solid #0f0;
    border-bottom: 1px solid #0f0;
    background-color: #efe;
    color: #0f0;
    font-weight: bold;
}
        </code>
    </pre>

    <p>We can break these classes into smaller classes creating general abstraction:</p>

    <pre>
        <code>
<!-- leave this line empty -->
.box {
    display: block;
    padding: 10px;
}

.message {
    border-style: solid;
    border-width: 1px 0;
    font-weight: bold;
}

.message--error {
    background-color: #fee;
    color: #f00;
}

.message--success {
    background-color: #efe;
    color: #0f0;
}
        </code>
    </pre>

    <h2>CSS Performance</h2>

    <p>CSS is not the largest asset to consider during development, but it is one of the first the browser discovers. The browser is blocked from rendering the page until the CSS is downloaded and parsed, so it's always worthwhile to consider the performance of your CSS to make your stylesheets as lean as possible.</p>

    <h2>Shallow Selectors</h2>

    <p>Used correctly, shallow selectors can reduce kilobytes off the file size of your CSS stylesheets. As well as keeping your CSS tidy, the browser will also render the elements targeted by shallow selectors faster. Browsers read selectors from right to left. The deeper the selectors are, the longer it takes for the browser to render or re-render those elements.</p>

    <pre>
        <code>
<!-- leave this line empty -->
/* Deep selector example */
nav ul li.nav-item { }

/* Shallow selector example */
.nav-item { }
        </code>
    </pre>

    <h2>CSS Browser Support</h2>

    <p>Even in a world where the majority of browsers are Chromium-based, those browsers are not all running the same version of Chromium as Google Chrome. This means that other Chromium-based browsers might be a few versions behind Google Chrome.</p>

    <p>If you use a CSS property or value that a browser does not understand, the browser will ignore it. If the browser does not understand that line of CSS, it just skips it and gets on with the next thing it understands. Feature queries allow us to directly ask the browser what they support and then act on the response, just like a media query. Feature queries basically test for support of a CSS property and value. The content inside the feature query will only run of the browser responds with true - it supports the feature.</p>

    <h2>CSS Transition</h2>

    <p>CSS transitions allow you to change property values smoothly from one value to another, over a given duration.</p>

    <p>Browser support:</p>

    <ul>
        <li>IE10 and above</li>
        <li>Chrome 26 and above</li>
        <li>Firefox 16 and above</li>
        <li>Safari 6.1 and above</li>
    </ul>

    <p>Imagine you have an image. By default, this image has an opacity of 0.7. When hovering, this image will then have an opacity of 1.</p>

    <pre>
        <code>
<!-- leave this line empty -->
img {
    opacity: 1;
}

img:hover {
    opacity: 0.7;
}
        </code>
    </pre>

    <p>CSS transitions will give you the opportunity to do the same with style. We can therefore add a transition to our image.</p>

    <pre>
        <code>
<!-- leave this line empty -->
img {
    opacity: 1;
    transition: opacity .4s;
}

img:hover {
    opacity: 0.7;
}
        </code>
    </pre>

    <p>Transitions will make the transition between two properties smoother. You must always specify the property value at the start and then the finish. You may see this example being used:</p>

    <pre>
        <code>
<!-- leave this line empty -->
img {
    opacity: 1;
    transition: all .4s;
}
        </code>
    </pre>

    <p>You can write 'all' for all your transitions, but this will impact performance. If you only want the opacity (you only want to apply opacity), don't be lazy, specify it and avoid using 'all'.</p>

    <p>To continue with performance, you can use the will-change CSS property so the browser will know that this element will be subject to opacity changes and will prepare itself to handle it even smoother.</p>

    <p>will-change is intended to be used as a last resort in order to try to deal with existing performance problems. It should not be used to anticipate performance problems. It is also not supported in both IE (Internet Explorer) or Edge.</p>

    <pre>
        <code>
<!-- leave this line empty -->
img {
    opacity: 1;
    transition: all .4s;
    will-change: opacity;
}
        </code>
    </pre>

    <p>You can also change the way a transition is animating by changing its curve. You can choose between: ease, linear, ease-in, ease-out, ease-in-out, and cube-bezier.</p>

    <pre>
        <code>
<!-- leave this line empty -->
img {
    opacity: 1;
    transition: all .4s ease-in-out;
}
        </code>
    </pre>

    <h2>Common CSS fixes</h2>

    <p>Here is a collection of common CSS fixes for common CSS issues that may come in useful.</p>

    <h3>Reset the Backgrounds of Elements</h3>

    <p>When adding a button, reset its background or else if will look different across browsers. For example, if you don't reset the background, Chrome will show the button correctly, but Safari may add a default gray background. Resetting the background will solve this issue.</p>

    <pre>
        <code>
<!-- leave this line empty -->
button {
    appearance: none;
    background: transparent;
}
        </code>
    </pre>

    <h3>Setting max-width for Images</h3>

    <p>When adding an image, define max-width: 100%, so that the image resizes when the screen is small, otherwise the browser will show a horizontal scroll bar.</p>

    <pre>
        <code>
<!-- leave this line empty -->
img {
    max-width: 100%;
}
        </code>
    </pre>

    <p>Go to the <a href="images.html">images</a> document for more details.</p>

    <h2>CSS3 calc() function</h2>

    <p>The CSS3 calc() function performs a calculation to be used as a property value. This function is supported in IE9 (Internet Explorer 9) and above.</p>

    <p>The following example shows how to use the calc() function to calculate the width of a &lt;div&gt; element:</p>

    <pre>
        <code>
<!-- leave this line empty -->
div {
    width: calc(100% - 100px);
}
        </code>
    </pre>

    <p>This would create a &lt;div&gt; that would stretch across the window with a 50px gap between both sides of the &lt;div&gt; and the edges of the window.</p>

    <h2>Using Data States</h2>

    <p>You don't always need to use a class to manipulate the state of elements. Behaviour is separate to style and it can be a challenge to avoid crossing the line. Anything beyond using :hover pseudo to style your components, usually requires the use of JavaScript.</p>

    <p>When building web applications, its good to think about the element states such as open, visible, toggled, selected, and many more. It depends what your components are doing. This is what we could look to use:</p>

    <pre>
        <code>
<!-- leave this line empty -->
.my-class {}
.my-class.isSelected {}

// BEM example
.my-class {}
.my-class--selected {}
        </code>
    </pre>

    <p>To achieve something better, we could use data-state attributes for managing this.</p>

    <p>Using data-* attributes for managing behaviour is a really good way of abstracting the interactive layer of our code. This attribute is supported in all browsers greater than IE8. Your CSS would look something like this:</p>

    <pre>
        <code>
<!-- leave this line empty -->
.menu {
  /* generic styles */
}

.menu[data-state=closed] {
    display: none;
    background: blue;
}

.menu[data-state=open] {
    display: inherit;
    background: red;
}
        </code>
    </pre>

    <p>This line of code sets a data-state attribute, checks the current value and then uses the alternative value as a simple toggle.</p>

    <pre>
        <code>
<!-- leave this line empty -->
elem.setAttribute('data-state', elem.getAttribute('data-state') === 'open' ? 'closed' : 'open');
        </code>
    </pre>

    <p>Putting it all together:</p>

    <pre>
        <code>
<!-- leave this line empty -->
var nav = document.querySelector('.nav__toggle');
var toggleState = function (elem, one, two) {
    var elem = document.querySelector(elem);
    elem.setAttribute('data-state', elem.getAttribute('data-state') === one ? two : one);
};

nav.onclick = function (e) {
    toggleState('.nav ul', 'closed', 'open');
    e.preventDefault();
};

// ES5 using .bind() #ftw
// nav.addEventListener('click', toggleState.bind(null, '.nav ul', 'closed', 'open'), false);
        </code>
    </pre>

    <p>And here is the HTML markup:</p>

    <pre>
        <code>
<!-- leave this line empty -->
&lt;nav class="nav"&gt;
    &lt;a href="#" class="nav__toggle"&gt;Menu&lt;/a&gt;
    &lt;ul data-state="closed"&gt;
        &lt;li&gt;Item 1&lt;/li&gt;
        &lt;li&gt;Item 2&lt;/li&gt;
        &lt;li&gt;Item 3&lt;/li&gt;
        &lt;li&gt;Item 4&lt;/li&gt;
    &lt;/ul&gt;
&lt;/nav&gt;
        </code>
    </pre>

    <h2>VH &amp; VW units</h2>

    <p>There are four viewport based units in CSS. These are vh (Viewport Height), vw (Viewport Width), vmin and vmax. They are truly responsive length units.</p>

    <p>Viewport Height (vh) is based on the height of the viewport. A value of 1vh is equal to 1% of the viewport height. Viewport Width (vw) is based on the width of the viewport and 1vw is equal to 1% of the viewport width. If the viewport is 1200px wide and 1000px hight, the value of 10vw will be 120px and the value of 10vh will be 100px. Since these units are based on viewport dimensions, it is very convenient to use them in situations where width, height or size of elements neds to be set relative to the viewport.</p>

    <p>It is very common to set background images on elements that fully cover the screen. You may want to design a website where each individual section has to cover the entire screen. In such cases, you can set the width of the respective elements to be equal to 100% and set their height equal to 100vh.</p>

    <pre>
        <code>
<!-- leave this line empty -->
&lt;div class="fullscreen" id="a"&gt;
    &lt;p&gt;a&lt;/p&gt;
&lt;/div&gt;

&lt;div class="fullscreen" id="b"&gt;
    &lt;p&gt;b&lt;/p&gt;
&lt;/div&gt;


.fullscreen {
    width: 100%;
    height: 100vh;
    padding: 40vh;
}

#a {
    background: url('https://s3-us-west-2.amazonaws.com/s.cdpn.io/123941/vwa.jpg') center/cover;
}

#b {
    background-color: #eaeaea;
}
        </code>
    </pre>

    <p>Most browsers fully support these units. IE11 does not support the vmax unit, but you can use these units with confidence in new projects, as detailed by <a href="https://caniuse.com/#feat=viewport-units" target="_blank" rel="noopener noreferrer">caniuse</a>.
</main>

</body>
</html>