<!DOCTYPE html>
<html lang="en-GB">
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Developer Notes - Testing & TDD</title>

    <link rel="shortcut icon" type="image/ico" href="img/favicon/code.ico" />
    <link rel="stylesheet" href="styles/main.css" />
    <link rel="preload" href="fonts/nunito-v9-latin-regular.woff2" as="font" type="font/woff2" crossorigin />
</head>
<body>

<!-- https://airbnb.io/enzyme/docs/installation/react-16.html -->
<!-- https://jestjs.io/ -->
<!-- https://marmelab.com/blog/2015/06/24/jest-in-practice.html -->
<!-- https://medium.com/wehkamp-techblog/unit-testing-your-react-application-with-jest-and-enzyme-81c5545cee45 -->
<!-- https://medium.com/codeclan/testing-react-with-jest-and-enzyme-20505fec4675 -->
<!-- https://code.tutsplus.com/articles/the-beginners-guide-to-unit-testing-what-is-unit-testing--wp-25728 -->
<!-- https://www.guru99.com/unit-testing-guide.html -->
<!-- https://medium.freecodecamp.org/test-driven-development-what-it-is-and-what-it-is-not-41fa6bca02a2 -->
<!-- https://news.codecademy.com/test-driven-development/ -->
<!-- https://www.bignerdranch.com/blog/why-do-javascript-test-frameworks-use-describe-and-beforeeach/ -->

<!-- https://medium.com/opendoor-labs/testing-react-components-with-jest-a7e8e4d312d8 -->
<!-- https://medium.com/@rickhanlonii/understanding-jest-mocks-f0046c68e53c -->
<!-- https://flaviocopes.com/jest/ -->

<!-- https://jestjs.io/docs/en/configuration.html -->
<!-- https://www.npmjs.com/package/enzyme-to-json -->
<!-- https://blog.logrocket.com/testing-with-jest-from-zero-to-hero-85ce0e9cc953 -->

<!-- https://medium.com/codeclan/mocking-es-and-commonjs-modules-with-jest-mock-37bbb552da43 -->

<!-- Selenium WebDriver e2e tests -->
<!-- https://www.smashingmagazine.com/2018/04/feature-testing-selenium-webdriver/ -->

<!-- https://medium.com/javascript-scene/unit-testing-react-components-aeda9a44aae2 -->
<!-- https://medium.com/@rossbulat/test-driven-development-in-react-with-jest-and-enzyme-2a6cf2cc3071 -->
<!-- https://medium.com/welldone-software/an-overview-of-javascript-testing-in-2019-264e19514d0a -->

<header class="header" role="banner">
    <nav class="header__inner">
        <ul class="header__item header__item--links">
            <li class="header__link">
                <span class="header__link--background">
                    <a href="index.html">Home</a>
                </span>
            </li>
            <li class="header__link">
                <span class="header__link--background">
                    <a href="#main">Skip to content</a>
                </span>
            </li>
        </ul>
    </nav>
</header>

<main role="main" id="main">
    <h1>Testing &amp; TDD (Test Driven Development)</h1>

    <p>In short, if you want to "just get started", you can't go wrong with Jest. Jest is a testing framework created and maintained by Facebook. It is based on Jasmine and comes with assertions, spies, and mocks. Additional libraries can be added should you need unique features from them.</p>

    <p>Like Jasmine, Jest creates test globals by default so there is no need to require them. This can be considered as bad practice since it makes your tests less flexible and controllable, but it makes your life easier.</p>

    <pre>
        <code>
<!-- leave this line empty -->
// "describe" is in the global scope already
// so no these require lines are **not required**:
// import { describe } from 'jest'
// import { describe } from 'jasmine'

describe('calculator', function() {
    ...
})
        </code>
    </pre>

    <p>Jest provides you with an easy way to mock modules, for example a service can be mocked to resolve a promise instead of making a network request.</p>

    <p>Snapshot testing (jest-snapshot) is developed and maintained by Facebook and can be used with almost any other testing framework.</p>

    <p>Jest includes code coverage built-in that is based on Istanbul.</p>

    <p>Jest can also be used with Angular and not just React. Angular suggests using Jasmine over Jest.</p>

    <p>Mocha is the most used testing library. Unlike Jasmine (and Jest), it is used with third-party assertions, mocking, and spying tools (usually Sinon and Chai). Mocha is a little harder to set up due to the number of libraries required, but is more flexible and open to extensions.</p>

    <p>Functional tests can be run using a tool such as Selenium. It is not written specifically for testing and can control a browser for many purposes by exposing a driver that controls the browsers using add-ins and browser extensions.</p>

    <p>Selenium WebDriver can be accessed in many different ways and using a variety of programming languages. The WebDriver can be imported into your testing framework and tests can be written as part of it.</p>

    <p>Nightwatch has its own implementation of the Selenium WebDriver. It provides its own testing framework and test server, assertions, and tools.</p>

    <p>Cypress is used to inject tests into a website. Cypress.io runs itself in the browser and controls your tests. Cypress only controls Chrome initiall and is not headless.</p>

    <p>Puppeteer is a NodeJS library, developed by Google, that provides a convenient NodeJS API to control Chrome or Headless Chrome. Headless Chrome is just a regular Chrome 59+ version that is launched with the --headless flag. When Chrome is run in headless mode, it exposes an API to control it.</p>

    <h2>E2E (End-to-End) Testing</h2>

    <p>End-to-End (E2E) or UI (User Interface) testing (sometimes often called Functional tests), is a methodology used to test whether the flow of an application is performing as expected from start to finish. It is testing of your application from the user endpoint. Only the UI is exposed to the user.</p>

    <p>This type of testing is to test how scenarios function on the product itself, by controlling the browser or the website. These tests usually ignore the internal structure of the application entirely and looks at them from the outside like on a black box.</p>

    <p>The State of JavaScript 2017 survey states that the two most popular JavaScript testing frameworks are Mocha and Jasmine.</p>

    <p>Tests can be run in the browser by creating an HTML page with the test libraries and tests included as JavaScript files.</p>

    <p>Tests can be also executed in NodeJS by importing tests and dependent libraries. jsdom is commonly used with NodeJS to simulate a browser-like environment using pure JavaScript. It provides window, document, body, location, cookies and whatever you get when you run your JavaScript inside a browser, but renders nothing real.</p>

    <p>Headless mode uses a real browser and can be used to take screenshots, unlike jsdom.</p>

    <h3>Testing Structure</h3>

    <p>Usually refers to the organisation of your tests. Tests are usually organised in a BDD (Behaviour Driven Development) structure. It often looks like this:</p>

    <pre>
        <code>
<!-- leave this line empty -->
describe('calculator', function() {
    // describes a module with nested "describe" functions
    describe('add', function() {
        // specify the expected behavior
        it('should add 2 numbers', function() {
            //Use assertion functions to test the expected behavior
            ...
        })
    })
})
        </code>
    </pre>

    <h3>Assertion functions</h3>

    <p>Check if the results a test returns are as expected - Chai, Jasmine, Jest, Cypress.</p>

    <p>Assertion functions are used to make sure that tested variables contain the expected value. They often look like this:</p>

    <pre>
        <code>
<!-- leave this line empty -->
// Chai expect (popular)
expect(foo).to.be.a('string')
expect(foo).to.equal('bar')

// Jasmine expect (popular)
expect(foo).toBeString()
expect(foo).toEqual('bar')

// Chai assert
assert.typeOf(foo, 'string')
assert.equal(foo, 'bar')

// Unexpected expect
expect(foo, 'to be a', 'string')
expect(foo, 'to be', 'bar')
        </code>
    </pre>

    <h3>Mocks, Spies, and Stubs</h3>

    <p>Used to isolate certain parts of tests and catch their side effects - Sinon, Jasmine, Enzyme, Jest.</p>

    <p>Spies provide us with information about functions, for example, how many times were the functions called. Spies are used in integration tests to make sure that the side effects of a process are as expected.</p>

    <p>Mocks or Fakes are used to fake certain modules or behaviors to test different parts of a process. Sinon, for example, can fake a server to ensure offline, fast and expected responses when testing a certain flow.</p>

    <h3>Snapshots</h3>

    <p>Compare snapshots of component and data structures to make sure changes from previous runs are intended - Jest &amp; Ava</p>

    <p>Snapshot testing is when you compare a data structure to an expected one. It doesn't actually render and take a screenshot of the component, but is saves it as internal data in a separate file. When the test runs, if the snapshot differs from the last one, the developer is prompted to confirm that the change is intended.</p>

    <h3>Code Coverage</h3>

    <p>Generate reports to know how much of the code is covered by your tests - Istanbul, Jest, Blanket</p>

    <p>Jest seems to provide an option to view code coverage. Istanbul is another tool that will tell you how much of your code is covered with unit tests. It will report on statement, line, function and branch coverage in percentages so you will understand better what is left to cover.</p>

    <h3>Browser Controllers</h3>

    <p>Simulate user actions for Functional tests - Nightwatch, Nightmare, Phantom, Casper, Cypress</p>

    <p>Browsers can be controlled by drivers that are installed on top of them. They control the browser using different methods, such as this example from Selenium:</p>

    <pre>
        <code>
<!-- leave this line empty -->
Node.js <=> WebDriver <=> FF/Chrome/IE/Safari drivers <=> browser
        </code>
    </pre>

    <h3>Visual Regression</h3>

    <p>Tools used to compare your site to previous versions visually by using image comparison techniques.</p>

    <h3>Setting up Testing</h3>

    <p>Start by choosing the testing structure and syntax you like, assertion functions library and decide how you want to run the tests.</p>

    <p>Some frameworks such as Jest, Jasmine, and Cypress provide all these out of the box. Some of them provide only some of the functionality and a combination of libraries maybe needed (mocha + chai + sinon).</p>

    <h2>Group tests using describe()</h2>

    <p>You can create groups of tests, in a single file, using the describe method.</p>

    <pre>
        <code>
<!-- leave this line empty -->
describe('first set', () => {
    beforeEach(() => {
        //do something
    })
    afterAll(() => {
        //do something
    })
    test(/*...*/)
    test(/*...*/)
})

describe('second set', () => {
    beforeEach(() => {
        //do something
    })
    beforeAll(() => {
        //do something
    })
    test(/*...*/)
    test(/*...*/)
})
        </code>
    </pre>

    <p>To perform something before each test runs, use beforeEach().</p>

    <p>Just as you could do with the setup, you can perform something after each test runs using afterEach().</p>

    <h2>Regression Testing</h2>

    <p>Regression testing is the process of testing changes to computer programs to make sure that the older programs still works with any new changes. This is a normal part of the program development process and is often done by code testing specialists (testers). It is the act of retesting a product around an area where a bug was fixed or a change was made. The code directly affected by that change will be regression tested as part of UAT (User Acceptance Testing).</p>

    <p>UAT is often considered as the final testing process prior to deployment and is performed by a tested who ultimately signs it off.</p>

    <p>Quality Assurance (QA) testing is defined as an activity to ensure an organisation is providing the best possible product or service to customers. QA focuses on improving the processes to deliver quality products to users. This is the systematic process of determining whether a product or service meets specified requirements.</p>

    <h2>Karma</h2>

    <p>Karma hosts a test server with a special web page to run your tests in the page's environment. This page can be run across many browsers and browser-like environments.</p>

    <h2>Sinon</h2>

    <p>Sinon works with any unit testing framework and can be used to test spies, stubs and mocks for JavaScript.</p>

    <h2>Cucumber</h2>

    <p>Cucumber helps with writing tests in BDD by dividing them between acceptance criteria files using the Gherkin syntax and the tests that correspond to them. Tests can be written in a variety of languages that are supported by the framework, including JavaScript.</p>

    <pre>
        <code>
<!-- leave this line empty -->
// like-article.feature

Feature: A reader can share an article to social networks
    As a reader
    I want to share articles
    So that I can notify my friends about an article I liked
Scenario: An article was opened
    Given I'm inside an article
    When I share the article
    Then the article should change to a "shared" state
        </code>
    </pre>

    <p>And here is the test:</p>

    <pre>
        <code>
<!-- leave this line empty -->
// like-article.steps.js

module.exports = function() {
    this.Given(/^I'm inside an article$/, function(callback) {
        // functional testing tool code
    })
  
    this.When(/^I share the article$/, function(callback) {
        // functional testing tool code
    })
    
    this.Then(/^the article should change to a "shared" state$/, function(callback) {     
        // functional testing tool code
    }) 
}
        </code>
    </pre>

    <h2>Shallow Rendering</h2>

    <p>Enzyme provides the ability the "shallow" render a component, only rendering the content of the tested component and not of any child components. This is useful when testing the component in isolation and to prevent the behaviour of its child components from affecting the test. This is the recommended way to test React components (exceptions, of course, apply).</p>

    <h2>Unit Testing</h2>

    <p>Unit tests are the testing of individual units, like functions or classes, by supplying input and making sure the output is as expected.</p>

    <pre>
        <code>
<!-- leave this line empty -->
expect(fn(5)).to.be(10)
        </code>
    </pre>

    <p>Unit testing is a great discipline which can lead to 40-80% reduction in production bug density and can help to improve you application architecture and maintainability. Unit testing also provides quick feedback to tell you whether or not your changes worked. This can replace the use of console.log() and clicking around in the UI (User Interface) to test changes.</p>

    <p>Some things are easier to test that others. Unit tests work well for pure functions, those which given the same input, always return the same output. It takes discipline and practice to train yourself to use TDD (Test Driven Development), if you don't write your tests first you may rob yourself of the best features of unit testing.</p>

    <p>TDD promotes developing with intent rather than procedure. React components already do a great job at compartmentalising logic, making them well suited to TDD. This is essentially treating testing as part of the development process, rather than a job to do at the end of a sprint.</p>

    <p>Consider an example project, a navigation app with a &lt;SideBar /&gt; and &lt;TopBar /&gt; component, both of which use an &lt;Item /&gt; component for navigation links. By separating each component we are isolating the logic as well as the tests associated with each component.</p>

    <p>My API can also be completely separate from other components within my main app project. The app.test.js file is specifically for API calls, which will no doubt include various mock functions to serve fake API calls.</p>

    <p>In React, it is better to favour pure components for UI code. Provide some props, but always render the same component. If you need state from the app, you can wrap those pure components with a container component which manages state and side-effects.</p>

    <p>Here is a pure component in React:</p>

    <pre>
        <code>
<!-- leave this line empty -->
import React from 'react';

const Hello = ({ userName }) => (
    &lt;div className="greeting"&gt;Hello, {userName}&lt;/div&gt;
);

export default Hello;
        </code>
    </pre>

    <p>These kinds of components are generally very easy to test. You'll need a way to select the component adn you'll need to know the expected outcome.</p>

    <h2>Integration Tests</h2>

    <p>Testing processes across several units to achieve their goals.</p>

    <pre>
        <code>
<!-- leave this line empty -->
const flyDroneButton = document.getElementById('fly-drone-button')

flyDroneButton.click()

assert(isDroneFlyingCommandSent())

//or even
drone.checkIfFlyingViaBluetooth()
    .then(isFlying => assert(isFlying))
        </code>
    </pre>

    <h2>Shapshot testing</h2>
    <!-- https://jestjs.io/docs/en/snapshot-testing -->

    <p>Jest has a snapshot testing functionality which is useful to make sure the UI does not change unexpectedly. In the first run of a snapshot test, the snapshot is stored with the test. In subsequent runs, Jest is able to compare the newly rendered component to the stored snapshot to alert you to any differences.</p>

    <p>Snapshot testing is a useful feature to make sure that your markup does not unexpectedly change and to make sure that render() outputs what you intended it to. A snapshot file is automatically generated when the following method is called within your test:</p>

    <pre>
        <code>
<!-- leave this line empty -->
toMatchSnapshot()
        </code>
    </pre>

    <p>This is often in conjunction with expect().</p>

    <pre>
        <code>
<!-- leave this line empty -->
expect(&lt;Component /&gt;).toMatchSnapshot();
        </code>
    </pre>

    <p>Snapshots are designed to be added to source control, so commit your snapshot files with your code updates.</p>

    <p>Remember, the first time you run the test, a snapshot file will be generated within a __snapshots__ directory under your test directories. All files of which will be named &lt;test_name&gt;.snap.js</p>

    <p>The package used to convert JavaScript objects into string representations within these .snap files is pretty-format.</p>

    <p>Visual regression and Snapshot testing are two distinct ways of testing your UI (User Interface) and serve different purposes. Visual regression testing tools take screenshots of web pages and compare the resulting images pixel by pixel. Snapshot testing is used to compare changes to the code using a diff algorithm.</p>

    <p>This type of testing is not intended to replace unit tests but to provide additional value and ease testing and is only one of more than 20 assertions that ship with Jest.</p>

    <p>Consider this example test for a link component:</p>

    <pre>
        <code>
<!-- leave this line empty -->
import React from 'react';
import Link from '../Link.react';
import renderer from 'react-test-renderer';

it('renders correctly', () => {
    const tree = renderer
        .create(&lt;Link page="http://www.facebook.com"&gt;Facebook&lt;/Link&gt;)
        .toJSON();
    expect(tree).toMatchSnapshot();
});
        </code>
    </pre>

    <p>The first time this test is run, Jest creates a snapshot file that looks like this:</p>

    <pre>
        <code>
<!-- leave this line empty -->
exports[`renders correctly 1`] = `
&lt;a
    className="normal"
    href="http://www.facebook.com"
    onMouseEnter={[Function]}
    onMouseLeave={[Function]}
&gt;
    Facebook
&lt;/a&gt;
`;
        </code>
    </pre>

    <p>The snapshot artifact should be committed alongside code changes and reviewed as part of your code review process. The rule is to treat snapshots as code. The goal is to make it easy to review snapshots in pull requests and to fight against simply regenerating snapshots when the test suite fails instead of examining the root cause of their failure.</p>

    <p>When a snapshot test failes after a bug has been introduced, go ahead and fix the issue and make sure your snapshot tests are passing once again. For example, let's change the adderess the Link component in our example is pointing to and cause the snapshot test to fail:</p>

    <pre>
        <code>
<!-- leave this line empty -->
import React from 'react';
import Link from '../Link.react';
import renderer from 'react-test-renderer';

it('renders correctly', () => {
    const tree = renderer
        .create(&lt;Link page="http://www.instagram.com"&gt;Instagram&lt;/Link&gt;)
        .toJSON();
    expect(tree).toMatchSnapshot();
});
        </code>
    </pre>

    <p>Because the snapshot no longer matches the test because the address has changed, the snapshot test will fail. To resolve this, we will need to update our snapshot artifact for this test case.</p>

    <p>When using a tool like Jest, we can create snapshots to test that the rendered component matches a snapshot on a subsequent run. This is useful for knowing if your component has changed behaviour.</p>

    <p>This is a quick and simple way to capture unexpected render output, but reviewers need to be careful to check differences between the old and new snapshots. Typically, we have one snapshot test for every component to ensure that it renders as expected. Snapshots should be considered similar to other assertion in Jest.</p>

    <pre>
        <code>
<!-- leave this line empty -->
import { shallow } from 'enzyme';
import Button from './Button';

describe('Button', () => {
    it('renders correctly', () => {
        const wrapper = shallow(&lt;Button /&gt;);
        expect(wrapper).toMatchSnapshot();
        // On the first run of this test, Jest will generate a snapshot file automatically
    });
});
        </code>
    </pre>

    <p>We use the enzyme-to-json package as the snapshot serializer in our Jest config. This automatically converts the shallow render into a much more human-readable format for snapshot file(s) and removes extra from the Enzyme shallow wrapper that we don't care about.</p>

    <pre>
        <code>
<!-- leave this line empty -->
$ npm install enzyme-to-json --save-dev
        </code>
    </pre>

    <p>Example origin snapshot:</p>

    <pre>
        <code>
<!-- leave this line empty -->
exports[`BaseButton renders correctly 1`] = `
ShallowWrapper {
    "complexSelector": ComplexSelector {
        "buildPredicate": [Function],
        "childrenOfNode": [Function],
        "findWhereUnwrapped": [Function],
    },
    "length": 1,
    "node": &lt;div&gt;
    // ...
    &lt;/div&gt;,
    "nodes": Array [
        // ...
    ],
    // and so on
}
`
        </code>
    </pre>

    <p>Example serialized snapshot using enzyme-to-json:</p>

    <pre>
        <code>
<!-- leave this line empty -->
exports[`BaseButton renders correctly 1`] = `
&lt;div&gt;
    &lt;button&gt;
        Click me
    &lt;/button&gt;
&lt;/div&gt;
`
        </code>
    </pre>

    <p>You can run Jest with a flag that will tell it to re-generate snapshots. This is useful after you have updated your UI (User Interface) and wish to update your snapshots after:</p>

    <pre>
        <code>
<!-- leave this line empty -->
$ jest --updateSnapshot
        </code>
    </pre>

    <p>As of Jest 20, snapshots in Jest are not automatically written when Jest is run in a CI system without explicitly passing --updateSnapshot.</p>

    <h2>Simulating Events</h2>
    <!-- https://medium.com/@rossbulat/test-driven-development-in-react-with-jest-and-enzyme-2a6cf2cc3071 -->

    <p>Simulating events such as clicks and inputting text can be done within our tests using Enzyme's simulate() method. For example, let's say I wanted to test the result of clicking a button inside a component.</p>

    <pre>
        <code>
<!-- leave this line empty -->
it('Should update form submitted state with button click', () => {
    const component = mount(&lt;RegistrationForm /&gt;);
    component
        .find('button#submit_form')
        .simulate('click');
  
    expect(component.state('form_submitted')).toEqual(true);
    component.unmount();
});
        </code>
    </pre>

    <p>If we wanted to add input into form fields:</p>

    <pre>
        <code>
<!-- leave this line empty -->
component
    .find('#name')
    .simulate('change', { target: { value: 'Dan' } });
        </code>
    </pre>

    <p>Similarly, we can also toggle checkboxes:</p>

    <pre>
        <code>
<!-- leave this line empty -->
component
    .find('#agreetoterms')
    .simulate('change', {target: {checked: true}});
        </code>
    </pre>

    <h2>Jest Mocks</h2>
    <!-- https://medium.com/@rickhanlonii/understanding-jest-mocks-f0046c68e53c -->

    <p>The goal for mocking is to replace something we don't control with something we do.</p>

    <p>As the name suggests, Mock functions allow us to re-implement a function, stripping away logic for the purpose of capturing calls to the function, testing parameters and testing return values.</p>

    <p>The simplest way to use mock functions is to simply define an empty function and put it in place of an actual function within your tests. The benefit of doing this is tracking whether the function was actually called. We can define such a function by using:</p>

    <pre>
        <code>
<!-- leave this line empty -->
jest.fn()
        </code>
    </pre>

    <p>In this example we would replace an onClick handler with an empty mock function and test whether it has been called:</p>

    <pre>
        <code>
<!-- leave this line empty -->
//define empty mock function 
const fnClick = jest.fn();

describe('click events', () => {
    it('button click should show menu', () => {

        //replace actual function with mock function
        const component = shallow(&lt;MyButton onClick={fnClick} /&gt;);
    
        //simulate a click
        component
            .find('button#btn_open_menu')
            .simulate('click');
    
        //check if function was called
        expect(fnClick).toHaveBeenCalled();
    });
});
        </code>
    </pre>

    <p>Here are a few more tests:</p>

    <pre>
        <code>
<!-- leave this line empty -->
// Test how many times the function is called
expect(fnClick.mock.calls.length).toBe(3);

// Test the values passed as arguments
// The second argument of the third call to the function was 'yes'
expect(mockCallback.mock.calls[2][1]).toBe('yes');

// Test return values
// The return value of the second call to the function was true
expect(mockCallback.mock.results[1].value).toBe(true);
        </code>
    </pre>

    <p>Mocking is a technique to isolate test subjects by replacing dependencies with objects that you can control and inspect. A dependency can be anything your subject depends on, but is typically a module that the subject imports. For JavaScript, there are great mocking libraries available such as sinon. Jest provides mocking out of the box.</p>

    <p>For JavaScript, there are great mocking libraries available like Sinon, Jest also provides mocking out of the box.</p>

    <p>The simplest way to create a Mock Function instance is with jest.fn().</p>

    <p>Modules can also be mocked using jest.mock(). Think of database calls or API requests that are slow and fragile - things that could break easily. Jest provides a simple example of mocking the axios module to overwrite API calls.</p>

    <pre>
        <code>
<!-- leave this line empty -->
// import the module to mock
import axios from 'axios';

// wrap the module in jest.mock()
jest.mock('axios');

test('should fetch users', () => {
    const users = [{first_name: 'Ross'}];
    const resp = {data: users};

    // append .mockResolvedValue(&lt;return value&gt;) to the module method
    axios.get.mockResolvedValue(resp);

    // carry out your test
    return expect(resp.data).toEqual(users));
});
        </code>
    </pre>

    <h2>Debug Components</h2>

    <p>It is worth mentioning that if you wish to log a component's render() output in HTML, use the debug() method of a wrapper:</p>

    <pre>
        <code>
<!-- leave this line empty -->
const component = shallow(&lt;MyComponent /&gt;);
console.log(component.debug());
        </code>
    </pre>

    <h2>TDD (Test Driven Development)</h2>

    <p>Test-driven development (TDD) is an approach to programming that encourages developers to write tests of their code before actually writing the code itself.</p>

    <ul>
        <li>Write only enough of a unit test to fail.</li>
        <li>Write only enough production code to make the failing unit test pass.</li>
    </ul>

    <p>The process of TDD can often be summarised like this:</p>

    <ul>
        <li>Write a test</li>
        <li>Run the test, this should fail</li>
        <li>Change the code to make it correct and the test should pass - refactor</li>
        <li>Repeat the process</li>
    </ul>

    <h2>Unit Testing</h2>

    <p>Unit testing is the practice of testing certain functions and areas, or units, of our code. This gives us the ability to verify that our functions work as expected. As you begin to write more and more tests, you end up creating a suite of tests that you can run at any time during development.</p>

    <h2>Jest</h2>
    <!-- https://jestjs.io/en/ -->
    <!-- https://medium.com/codeclan/testing-react-with-jest-and-enzyme-20505fec4675 -->

    <p>Jest is a JavaScript testing framework that works with projects including: React, Angular, Vue, Node, Babel, and TypeScript. It has little or no config to worry about and can generate code coverage information from the entire project, if needed.</p>

    <p>Jest acts as a test runner, assertion library, and mocking library.</p>

    <p>Jest is the de facto unit testing framework for React. It is provided and used by Facebook themselves. The main advantage for using Jest is that it has zero configuration. It can be installed quickly (included with CRA - create-react-app) and is simple to use. Place you tests, files with '.js' extension, in a __tests__ folder, or name your test files with a '.spec.js' or '.test.js' extension. Whatever you prefer, Jest will find and run your tests.</p>

    <p>Jest will look for tests in any of the following places:</p>

    <ul>
        <li>Files with .js suffix in __tests__ folders.</li>
        <li>Files with .test.js suffix.</li>
        <li>Files with .spec.js suffix.</li>
    </ul>

    <p>It is conventional to put each test file next to the code or component it is testing.</p>

    <p>Jest acts as a test runner, assertion library, and mocking library. Jest also provides Snapshot testing. This is the ability to create a rendered 'snapshot' of a component to compare it to a previously saved 'snapshot'. The test will fail if the two do not match. Snapshots will be saved for you beside the test file that created them in an auto-generated __snapshots__ folder.</p>

    <h3>Install Jest</h3>

    <p>Install Jest as a devDependency using NPM (Node Package Manager). We have some notes within </p>

    <pre>
        <code>
<!-- leave this line empty -->
$ npm install jest --save-dev
        </code>
    </pre>

    <p>Jest 24 dropped support for Babel 6, so its recommended to upgrade to Babel 7 which is actively maintained.</p>

    <p>You can generate code coverage by adding the --coverage flag. Jest can then collect code coverage information from entire projects including untested files.</p>

    <pre>
        <code>
<!-- leave this line empty -->
$ npm run test --coverage
        </code>
    </pre>

    <p>Jest also supports <a href="typescript.html">TypeScript</a>, via <a href="webpack.html">Babel</a>. You will need to install Babel and install the @babel/preset-typescript package via NPM (Node Package Manager) or Yarn.</p>

    <pre>
        <code>
<!-- leave this line empty -->
$ npm install @babel/preset-typescript --save-dev
        </code>
    </pre>

    <p>This will need to be added to the list of presets within your babelrc config file.</p>

    <p>Create a simple file named sum.test.js that will contain a simple test, as an example:</p>

    <pre>
        <code>
<!-- leave this line empty -->
const sum = require('./sum');

test('adds 1 + 2 to equal 3', () => {
    expect(sum(1, 2)).toBe(3);
});
        </code>
    </pre>

    <p>This test used expect and toBe to test that two values were exactly identical. These are known as Matchers.</p>

    <p>Here is a further test example that uses Enzyme and Chai:</p>

    <pre>
        <code>
<!-- leave this line empty -->
import React from 'react'
import { shallow } from 'enzyme'
import { expect } from 'chai'

import Component from './HelpAndSupportCard'

describe('&lt;HelpAndSupportCard /&gt;', () => {
    //const tree = shallow(&lt;Component {...props} /&gt;)
    const tree = shallow(&lt;Component /&gt;)

    it('renders correctly', () => {
        expect(tree.debug()).to.matchSnapshot()
    })
})
        </code>
    </pre>

    <p>You will need to update package.json to run Jest:</p>

    <pre>
        <code>
<!-- leave this line empty -->
{
    "scripts": {
        "test": "jest"
    }
}
        </code>
    </pre>

    <p>Finally, run Jest and the test will output in your terminal:</p>

    <pre>
        <code>
<!-- leave this line empty -->
$ npm run test
        </code>
    </pre>

    <h2>Enzyme</h2>

    <p>Enzyme is a testing utility created by Airbnb that can be used together with Jest. Enzyme makes it easier to assert, manipulate, and traverse your React components' output. This adds some additional utility methods for rendering a component, find elements, and interacting with elements.</p>

    <p>Jest can be used with other JavaScript applications, but Enzyme only works with React. If Jest is not used, Enzyme must be paired with another test runner.</p>

    <p>Jest can be used without Enzyme to render components and test with snapshots, Enzyme simply adds additional functionality.</p>

    <p>Enzyme is not included with the CRA (create-react-app) tool, so it must be installed in addition.</p>

    <h3>Install Enzyme</h3>

    <p>If you are wanting to use Enzyme with React 16, simply install it as a devDependency with NPM (Node Package Manager). This will install both Enzyme and Enzyme Adapter.</p> 

    <pre>
        <code>
<!-- leave this line empty -->
$ npm install enzyme enzyme-adapter-react-16 --save-dev
        </code>
    </pre>

    <p>When you try to run tests following installation, an error may occur within the terminal. You may need to configure Enzyme so it can be used with React 16 and Jest.</p>

    <p>In the 'src/js' directory of your application, create a file named 'setupTests.js' and add the following code:</p>

    <pre>
        <code>
<!-- leave this line empty -->
// src/js/setupTests.js

import { configure } from 'enzyme'
import Adapter from 'enzyme-adapter-react-16'

configure({
    adapter: new Adapter()
})
        </code>
    </pre>

    <p>Next, update the package.json file to include a reference to the path of this config file when running Jest.</p>

    <pre>
        <code>
<!-- leave this line empty -->
"jest": {
    "setupTestFrameworkScriptFile": "&lt;rootDir&gt;/src/js/setupTests.js"
},
        </code>
    </pre>

    <p>This has since been deprecated and replaced (now in an array) with this:</p>

    <pre>
        <code>
<!-- leave this line empty -->
"jest": {
    "setupFilesAfterEnv": ["&lt;rootDir&gt;/src/js/setupTests.js"]
},
        </code>
    </pre>

    <p>We should already have a build script within our package.json file to run tests.</p>

    <pre>
        <code>
<!-- leave this line empty -->
"scripts": {
    "test": "jest"
},
        </code>
    </pre>

    <p>Once everything has been done, the tests can be executed by running the build script in the terminal.</p>

    <pre>
        <code>
<!-- leave this line empty -->
$ npm run test
        </code>
    </pre>

    <h2>Mocha</h2>

    <p>Mocha is a JavaScript test framework that runs using NodeJS and from within the browser. Jest and Jasmine are alternatives to Mocha. Unlike Jest, Mocha does not have an assertion library, a tool used to verify that things are correct. Assertion libraries such as Expect or Chai can be used with Mocha.</p>

    <h3>Install Mocha</h3>

    <p>Mocha can be installed using NPM (Node Package Manager). It should be installed as a devDependency.</p>

    <pre>
        <code>
<!-- leave this line empty -->
$ npm install mocha --save-dev
        </code>
    </pre>

    <p>By default, Mocha looks for a 'test' directory containing test files. You may need to create a directory in the root of your application for Mocha to work correctly.</p>

    <pre>
        <code>
<!-- leave this line empty -->
$ mkdir test
        </code>
    </pre>

    <p>The 'test' directory would where we can place all our test files. However, we may want to place our test files near to our components.</p>

    <p>We can continue to have a 'test' directory within the root of our project, but will contain two config file - setup.js and mocha.opts</p>

    <pre>
        <code>
<!-- leave this line empty -->
app /
    test /
        mocha.opts
        setup.js
        </code>
    </pre>

    <p>The mocha.opts file will look like this:</p>

    <pre>
        <code>
<!-- leave this line empty -->
test/setup.js
src/**/*.spec.js
        </code>
    </pre>

    <p>The setup.js file will look like this:</p>

    <pre>
        <code>
<!-- leave this line empty -->
const chai = require('chai');
        </code>
    </pre>

    <h3>Chai</h3>

    <p>This is assuming that Chai is to be used as the assertion library and has been installed.</p>

    <pre>
        <code>
<!-- leave this line empty -->
$ npm install chai --save-dev
        </code>
    </pre>

    <p>Node has its own built-in assertion module, named Assert, should you not want to use Chai.</p>

    <p>Any test file created for the React components should have the file extension of '.spec.js'. Using this configuration allows us to place the test file(s) in the same directory as our components.</p>

    <p>An example showing a possible file structure:</p>

    <pre>
        <code>
<!-- leave this line empty -->
app /
    src/
        components/
            1-atoms/
                input/
                    Input.js
                    Input.spec.js
    test /
        mocha.opts
        setup.js
        </code>
    </pre>

    <p>As with Jest, we can run Mocha using a simple build script in package.json.</p>

    <pre>
        <code>
<!-- leave this line empty -->
"scripts": {
    "test": "mocha"
},
        </code>
    </pre>

    <h3>Mocha &amp; ES6</h3>

    <p>Should you want to use JavaScript ES6 syntax within your test files, when using Mocha, you will need to make a few amendments. Babel will need to be setup within your build process and the mocha.opts file will need to be updated to allow for ES6.</p>

    <pre>
        <code>
<!-- leave this line empty -->
--require babel-register

test/setup.js
src/**/*.spec.js
        </code>
    </pre>

    <p>Next, update the package.json file:</p>

    <pre>
        <code>
<!-- leave this line empty -->
"babel": {
    "presets": ["env"]
}
        </code>
    </pre>

    <p>And here is an example test file:</p>

    <pre>
        <code>
<!-- leave this line empty -->
import React from 'react'
import { assert } from 'chai'

describe('Input', function() {
   it('test test', function() {
      // assert function from Chai
      assert.equal(true);
   });
})
        </code>
    </pre>

    <h2>Writing Tests</h2>

    <p>Using Jest it is possible to create a test file for a React component in any directory provided that are named as '.spec.js' or '.test.js'. Jest doesn't require a 'test' directory.</p>

    <p>Once a React component has been built, we can write a simple test. As an example, we can create a simple Button component named 'Button.js' and then write a test file named 'Button.test.js'.</p>

    <p>The test code for the Button component may look something like this:</p>

    <pre>
        <code>
<!-- leave this line empty -->
import React from 'react'
import { shallow } from 'enzyme'
import Button from './Button'

describe('&lt;Button/&gt;', () => {
    it('should render without throwing an error', () => {
        expect(shallow(&lt;Button/&gt;).find('.btn').exists()).toBe(true)
    })
})
        </code>
    </pre>

    <p>Ideally, this should be placed in the same directory as the Button component itself.</p>

    <p>You may want to update the test if you only want to run the sole test within a collection of tests:</p>

    <pre>
        <code>
<!-- leave this line empty -->
import React from 'react'
import { shallow } from 'enzyme'
import Button from './Button'

describe.only('&lt;Button/&gt;', () => {
    it('should render without throwing an error', () => {
        expect(shallow(&lt;Button/&gt;).find('.btn').exists()).toBe(true)
    })
})
        </code>
    </pre>

    <h2>Selenium</h2>

    <p>Selenium is a framework for the automated testing of web applications. You can basically automate every task in your browser as if a user was to execute the task. The interface used to send commands to the different browsers is called Selenium WebDriver. Implementations for this interface are available fr every major browser, including Firefox and Google Chrome. Selenium basically allows you to automate web browsers.</p>

    <p>Automate repetitive online tasks with Selenium WebDriver. This can be used to automate tasks such as login forms.</p>

    <p>Selenium is commonly used in Java. All major browsers provide their own implementation of the WebDriver interface. For example, should you want to use Chrome, you needed to get the WebDriver implementation of Chrome, ChromeDriver.</p>

    <h2>How to write tests</h2>
    <!-- https://www.taniarascia.com/unit-testing-in-javascript/ -->

    <p>Test-driven development (TDD) is an approach to development that consists of writing test, followed by production code. Refactoring is then done, as needed. The tests are written to fail initially and the developer writes code to fulfill the requirements of the test, so that they then pass.</p>

    <p>Testing frameworks, such as Mocha, are often used as JavaScript testing frameworks.</p>

    <p>NodeJS (also known as Node or Node.js) also has a built-in assert module to test of true is equal to true. We can write a simple test like this:</p>

    <pre>
        <code>
<!-- leave this line empty -->
const assert = require('assert');

it('should return true', () => {
    assert.equal(true, true);
});
        </code>
    </pre>

    <p>This function is using ES6 arrow functions and implicit returns.</p>

    <p>This test can be run in the command prompt, like so:</p>

    <pre>
        <code>
<!-- leave this line empty -->
$ npm test
        </code>
    </pre>
</main>

</body>
</html>