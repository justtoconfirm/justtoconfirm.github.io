<!DOCTYPE html>
<html lang="en-GB">
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Developer Notes - Testing & TDD</title>

    <link rel="shortcut icon" type="image/ico" href="img/favicon/code.ico" />
    <link rel="stylesheet" href="styles/main.css" />
    <link rel="preload" href="fonts/nunito-v9-latin-regular.woff2" as="font" type="font/woff2" crossorigin />
</head>
<body>

<!-- https://airbnb.io/enzyme/docs/installation/react-16.html -->
<!-- https://jestjs.io/ -->
<!-- https://marmelab.com/blog/2015/06/24/jest-in-practice.html -->
<!-- https://medium.com/wehkamp-techblog/unit-testing-your-react-application-with-jest-and-enzyme-81c5545cee45 -->
<!-- https://medium.com/codeclan/testing-react-with-jest-and-enzyme-20505fec4675 -->
<!-- https://code.tutsplus.com/articles/the-beginners-guide-to-unit-testing-what-is-unit-testing--wp-25728 -->
<!-- https://www.guru99.com/unit-testing-guide.html -->
<!-- https://medium.freecodecamp.org/test-driven-development-what-it-is-and-what-it-is-not-41fa6bca02a2 -->
<!-- https://news.codecademy.com/test-driven-development/ -->
<!-- https://www.bignerdranch.com/blog/why-do-javascript-test-frameworks-use-describe-and-beforeeach/ -->

<!-- https://medium.com/opendoor-labs/testing-react-components-with-jest-a7e8e4d312d8 -->
<!-- https://medium.com/@rickhanlonii/understanding-jest-mocks-f0046c68e53c -->
<!-- https://flaviocopes.com/jest/ -->

<!-- https://jestjs.io/docs/en/configuration.html -->
<!-- https://www.npmjs.com/package/enzyme-to-json -->

<!-- https://medium.com/codeclan/mocking-es-and-commonjs-modules-with-jest-mock-37bbb552da43 -->

<!-- Selenium WebDriver e2e tests -->
<!-- https://www.smashingmagazine.com/2018/04/feature-testing-selenium-webdriver/ -->

<header class="header" role="banner">
    <nav class="header__inner">
        <ul class="header__item header__item--links">
            <li class="header__link">
                <span class="header__link--background">
                    <a href="index.html">Home</a>
                </span>
            </li>
            <li class="header__link">
                <span class="header__link--background">
                    <a href="#main">Skip to content</a>
                </span>
            </li>
        </ul>
    </nav>
</header>

<main role="main" id="main">
    <h1>Testing &amp; TDD (Test Driven Development)</h1>

    <p>The State of JavaScript 2017 survey states that the two most popular JavaScript testing frameworks are Mocha and Jasmine.</p>

    <h2>Group tests using describe()</h2>

    <p>You can create groups of tests, in a single file, using the describe method.</p>

    <pre>
        <code>
<!-- leave this line empty -->
describe('first set', () => {
    beforeEach(() => {
        //do something
    })
    afterAll(() => {
        //do something
    })
    test(/*...*/)
    test(/*...*/)
})

describe('second set', () => {
    beforeEach(() => {
        //do something
    })
    beforeAll(() => {
        //do something
    })
    test(/*...*/)
    test(/*...*/)
})
        </code>
    </pre>

    <p>To perform something before each test runs, use beforeEach().</p>

    <p>Just as you could do with the setup, you can perform something after each test runs using afterEach().</p>

    <h2>Shallow Rendering</h2>

    <p>Enzyme provides the ability the "shallow" render a component, only rendering the content of the tested component and not of any child components. This is useful when testing the component in isolation and to prevent the behaviour of its child components from affecting the test. This is the recommended way to test React components (exceptions, of course, apply).</p>

    <h2>Shapshot testing</h2>
    <!-- https://jestjs.io/docs/en/snapshot-testing -->

    <p>Jest has a snapshot testing functionality which is useful to make sure the UI does not change unexpectedly. In the first run of a snapshot test, the snapshot is stored with the test. In subsequent runs, Jest is able to compare the newly rendered component to the stored snapshot to alert you to any differences.</p>

    <p>Visual regression and Snapshot testing are two distinct ways of testing your UI (User Interface) and serve different purposes. Visual regression testing tools take screenshots of web pages and compare the resulting images pixel by pixel. Snapshot testing is used to compare changes to the code using a diff algorithm.</p>

    <p>This type of testing is not intended to replace unit tests but to provide additional value and ease testing and is only one of more than 20 assertions that ship with Jest.</p>

    <p>Consider this example test for a link component:</p>

    <pre>
        <code>
<!-- leave this line empty -->
import React from 'react';
import Link from '../Link.react';
import renderer from 'react-test-renderer';

it('renders correctly', () => {
    const tree = renderer
        .create(&lt;Link page="http://www.facebook.com"&gt;Facebook&lt;/Link&gt;)
        .toJSON();
    expect(tree).toMatchSnapshot();
});
        </code>
    </pre>

    <p>The first time this test is run, Jest creates a snapshot file that looks like this:</p>

    <pre>
        <code>
<!-- leave this line empty -->
exports[`renders correctly 1`] = `
&lt;a
    className="normal"
    href="http://www.facebook.com"
    onMouseEnter={[Function]}
    onMouseLeave={[Function]}
&gt;
    Facebook
&lt;/a&gt;
`;
        </code>
    </pre>

    <p>The snapshot artifact should be committed alongside code changes and reviewed as part of your code review process. The rule is to treat snapshots as code. The goal is to make it easy to review snapshots in pull requests and to fight against simply regenerating snapshots when the test suite fails instead of examining the root cause of their failure.</p>

    <p>When a snapshot test failes after a bug has been introduced, go ahead and fix the issue and make sure your snapshot tests are passing once again. For example, let's change the adderess the Link component in our example is pointing to and cause the snapshot test to fail:</p>

    <pre>
        <code>
<!-- leave this line empty -->
import React from 'react';
import Link from '../Link.react';
import renderer from 'react-test-renderer';

it('renders correctly', () => {
    const tree = renderer
        .create(&lt;Link page="http://www.instagram.com"&gt;Instagram&lt;/Link&gt;)
        .toJSON();
    expect(tree).toMatchSnapshot();
});
        </code>
    </pre>

    <p>Because the snapshot no longer matches the test because the address has changed, the snapshot test will fail. To resolve this, we will need to update our snapshot artifact for this test case.</p>

    <p>When using a tool like Jest, we can create snapshots to test that the rendered component matches a snapshot on a subsequent run. This is useful for knowing if your component has changed behaviour.</p>

    <p>This is a quick and simple way to capture unexpected render output, but reviewers need to be careful to check differences between the old and new snapshots. Typically, we have one snapshot test for every component to ensure that it renders as expected. Snapshots should be considered similar to other assertion in Jest.</p>

    <pre>
        <code>
<!-- leave this line empty -->
import { shallow } from 'enzyme';
import Button from './Button';

describe('Button', () => {
    it('renders correctly', () => {
        const wrapper = shallow(&lt;Button /&gt;);
        expect(wrapper).toMatchSnapshot();
        // On the first run of this test, Jest will generate a snapshot file automatically
    });
});
        </code>
    </pre>

    <p>We use the enzyme-to-json package as the snapshot serializer in our Jest config. This automatically converts the shallow render into a much more human-readable format for snapshot file(s) and removes extra from the Enzyme shallow wrapper that we don't care about.</p>

    <pre>
        <code>
<!-- leave this line empty -->
$ npm install enzyme-to-json --save-dev
        </code>
    </pre>

    <p>Example origin snapshot:</p>

    <pre>
        <code>
<!-- leave this line empty -->
exports[`BaseButton renders correctly 1`] = `
ShallowWrapper {
    "complexSelector": ComplexSelector {
        "buildPredicate": [Function],
        "childrenOfNode": [Function],
        "findWhereUnwrapped": [Function],
    },
    "length": 1,
    "node": &lt;div&gt;
    // ...
    &lt;/div&gt;,
    "nodes": Array [
        // ...
    ],
    // and so on
}
`
        </code>
    </pre>

    <p>Example serialized snapshot using enzyme-to-json:</p>

    <pre>
        <code>
<!-- leave this line empty -->
exports[`BaseButton renders correctly 1`] = `
&lt;div&gt;
    &lt;button&gt;
        Click me
    &lt;/button&gt;
&lt;/div&gt;
`
        </code>
    </pre>

    <p>You can run Jest with a flag that will tell it to re-generate snapshots:</p>

        <code>
<!-- leave this line empty -->
$ jest --updateSnapshot
        </code>
    </pre>

    <p>As of Jest 20, snapshots in Jest are not automatically written when Jest is run in a CI system without explicitly passing --updateSnapshot.</p>

    <h2>Jest Mocks</h2>
    <!-- https://medium.com/@rickhanlonii/understanding-jest-mocks-f0046c68e53c -->

    <p>The goal for mocking is to replace something we don't control with something we do.</p>

    <p>Mocking is a technique to isolate test subjects by replacing dependencies with objects that you can control and inspect. A dependency can be anything your subject depends on, but is typically a module that the subject imports. For JavaScript, there are great mocking libraries available such as sinon. Jest provides mocking out of the box.</p>

    <p>For JavaScript, there are great mocking libraries available like Sinon, Jest also provides mocking out of the box.</p>

    <p>The simplest way to create a Mock Function instance is with jest.fn().</p>

    <h2>TDD (Test Driven Development)</h2>

    <p>Test-driven development (TDD) is an approach to programming that encourages developers to write tests of their code before actually writing the code itself.</p>

    <ul>
        <li>Write only enough of a unit test to fail.</li>
        <li>Write only enough production code to make the failing unit test pass.</li>
    </ul>

    <p>The process of TDD can often be summarised like this:</p>

    <ul>
        <li>Write a test</li>
        <li>Run the test, this should fail</li>
        <li>Change the code to make it correct and the test should pass - refactor</li>
        <li>Repeat the process</li>
    </ul>

    <h2>Unit Testing</h2>

    <p>Unit testing is the practice of testing certain functions and areas, or units, of our code. This gives us the ability to verify that our functions work as expected. As you begin to write more and more tests, you end up creating a suite of tests that you can run at any time during development.</p>

    <h2>Jest</h2>
    <!-- https://jestjs.io/en/ -->
    <!-- https://medium.com/codeclan/testing-react-with-jest-and-enzyme-20505fec4675 -->

    <p>Jest is a JavaScript testing framework that works with projects including: React, Angular, Vue, Node, Babel, and TypeScript. It has little or no config to worry about and can generate code coverage information from the entire project, if needed.</p>

    <p>Jest acts as a test runner, assertion library, and mocking library.</p>

    <p>Jest is the de facto unit testing framework for React. It is provided and used by Facebook themselves. The main advantage for using Jest is that it has zero configuration. It can be installed quickly (included with CRA - create-react-app) and is simple to use. Place you tests, files with '.js' extension, in a __tests__ folder, or name your test files with a '.spec.js' or '.test.js' extension. Whatever you prefer, Jest will find and run your tests.</p>

    <p>Jest will look for tests in any of the following places:</p>

    <ul>
        <li>Files with .js suffix in __tests__ folders.</li>
        <li>Files with .test.js suffix.</li>
        <li>Files with .spec.js suffix.</li>
    </ul>

    <p>It is conventional to put each test file next to the code or component it is testing.</p>

    <p>Jest acts as a test runner, assertion library, and mocking library. Jest also provides Snapshot testing. This is the ability to create a rendered 'snapshot' of a component to compare it to a previously saved 'snapshot'. The test will fail if the two do not match. Snapshots will be saved for you beside the test file that created them in an auto-generated __snapshots__ folder.</p>

    <h3>Install Jest</h3>

    <p>Install Jest as a devDependency using NPM (Node Package Manager). We have some notes within </p>

    <pre>
        <code>
<!-- leave this line empty -->
$ npm install jest --save-dev
        </code>
    </pre>

    <p>Jest 24 dropped support for Babel 6, so its recommended to upgrade to Babel 7 which is actively maintained.</p>

    <p>You can generate code coverage by adding the --coverage flag. Jest can then collect code coverage information from entire projects including untested files.</p>

    <pre>
        <code>
<!-- leave this line empty -->
$ npm run test --coverage
        </code>
    </pre>

    <p>Jest also supports <a href="typescript.html">TypeScript</a>, via <a href="webpack.html">Babel</a>. You will need to install Babel and install the @babel/preset-typescript package via NPM (Node Package Manager) or Yarn.</p>

    <pre>
        <code>
<!-- leave this line empty -->
$ npm install @babel/preset-typescript --save-dev
        </code>
    </pre>

    <p>This will need to be added to the list of presets within your babelrc config file.</p>

    <p>Create a simple file named sum.test.js that will contain a simple test, as an example:</p>

    <pre>
        <code>
<!-- leave this line empty -->
const sum = require('./sum');

test('adds 1 + 2 to equal 3', () => {
    expect(sum(1, 2)).toBe(3);
});
        </code>
    </pre>

    <p>This test used expect and toBe to test that two values were exactly identical. These are known as Matchers.</p>

    <p>Here is a further test example that uses Enzyme and Chai:</p>

    <pre>
        <code>
<!-- leave this line empty -->
import React from 'react'
import { shallow } from 'enzyme'
import { expect } from 'chai'

import Component from './HelpAndSupportCard'

describe('&lt;HelpAndSupportCard /&gt;', () => {
    //const tree = shallow(&lt;Component {...props} /&gt;)
    const tree = shallow(&lt;Component /&gt;)

    it('renders correctly', () => {
        expect(tree.debug()).to.matchSnapshot()
    })
})
        </code>
    </pre>

    <p>You will need to update package.json to run Jest:</p>

    <pre>
        <code>
<!-- leave this line empty -->
{
    "scripts": {
        "test": "jest"
    }
}
        </code>
    </pre>

    <p>Finally, run Jest and the test will output in your terminal:</p>

    <pre>
        <code>
<!-- leave this line empty -->
$ npm run test
        </code>
    </pre>

    <h2>Enzyme</h2>

    <p>Enzyme is a testing utility created by Airbnb that can be used together with Jest. Enzyme makes it easier to assert, manipulate, and traverse your React components' output. This adds some additional utility methods for rendering a component, find elements, and interacting with elements.</p>

    <p>Jest can be used with other JavaScript applications, but Enzyme only works with React. If Jest is not used, Enzyme must be paired with another test runner.</p>

    <p>Jest can be used without Enzyme to render components and test with snapshots, Enzyme simply adds additional functionality.</p>

    <p>Enzyme is not included with the CRA (create-react-app) tool, so it must be installed in addition.</p>

    <h3>Install Enzyme</h3>

    <p>If you are wanting to use Enzyme with React 16, simply install it as a devDependency with NPM (Node Package Manager). This will install both Enzyme and Enzyme Adapter.</p> 

    <pre>
        <code>
<!-- leave this line empty -->
$ npm install enzyme enzyme-adapter-react-16 --save-dev
        </code>
    </pre>

    <p>When you try to run tests following installation, an error may occur within the terminal. You may need to configure Enzyme so it can be used with React 16 and Jest.</p>

    <p>In the 'src/js' directory of your application, create a file named 'setupTests.js' and add the following code:</p>

    <pre>
        <code>
<!-- leave this line empty -->
// src/js/setupTests.js

import { configure } from 'enzyme'
import Adapter from 'enzyme-adapter-react-16'

configure({
    adapter: new Adapter()
})
        </code>
    </pre>

    <p>Next, update the package.json file to include a reference to the path of this config file when running Jest.</p>

    <pre>
        <code>
<!-- leave this line empty -->
"jest": {
    "setupTestFrameworkScriptFile": "&lt;rootDir&gt;/src/js/setupTests.js"
},
        </code>
    </pre>

    <p>This has since been deprecated and replaced (now in an array) with this:</p>

    <pre>
        <code>
<!-- leave this line empty -->
"jest": {
    "setupFilesAfterEnv": ["&lt;rootDir&gt;/src/js/setupTests.js"]
},
        </code>
    </pre>

    <p>We should already have a build script within our package.json file to run tests.</p>

    <pre>
        <code>
<!-- leave this line empty -->
"scripts": {
    "test": "jest"
},
        </code>
    </pre>

    <p>Once everything has been done, the tests can be executed by running the build script in the terminal.</p>

    <pre>
        <code>
<!-- leave this line empty -->
$ npm run test
        </code>
    </pre>

    <h2>Mocha</h2>

    <p>Mocha is a JavaScript test framework that runs using NodeJS and from within the browser. Jest and Jasmine are alternatives to Mocha. Unlike Jest, Mocha does not have an assertion library, a tool used to verify that things are correct. Assertion libraries such as Expect or Chai can be used with Mocha.</p>

    <h3>Install Mocha</h3>

    <p>Mocha can be installed using NPM (Node Package Manager). It should be installed as a devDependency.</p>

    <pre>
        <code>
<!-- leave this line empty -->
$ npm install mocha --save-dev
        </code>
    </pre>

    <p>By default, Mocha looks for a 'test' directory containing test files. You may need to create a directory in the root of your application for Mocha to work correctly.</p>

    <pre>
        <code>
<!-- leave this line empty -->
$ mkdir test
        </code>
    </pre>

    <p>The 'test' directory would where we can place all our test files. However, we may want to place our test files near to our components.</p>

    <p>We can continue to have a 'test' directory within the root of our project, but will contain two config file - setup.js and mocha.opts</p>

    <pre>
        <code>
<!-- leave this line empty -->
app /
    test /
        mocha.opts
        setup.js
        </code>
    </pre>

    <p>The mocha.opts file will look like this:</p>

    <pre>
        <code>
<!-- leave this line empty -->
test/setup.js
src/**/*.spec.js
        </code>
    </pre>

    <p>The setup.js file will look like this:</p>

    <pre>
        <code>
<!-- leave this line empty -->
const chai = require('chai');
        </code>
    </pre>

    <h3>Chai</h3>

    <p>This is assuming that Chai is to be used as the assertion library and has been installed.</p>

    <pre>
        <code>
<!-- leave this line empty -->
$ npm install chai --save-dev
        </code>
    </pre>

    <p>Node has its own built-in assertion module, named Assert, should you not want to use Chai.</p>

    <p>Any test file created for the React components should have the file extension of '.spec.js'. Using this configuration allows us to place the test file(s) in the same directory as our components.</p>

    <p>An example showing a possible file structure:</p>

    <pre>
        <code>
<!-- leave this line empty -->
app /
    src/
        components/
            1-atoms/
                input/
                    Input.js
                    Input.spec.js
    test /
        mocha.opts
        setup.js
        </code>
    </pre>

    <p>As with Jest, we can run Mocha using a simple build script in package.json.</p>

    <pre>
        <code>
<!-- leave this line empty -->
"scripts": {
    "test": "mocha"
},
        </code>
    </pre>

    <h3>Mocha &amp; ES6</h3>

    <p>Should you want to use JavaScript ES6 syntax within your test files, when using Mocha, you will need to make a few amendments. Babel will need to be setup within your build process and the mocha.opts file will need to be updated to allow for ES6.</p>

    <pre>
        <code>
<!-- leave this line empty -->
--require babel-register

test/setup.js
src/**/*.spec.js
        </code>
    </pre>

    <p>Next, update the package.json file:</p>

    <pre>
        <code>
<!-- leave this line empty -->
"babel": {
    "presets": ["env"]
}
        </code>
    </pre>

    <p>And here is an example test file:</p>

    <pre>
        <code>
<!-- leave this line empty -->
import React from 'react'
import { assert } from 'chai'

describe('Input', function() {
   it('test test', function() {
      // assert function from Chai
      assert.equal(true);
   });
})
        </code>
    </pre>

    <h2>Writing Tests</h2>

    <p>Using Jest it is possible to create a test file for a React component in any directory provided that are named as '.spec.js' or '.test.js'. Jest doesn't require a 'test' directory.</p>

    <p>Once a React component has been built, we can write a simple test. As an example, we can create a simple Button component named 'Button.js' and then write a test file named 'Button.test.js'.</p>

    <p>The test code for the Button component may look something like this:</p>

    <pre>
        <code>
<!-- leave this line empty -->
import React from 'react'
import { shallow } from 'enzyme'
import Button from './Button'

describe('&lt;Button/&gt;', () => {
    it('should render without throwing an error', () => {
        expect(shallow(&lt;Button/&gt;).find('.btn').exists()).toBe(true)
    })
})
        </code>
    </pre>

    <p>Ideally, this should be placed in the same directory as the Button component itself.</p>

    <p>You may want to update the test if you only want to run the sole test within a collection of tests:</p>

    <pre>
        <code>
<!-- leave this line empty -->
import React from 'react'
import { shallow } from 'enzyme'
import Button from './Button'

describe.only('&lt;Button/&gt;', () => {
    it('should render without throwing an error', () => {
        expect(shallow(&lt;Button/&gt;).find('.btn').exists()).toBe(true)
    })
})
        </code>
    </pre>

    <h2>Selenium</h2>

    <p>Selenium is a framework for the automated testing of web applications. You can basically automate every task in your browser as if a user was to execute the task. The interface used to send commands to the different browsers is called Selenium WebDriver. Implementations for this interface are available fr every major browser, including Firefox and Google Chrome. Selenium basically allows you to automate web browsers.</p>

    <p>Automate repetitive online tasks with Selenium WebDriver. This can be used to automate tasks such as login forms.</p>

    <p>Selenium is commonly used in Java. All major browsers provide their own implementation of the WebDriver interface. For example, should you want to use Chrome, you needed to get the WebDriver implementation of Chrome, ChromeDriver.</p>
</main>

</body>
</html>