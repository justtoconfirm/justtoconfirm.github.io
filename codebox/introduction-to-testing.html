<!DOCTYPE html>
<html lang="en-GB">
<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="An introductory guide to Testing">

	<title>Codebox - Introduction to Testing</title>

	<link rel="shortcut icon" type="image/ico" href="favicon/code.ico">
	<link rel="stylesheet" href="style/foundation.min.css">
	<link rel="stylesheet" href="style/main.css">
</head>
<body>

<main role="main">
	<div class="row">
		<div class="columns small-12 large-12">

			<h1>Introduction to Testing</h1>

            <p>Testing means checking that our code meets some expectations. For example, a function should return the expected output for some given input.</p>

            <h2>Testing Frameworks, Libraries & Utilities</h2>

            <ul>
                <li><strong>Jest</strong> - JavaScript test runner.</li>
                <li><strong>Mocha</strong> - feature-rich JavaScript test framework for Node.js and the browser.</li>
                <li><strong>Selenium</strong> - browser automation.</li>
                <li><strong>Enzyme</strong> - JavaScript testing utility for React, by Airbnb, used to assertion.</li>
                <li><strong>Jasmine</strong> - BDD (Behavior Driven Development) testing framework for JavaScript.</li>
                <li><strong>Cypress</strong> - Front-end automated testing in Chrome.</li>
                <li><strong>Chai</strong> - TDD/BDD assertion library.</li>
                <li><strong>SinonJS</strong> - Standalone test spies, stubs and mocks for JavaScript.</li>
            </ul>

            <h2>Unit Testing</h2>

            <p>Unit testing is a type of software testing where individual units of source code or components are tested. This type of testing is carried out to validate that each unit of the software code performs as expected. Unit testing is carried out during the development phase by the developers. A unit is the smallest testable part of any software.</p> 

            <p>Unit tests can test:</p>

            <ul>
                <li>Functions</li>
                <li>Pure classes</li>
                <li>Components - React, Angular, Vue.js, Web Components</li>
            </ul>

            <p>It's usually convention to put each test file next to the unit or component being tested.</p>

<pre>
    <code>
<!-- Just leave this line alone -->
directory /
    script.js
    script.test.js
<!-- Just leave this line alone -->
    </code>
</pre>

            <h2>Mocking</h2>

            <p>Mocking is a technique where code parts are replaced by dummy implementations that emulate real code. Mocking helps to achieve isolation of tests and is primary used in unit testing. Mocking allows testing to be easier and allows an ideal setup to be used in your tests allowing the focus to be on the bits of the application we developed ourselves and not third-party code. It's especially useful when it's expensive or impractical to include a dependency directly in our tests.</p>

            <p>Examples of where we would use mocking to test:</p>

            <ul>
                <li>Replace access or interaction with a real database.</li>
                <li>Avoid making HTTP calls to an API.</li>
            </ul>

            <h2>Snapshot Testing</h2>

            <p>Snapshot tests are a very useful tool whenever you want to make sure your UI (User Interface) does not change unexpectedly. A typical test renders a UI component, takes a snapshot, then compares it to a reference snapshot file stored alongside the test. The test will fail if the two snapshots do not match.</p>

            <p>The snapshot artifact should be committed alongside your code changes and reviewed as part of your code review process.</p>

            <p>In React, instead of rendering the graphical interface, which would require building the full application, you can use the test renderer to quickly generate a serializable value for your React tree.</p> 

            <h2>TDD (Test-Driven Development)</h2>

            <p>In JavaScript, as with many other languages, you will want to follow <strong>test-driven development</strong> (<strong>TDD</strong>) a discipline which imposes writing a failing test first before writing code.</p>

            <h2>Visual Testing (Visual Regression)</h2>

            <p>Visual tests, also called visual regression tests, catch bugs in UI appearance. They work by taking screenshots and then comparing them commit-to-commit to identify changes.</p>

            <h2>Jest</h2>

            <p>Jest is a JavaScript test runner, a library for creating, running and structuring tests. It is the default choice for React projects.</p>

            <p>Jest will look for the following test files:</p>

            <ul>
                <li>JavaScript files with a <strong>.js</strong> file extension in a <strong>__tests__</strong> folder.</li>
                <li>JavaScript files with a <strong>.test.js</strong> file extension.</li>
                <li>JavaScript files with a <strong>.spec.js</strong> file extension.</li>
            </ul>

            <p>In JavaScript, it's common to see test files end with <strong>.spec.js</strong> as developers use "spec" as shorthand for "specification".</p>

            <p>Jest can be installed using NPM (Node Package Manager):</p>

<!-- Terminal -->
<div class="terminal terminal--shadow">
    <div class="terminal__top">
        <div class="terminal__buttons">
            <span class="terminal__circle terminal__circle--red"></span>
            <span class="terminal__circle terminal__circle--yellow"></span>
            <span class="terminal__circle terminal__circle--green"></span>
        </div>
        <div class="terminal__title">bash -- 85x24</div>
    </div>
    <pre class="terminal__body">
<!-- Just leave this line alone -->
    $ npm install jest ---save-dev
    </pre>
</div>
<!-- / Terminal -->

            <p>A script will be required to be added to your <strong>package.json</strong> file to run Jest.</p>

<pre>
    <code>
<!-- Just leave this line alone -->
"scripts": {
    "test": "jest"
},
<!-- Just leave this line alone -->
    </code>
</pre>

            <p>You can then run Jest.</p>

<!-- Terminal -->
<div class="terminal terminal--shadow">
    <div class="terminal__top">
        <div class="terminal__buttons">
            <span class="terminal__circle terminal__circle--red"></span>
            <span class="terminal__circle terminal__circle--yellow"></span>
            <span class="terminal__circle terminal__circle--green"></span>
        </div>
        <div class="terminal__title">bash -- 85x24</div>
    </div>
    <pre class="terminal__body">
<!-- Just leave this line alone -->
    $ npm run test
    </pre>
</div>
<!-- / Terminal -->

            <h3>Writing Tests in Jest</h3>

            <p>Time to create your first test in Jest. It is often recommended to save a test file next to the code you're testing and name the test file with the file extension of <strong>.spec.js</strong> as Jest will search for test files with a <strong>.test.js</strong> or <strong>.spec.js</strong> filename, or alternatively a <strong>.js</strong> file placed within a directory named __tests__</p>

            <p>If the file we are testing were to be named <strong>example.js</strong>, then our test file should be named <strong>example.spec.js</strong> like so:</p>

<pre>
    <code>
<!-- Just leave this line alone -->
directory /
    example.js
    example.spec.js
<!-- Just leave this line alone -->
    </code>
</pre>

            <p>Inside the test file (the file named .spec.js), create a <strong>test block</strong>. Jest uses the <strong>describe</strong> method. This is a method for containing one or more related tests. Every time you start writing a new suite of tests, wrap it in a describe block.</p>

            <p>As you can see, it takes two arguments: a string for describing the test suite and a callback function for wrapping the actual test.</p> 

<pre>
    <code>
<!-- Just leave this line alone -->
describe("Description of the test suite here", () => {
   // Test stuff goes here 
});
<!-- Just leave this line alone -->
    </code>
</pre>

            <p>We then use another function called <strong>test</strong> which is the actual test block.

<pre>
    <code>
<!-- Just leave this line alone -->
describe("Description of the test suite here", () => {
   test("It is testing something here", () => {
        // Actual test
    });
});
<!-- Just leave this line alone -->
    </code>
</pre>

            <p>As an example, let's write a simple test that checks if a simple calculation is true.</p>

<pre>
    <code>
<!-- Just leave this line alone -->
describe("sum of 2 numbers", () => {
    it("2 + 2 equal 4", () => {
        expect(2 + 2).toEqual(4)
    });
});
<!-- Just leave this line alone -->
    </code>
</pre>

            <h3>Example: Hello Test</h3>

            <p>At this point we're ready to write an actual test. Remember, testing is a matter of <strong>input</strong>, <strong>functions</strong>, and <strong>expected outputs</strong>.</p>

            <p>Here's a very simple test file named <strong>SimpleModule.spec.js</strong>:</p>

<pre>
    <code>
<!-- Just leave this line alone -->
import { simpleFunc } from "./SimpleModule";

describe("A simple module", () => {
    test("it should say hello", () => {
        expect(simpleFunc()).toEqual("hello!");
    });
});
<!-- Just leave this line alone -->
    </code>
</pre>

            <p>You may need to setup <strong>Babel</strong> in your project to allow the import statement to be used here. Using <strong>Webpack</strong> is one solution to create a frontend build process.</p> 

            <p>And now we write the module as a function and export the function to allow it to be imported. This file should be named <strong>SimpleModule.js</strong></p>

<pre>
    <code>
<!-- Just leave this line alone -->
export function simpleFunc() {
    return "hello!";
}
<!-- Just leave this line alone -->
    </code>
</pre>

            <p>Here's file file structure:</p>

<pre>
    <code>
<!-- Just leave this line alone -->
directory /
    SimpleModule.js
    SimpleModule.spec.js
<!-- Just leave this line alone -->
    </code>
</pre>

            <p>You will need to <strong>import</strong> the function your testing in your test file. Here is our example file structure for our next example:</p>

<pre>
    <code>
<!-- Just leave this line alone -->
directory /
    filter.js
    filter.spec.js
<!-- Just leave this line alone -->
    </code>
</pre>

            <h3>Example: Array Test</h3>

            <p>Let's define a simple input, an array of objects:</p>

<pre>
    <code>
<!-- Just leave this line alone -->
import { filterByTerm } from './filter.js';

describe("Filter function", () => {
    test("it should filter by a search term (link)", () => {
    
        const input = [
            { id: 1, url: "https://www.url1.dev" },
            { id: 2, url: "https://www.url2.dev" },
            { id: 3, url: "https://www.link3.dev" }
        ];
    });
});
<!-- Just leave this line alone -->
    </code>
</pre>

            <p>Next, we define the <strong>expected result</strong>.</p>

<pre>
    <code>
<!-- Just leave this line alone -->
import { filterByTerm } from './filter.js';

describe("Filter function", () => {
    test("it should filter by a search term (link)", () => {
    
        const input = [
            { id: 1, url: "https://www.url1.dev" },
            { id: 2, url: "https://www.url2.dev" },
            { id: 3, url: "https://www.link3.dev" }
        ];

        const output = [{ id: 3, url: "https://www.link3.dev" }];
    });
});
<!-- Just leave this line alone -->
    </code>
</pre>

            <p>Now we can write the actual test using <strong>expect</strong> and a Jest <strong>matcher</strong> for checking if our function - <strong>filterByTerm()</strong> - returns the expectd result when called.</p>

<pre>
    <code>
<!-- Just leave this line alone -->
import { filterByTerm } from './filter.js';

describe("Filter function", () => {
    test("it should filter by a search term (link)", () => {
    
        const input = [
            { id: 1, url: "https://www.url1.dev" },
            { id: 2, url: "https://www.url2.dev" },
            { id: 3, url: "https://www.link3.dev" }
        ];

        const output = [{ id: 3, url: "https://www.link3.dev" }];

        expect(filterByTerm(input, "link")).toEqual(output);
    });
});
<!-- Just leave this line alone -->
    </code>
</pre>

            <p>When we run the test it will <strong>fail</strong> as we have no function to test against. Let's write a function in a file name <strong>filter.js</strong></p>

<pre>
    <code>
<!-- Just leave this line alone -->
export function filterByTerm(inputArr, searchTerm) {
    return inputArr.filter(function(arrayElement) {
        return arrayElement.url.match(searchTerm);
    });
}
<!-- Just leave this line alone -->
    </code>
</pre>

            <p>For each element of the input array we check the "url" property, matching it against a regular expression with the match <strong>method</strong>.</p>

            <p>Now when we run the test it should pass.</p>

<!-- Terminal -->
<div class="terminal terminal--shadow">
    <div class="terminal__top">
        <div class="terminal__buttons">
            <span class="terminal__circle terminal__circle--red"></span>
            <span class="terminal__circle terminal__circle--yellow"></span>
            <span class="terminal__circle terminal__circle--green"></span>
        </div>
        <div class="terminal__title">bash -- 85x24</div>
    </div>
    <pre class="terminal__body">
<!-- Just leave this line alone -->
    $ npm run test
    </pre>
</div>
<!-- / Terminal -->

            <h2>Code Coverage</h2>

            <p>Code coverage checks that the test covers every line of your code base. For instance, say you go straight into the function and add a few lines of new code. Unless you update the test to identify this new code, you're not going to know exactly what to test in our function. Code coverage is the tool that provides the utility and Jest has code coverage built-in.</p>

            <p>You can set code coverage by passing the flag to the test script:</p>

<pre>
    <code>
<!-- Just leave this line alone -->
"scripts": {
    "test": "jest --coverage"
},
<!-- Just leave this line alone -->
    </code>
</pre>

            <p>Or you can update the package.json file, like so:</p>

<pre>
    <code>
<!-- Just leave this line alone -->
"scripts": {
    "test": "jest"
},
"jest": {
    "collectCoverage": true
}
<!-- Just leave this line alone -->
    </code>
</pre>

            <p>You can also build an HTML report if you'd prefer to have the report be more visual:</p>

<pre>
    <code>
<!-- Just leave this line alone -->
"scripts": {
    "test": "jest"
},
"jest": {
    "collectCoverage": true,
    "coverageReporters": ["html"]
}
<!-- Just leave this line alone -->
    </code>
</pre>

            <p>Now every time you run your tests, you can access a new folder called <strong>coverage</strong> in your project.</p>

            <p>When you run the test with code coverage enabled, you will see any lines of code not covered (uncovered) by your tests. This helps to identify if a new piece of code has been added into your functions without the test being updated. You should then update your test.</p>

            <p>With code coverage you can discover what to test when in doubt.</p>

		</div>
	</div>
</main>

</body>
</html>