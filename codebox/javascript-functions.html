<!DOCTYPE html>
<html lang="en-GB">
<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="A guide to JavaScript functions">

	<title>Codebox - JavaScript Functions</title>

	<link rel="shortcut icon" type="image/ico" href="favicon/code.ico">
	<link rel="stylesheet" href="style/foundation.min.css">
	<link rel="stylesheet" href="style/main.css">
</head>
<body>

<main role="main">
	<div class="row">
		<div class="columns small-12 large-12">

			<h1>JavaScript Functions</h1>

            <p>Functions let you group a series of statements together to perform a specific task. If different parts of a script repeat the same task, you can reuse the function rather than repeating the same set of statements. The statements the function needs to perform its task are packaged up within a <strong>code block</strong>.</p>

            <p>Statements in a function are not always executed when a page loads. You may have a task you only want to perform if the useer clicks on a specific element, such as a button on the page.</p>

            <p>If you are going to ask the function to perform its task later, you need to give the function a name. This name should describe the task the function is performing. This is known as calling the function. Nothing will happen and no code will be executed until we call (<strong>invoke</strong>) the function.</p>

            <p>When we write a function and expect it to provide you with an answer, the response is known as the <strong>return value</strong>.</p>

            <p>A function is declared using the <strong>function</strong> keyword. Below is the syntax for a function in JavaScript.</p>

<pre>
    <code>
<!-- Just leave this line alone -->
function func() {
    // Code to be executed here
}
<!-- Just leave this line alone -->
    </code>
</pre>

            <h2>Declaring a Function</h2>

            <p>To create a function you need to provide it with a name and any statements needed to to achieve its task should by within the curly braces. When a function is created it is known as a <strong>function declaration</strong>.</p> 

            <p>This function is very basic as it only contains one statement inside of the code block. Most functions that you see or write are likely to consist of more than one statement.</p>

<pre>
    <code>
<!-- Just leave this line alone -->
function sayHello() {
    document.write("Hello");
}
<!-- Just leave this line alone -->
    </code>
</pre>

            <h2>Calling a Function</h2>

            <p>Having now declared a function, you can now execute all of the statements between the curly braces with a single line of code. This is known as <strong>calling the function</strong>.</p>

            <p><strong>Defining a function does not execute it, calling a function executes the code.</strong></p>

            <p>To run the code within the function, use the function name followed by parenthesis. The function can be called as many times as you like within the same script.</p>

            <p>The function executes the code within the code block. When finished, the code continues to run from the point where it was initially called.</p>

            <p>Here, we are calling the <strong>sayHello()</strong> function:</p>

<pre>
    <code>
<!-- Just leave this line alone -->
sayHello();
<!-- Just leave this line alone -->
    </code>
</pre>

            <p>Sometimes you will see a function called before it has been declared. This still works as the interpreter runs through the script before executing each statement so it will know that a function declaration appears later in the script. Ideally, declaring the function before calling it is the best solution.</p>

            <h2>Function Parameters</h2>

            <p>Using parameters allows our functions to be more flexible. Parameters allow values to be passed into functions and to behave in a similar way to local variables. Sometimes a function needs specific information to perform its task and this is why parameters are useful.</p>

            <p>Perhaps when a user logs into an application, we may want to greet the user by name. We can add a parameter into our function, called name, to represent the name of the person being greeted. Parameters to be added to the function should be placed inside of the parenthesis of the function.</p>

<pre>
    <code>
<!-- Just leave this line alone -->
function sayHello(name) {
    document.write("Hello");
}
<!-- Just leave this line alone -->
    </code>
</pre>

            <p>Inside the function we can then output the value passed into the name parameter.</p>

<pre>
    <code>
<!-- Just leave this line alone -->
function sayHello(name) {
    document.write("Hello " + name);
}
<!-- Just leave this line alone -->
    </code>
</pre>

            <p>In ES6, instead of a static string we can use a <strong>template literal</strong> string containing the parameter. This now behaves like a local variable.</p>

<pre>
    <code>
<!-- Just leave this line alone -->
function sayHello(name) {
    document.write(`Hello ${name}`);
}
<!-- Just leave this line alone -->
    </code>
</pre>

            <p>We haven't yet defined and passed in the value of name. We assign a value when we invoke (call) our funcction. Let's assume the value of name is <strong>Dan</strong>. When we call the function, we assign this value as an <strong>argument</strong> and this is then passed into the parameter when the function is called.</p>

<pre>
    <code>
<!-- Just leave this line alone -->
sayHello("Dan");
<!-- Just leave this line alone -->
    </code>
</pre>

            <p>When we call the function, <strong>Hello Dan</strong> will be printed on the page.</p>

            <h2>Default Parameters</h2>

            <p>Default parameters were introduced as part of the ES6 syntax. This allows developers to initialize a function with a default value if an argument is not supplied when the function is called. This can help to make our functions easier to read and avoid errors that stem from passing in undefined arguments.</p>

            <p>Within the following function, we return the cube of a given number defined as <strong>x</strong>.</p>

<pre>
    <code>
<!-- Just leave this line alone -->
function cube(x) {
    return x * x * x;
}
<!-- Just leave this line alone -->
    </code>
</pre>

            <p>If not value is passed as an argument into a function, the function will implicitly use undefined as the value and return <strong>NaN</strong> (<strong>Not a Number</strong>). In this example, the function would then calculate the value of <strong>undefined * undefined * undefined</strong> which results in NaN being returned.</p>

<pre>
    <code>
<!-- Just leave this line alone -->
cube();
<!-- Just leave this line alone -->
    </code>
</pre>

            <p>Setting a default value avoids this occuring. A default value can be added to the parameter in the function using the <strong>assignment operator</strong> (=).</p>

<pre>
    <code>
<!-- Just leave this line alone -->
function cube(x = 5) {
    return x * x * x;
}

cube();     // 5 * 5 * 5
<!-- Just leave this line alone -->
    </code>
</pre>

            <p>If a value is passed into the parameter as an argument, then the default value will be overwritten.</p>

<pre>
    <code>
<!-- Just leave this line alone -->
function cube(x = 5) {
    return x * x * x;
}

cube(2);     // 2 * 2 * 2
<!-- Just leave this line alone -->
    </code>
</pre>

            <p>Before the introduction of default parameters in ES6, we would normally have to explicitly check for undefined values in order to set a default value.</p>

<pre>
    <code>
<!-- Just leave this line alone -->
function cube(x) {

    // Check to see if an argument is undefined
    if (typeof x === 'undefined') {
        // Set a default value if the argument is undefined
        x = 5;
    }

    return x * x * x;

}

cube();     // 5 * 5 * 5
<!-- Just leave this line alone -->
    </code>
</pre>

            <h2>Function Expressions</h2>

            <p>In earlier examples we used function declarations, but <strong>function expressions</strong> can also be used by assigning a function to a variable.</p>

            <p>Here we are creating a function expression for calculating the area of a shape.</p>

<pre>
    <code>
<!-- Just leave this line alone -->
const area = function getArea(width, height) {
    return width * height;
}

area(20, 40);
<!-- Just leave this line alone -->
    </code>
</pre>

            <p>Now the area constant is a function, we can make this expression more concise by turning it into an <strong>anonymous function</strong> which is an unnamed function. A named function may help and aid in debugging but it not necessary. Currently our function has a name of getArea, but with a function expression a name is not necessary and is usually omitted.</p>

<pre>
    <code>
<!-- Just leave this line alone -->
const area = function(width, height) {
    return width * height;
}

area(20, 40);
<!-- Just leave this line alone -->
    </code>
</pre>

            <p>Here is a <strong>function expression</strong> (function can be anonymous, as here) example:</p>

<pre>
    <code>
<!-- Just leave this line alone -->
const square = function(number) {
    return number * number;
}

let x = square(4);      // x gets the value 16
<!-- Just leave this line alone -->
    </code>
</pre>

            <p>This function can also be written using <strong>ES6</strong> (arrow function) syntax:</p>

<pre>
    <code>
<!-- Just leave this line alone -->
const square = number => {
    return number * number;
}

let x = square(4);      // x gets the value 16
<!-- Just leave this line alone -->
    </code>
</pre>

            <p>Here is a <strong>function declaration</strong> example:</p>

<pre>
    <code>
<!-- Just leave this line alone -->
function square(number) {
    return number * number;
}

square(4);      // 16
<!-- Just leave this line alone -->
    </code>
</pre>

            <p>The main difference between a function expression and a function declaration is the function name. A function name can be omitted (removed) from a function expression, to create anonymous functions. A function expression can also be used as an IIFE which runs as soon as it's defined.</p>

            <h2>Function scope</h2>

            <p>Variables defined inside a function cannot be accessed from anywhere outside the function. This is because the variable is defined only in the scope of the function. A function can however, access all variables and functions defined inside the scope in which it's defined.</p>

            <p>In other words, a function defined in the global scope can access all variables defined in the global scope. A function defined inside another function can also access all variables defined in its parent function and any other variables to which the parent function has access.</p>

<pre>
    <code>
<!-- Just leave this line alone -->
// The following variables are defined in the global scope
const numOne = 20;
const numTwo = 3;

// This function is defined in the global scope
function multiply() {
    return numOne * numTwo;
}

multiply();     // 60
<!-- Just leave this line alone -->
    </code>
</pre>

            <p>We can then rewrite our code to consider function scope:</p>

<pre>
    <code>
<!-- Just leave this line alone -->
function getScore() {
    
    let numOne = 2;
    let numTwo = 3;
    let name = 'Dan';

    function add() {
        return name + ' scored ' + (numOne + numTwo);
    }

    return add();
}

getScore();     // Dan scored 5
<!-- Just leave this line alone -->
    </code>
</pre>

            <h2>Hoisting</h2>

            <p>Hoisting refers to the availability of functions and variables at the top of your code as opposed to being available after they have been declared (created).</p>

            <p><strong>Function declarations</strong> are hoisted but <strong>function expressions</strong> are not.</p>

            <p>In this example, a function is called before a function declaration. This is an example of hoisting and will not cause an error as we're using a function declaration.</p>

<pre>
    <code>
<!-- Just leave this line alone -->
logStuff();

function logStuff() {
    console.log('This is a test log');
}
<!-- Just leave this line alone -->
    </code>
</pre>

            <p>If we use a <strong>function expression</strong> however, an error (Uncaught ReferenceError: Cannot access 'logStuff' before initialization) will be thrown:</p>

<pre>
    <code>
<!-- Just leave this line alone -->
logStuff();

const logStuff = () => {
    console.log('This is a test log');
}
<!-- Just leave this line alone -->
    </code>
</pre>

            <p>Hoisting is important when thinking about when and where a function is needed.</p>

            <p>Function expressions are invoked to avoid polluting the global scope. Instead of your program being aware of many different functions, if they're anonymous (which can only be done using function expressions), they are used and forgotten about immediately.</p>

            <h2>Arrow Functions</h2>

            <p>A newer, more concise method of defining a function is to use the Arrow function expression. This is part of the ES6 syntax. Arrow functions are represented by an equals sign followed by a greater than sign (=&gt;).</p>

            <p>Arrow functions are always anonymous functions and a type of a function expression. We use the =&gt; arrow to indicate a function without the need to use the <strong>function</strong> keyword.</p>

<pre>
    <code>
<!-- Just leave this line alone -->
const area = (width, height) => {
    return width * height;
}

area(20, 40);
<!-- Just leave this line alone -->
    </code>
</pre>

            <p>If a function has just a single parameter, the parenthesis can be excluded. In this example, we are squaring the value of <strong>x</strong> which only requires one number to be passed as an argument.</p>

<pre>
    <code>
<!-- Just leave this line alone -->
const squared = x => {
    return x * x;
}

squared(8);
<!-- Just leave this line alone -->
    </code>
</pre>

            <p>If a function has no parameters, an empty set of parenthesis is required.</p>

<pre>
    <code>
<!-- Just leave this line alone -->
const sayHello = () => {
    document.write("Hello");
}

sayHello();
<!-- Just leave this line alone -->
    </code>
</pre>

            <p>The <strong>return</strong> keyword is implied and can be omitted if using an arrow function without a block body.</p>

<pre>
    <code>
<!-- Just leave this line alone -->
let func = (a, b, c) => a + b + c
<!-- Just leave this line alone -->
    </code>
</pre>

            <p>In ES5, this same function may look like this:</p>

<pre>
    <code>
<!-- Just leave this line alone -->
function func(a, b, c) {
    return a + b + c;
}
<!-- Just leave this line alone -->
    </code>
</pre>

            <h2>Destructuring Functions</h2>

            <p><strong>Destructuring syntax</strong> can be applied to destructure the parameters in a function. To test this we will destructure the <strong>keys</strong> and <strong>values</strong> out of <strong>Objects.entries()</strong>. First we declare an object called <strong>note</strong>:</p>

<pre>
    <code>
<!-- Just leave this line alone -->
const note = {
    id: 1,
    title: 'My first note',
    date: '01/01/1970'
}
<!-- Just leave this line alone -->
    </code>
</pre>

            <p>Given this object, you could list the <strong>key-value</strong> pairs by destructuring arguments as they are passed to the <strong>forEach()</strong> method.</p>

<pre>
    <code>
<!-- Just leave this line alone -->
Object.entries(note).forEach(([key, value]) => {
    console.log(`${key}: ${value}`); 
});
<!-- Just leave this line alone -->
    </code>
</pre>

            <p>Or you could accomplish the same thing using a <strong>for loop</strong>:</p>

<pre>
    <code>
<!-- Just leave this line alone -->
for (let [key, value] of Object.entries(note)) {
    console.log(`${key}: ${value}`);
}
<!-- Just leave this line alone -->
    </code>
</pre>

            <p>Either way, you will receive the following output:</p>

<pre>
    <code>
<!-- Just leave this line alone -->
id: 1
title: My first note
date: 01/01/1970
<!-- Just leave this line alone -->
    </code>
</pre>

            <p>We can extend the object further:</p>

<pre>
    <code>
<!-- Just leave this line alone -->
const note = {
    id: 1,
    title: 'My first note',
    author: {
        firstName: 'Sherlock',
        lastName: 'Holmes'
    },
    tags: ['personal', 'writing', 'investigations']
}
<!-- Just leave this line alone -->
    </code>
</pre>

            <p>We can then destructure this object whilst setting a new <strong>date</strong> property with the default of new <strong>Date()</strong>.</p>

<pre>
    <code>
<!-- Just leave this line alone -->
const {
    id,
    title,
    date = new Date(),
    author = {firstName},
    tags: [personalTag, writingTag]
} = note;

console.log(date);      // Wed Nov 18 2020 23:53:49 GMT-0500 (Central Daylight Time)
<!-- Just leave this line alone -->
    </code>
</pre>

            <h2>Getting Multiple Values</h2>

            <p>Functions can return more than one value using an array. For example, this function calculates both the area and the volume.</p>

<pre>
    <code>
<!-- Just leave this line alone -->
function getSize(width, height, depth) {
    var area = width * height;
    var volume = width * height * depth;
    var sizes = [area, volume];

    return sizes;
}

var area = getSize(3, 2, 3)[0];         // Area
var volume = getSize(3, 2, 3)[1];       // Volume
<!-- Just leave this line alone -->
    </code>
</pre>

            <ul>
                <li>First, a new function is created called <strong>getSize()</strong>. The area of the box is calculated and stored in a variable called area.</li>
                <li>The volume is calculated and stored in a variable called volume. Both are then placed into an array named sizes.</li>
                <li>The array is then returned to the code that called the getSize() function, allowing the values to be used.</li>
                <li>The <strong>area</strong> variable holds the area of the box that is 3 x 2. The area is the first value in the array <strong>[0]</strong>.</li>
                <li>The <strong>volume</strong> variable holds the volume of the box, 3 x 2 x 3. The volume is the second value in the array <strong>[1]</strong>.</li>
            </ul>

            <h2>Immediately Invoked Function Expression (IIFE)</h2>

            <p>An IIFE is a way to execute functions immediately, as soon as they are created. They are very useful because they don't pollute the global object.</p>

<pre>
    <code>
<!-- Just leave this line alone -->
(function() {
    
    /* */

}());
<!-- Just leave this line alone -->
    </code>
</pre>

            <p>We can also define an IIFE using an ES6 arrow function:</p>

<pre>
    <code>
<!-- Just leave this line alone -->
(() => {
    
    /* */

}());
<!-- Just leave this line alone -->
    </code>
</pre>

            <p>We basically have a function defined inside parenthesis and then we append <strong>()</strong> to execute that function. The wrapping parenthesis are actuallty what makes our function to be a function expression. If this were a function declaration it would be invalid (Syntax Error) because we hadn't specified a name. The IIFE is an <strong>anonymous function</strong> as it has no name.</p>

            <p>Function declarations require a name, while function expressions do not.</p> 

<pre>
    <code>
<!-- Just leave this line alone -->
function() {
    
    /* SyntaxError: function statement requires a name */

};
<!-- Just leave this line alone -->
    </code>
</pre>

            <p>An IIFE can also be named. This does not change the fact that the function does not "leak" to the global scope and it cannot be invoked again after its execution.</p>

<pre>
    <code>
<!-- Just leave this line alone -->
(function doSomething() {
    
    /* */

}());
<!-- Just leave this line alone -->
    </code>
</pre>

            <p>Put simply, an <strong>Immediately Invoked Function Expression (IIFE)</strong> is a good way at protecting the scope of your function and variables within it. IIFEs are often used in JavaScript frameworks and libraries in order to wrap all of their code inside in order to protect the scope of the code within the function (avoids the code polluting the global namespace) and to make sure everything is executed without the user having to do anything.</p>

            <p>You may want to pass global objects into the IIFE to use them in your code and protect them from the global scope. IN this example we are passing the global <strong>Document</strong> and <strong>Window</strong> objects into the IIFE. The parameters in the function are also named <strong>'window'</strong> and <strong>'document'</strong>, but the parameters can be named whatever you consider suitable.</p>

<pre>
    <code>
<!-- Just leave this line alone -->
(function(window, document) {
    
    /* */

}(window, document));
<!-- Just leave this line alone -->
    </code>
</pre>

            <p>You may also have an object - named <strong>config</strong> in this example - outside of the IIFE you want to pass into the function as a parameter.</p>

<pre>
    <code>
<!-- Just leave this line alone -->
const config = {
    color: '#fff',
    backgroundColor: '#000',
    message: {
        intro: 'Hello and Welcome!'
    }
};

(function(w, d, c) {
    
    let color = c.color;
    let message = c.message.intro;

    console.log(color);     // #fff
    console.log(message);   // Hello and Welcome!

}(window, document, config));
<!-- Just leave this line alone -->
    </code>
</pre>

            <h2>Currying</h2>

            <p><strong>Currying</strong> is an advanced technique that can be used when working with functions in JavaScript. Currying, or <strong>partial application</strong>, is a process where a function takes multiple arguments one at a time. In other words, you can pass all the arguments a function is expecting and get the result. So, rather than have a function that looks like this:</p>

<pre>
    <code>
<!-- Just leave this line alone -->
function(arg1, arg2, arg3) {}
<!-- Just leave this line alone -->
    </code>
</pre>

            <p>You have something that looks like this:</p>

<pre>
    <code>
<!-- Just leave this line alone -->
function(arg1)(arg2)(arg3) {}
<!-- Just leave this line alone -->
    </code>
</pre>

            <p>When you pass in an argument, the first function processes it then returns a function that processes the next parameter. This allows you to chain your arguments.</p>

            <p>Let's take a look at another example. Here's a function for a greeting using familiar syntax:</p>

<pre>
    <code>
<!-- Just leave this line alone -->
const greeting = function(greeting, name) {
    console.log(greeting + " " + name);
}

greeting("Hello", "Dan");
<!-- Just leave this line alone -->
    </code>
</pre>

            <p>This function requires both the name and the greeting to be passed as arguments to work. If you were to pass just the greeting you would get <strong>"Hi undefined"</strong> returned.</p>

            <p>We can rewrite this function using currying so that the basic function only requires the greeting and it can return another function that takes the name of the person we would like to greet.</p>

<pre>
    <code>
<!-- Just leave this line alone -->
const greeting = function(greeting) {
    return function(name) {
        console.log(greeting + " " + name);
    };
};
<!-- Just leave this line alone -->
    </code>
</pre>

            <p>Now we have a new function for any type of greeting and we can pass that new function the name of the person we want to greet.</p>

<pre>
    <code>
<!-- Just leave this line alone -->
const greeting = function(greeting) {
    return function(name) {
        console.log(greeting + " " + name);
    };
};

const sayGreeting = greeting("Hi");

sayGreeting("Dan");         // Hi Dan
sayGreeting("Pearl");       // Hi Pearl
<!-- Just leave this line alone -->
    </code>
</pre>

            <p>You can also call the original curried function directly by passing in each of the parameters in a separate set of parenthesis.</p>

<pre>
    <code>
<!-- Just leave this line alone -->
const greeting = function(greeting) {
    return function(name) {
        console.log(greeting + " " + name);
    };
};

greeting("Hi")("Dan");       // Hi Dan
greeting("Hi")("Pearl");     // Hi Pearl
<!-- Just leave this line alone -->
    </code>
</pre>

            <p>Currying is useful because it lets you chain your arguments in a way that prevents if from having side effects. This is an example of functional programming, your function does one thing and one thing only. If a function has more than one argment, it can have additional side effects. The final argument in a chain has access to all arguments in the chain, therefore, regardless of how it's called, if the sequence is correct, the final result will always return as expected.</p>

            <p>Currying also makes your code quick and easier to read. This lets you create a sequence of functions and ensures that this is enforced. This makes it easier to detect issues every step of the way.</p>

		</div>
	</div>
</main>

</body>
</html>