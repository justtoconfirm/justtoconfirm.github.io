<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1" />
	<title>Dev Notes - Non Published</title>
	<link rel="stylesheet" href="styles/foundation.min.css" />
	<link rel="stylesheet" href="styles/style.min.css" />

	<!-- Breakout CSS -->
	<style>
	canvas {
		background: #eee;
		display: block;
		margin: 0 auto;
	}
	</style>
	<!-- / Breakout CSS -->

</head>
<body>

<header>
	<div class="row">
		<div class="small-12 medium-12 large-12 columns">
			<div class="header__icon header__icon--js">
				<span class="header__icon--marks">&lt; &gt;</span>
			</div>
		</div>
	</div>
</header>

<div class="row">
	<div class="small-12 medium-12 large-12 columns">

		<!-- Notes that are hidden from the main site go here -->
		<h1>Non Published Notes</h1>

		<h3>Udemy: JavaScript Essentials - Lawrence Turton</h3>

		<!-- Code example -->
		<div class="code" rel="js" data-title="JS">
			<pre>
				<code>
<!-- Leave this line empty -->
var x = 10;
var y = 30;

function add ( arg1, arg2 ) {
	return arg1 + arg2;
}

add (x, y);
				</code>
			</pre>
		</div>
		<!-- / Code example -->



		

		<!-- Code example -->
		<div class="code" rel="js" data-title="JS">
			<pre>
				<code>
<!-- Leave this line empty -->
{
	// Properties
	width: 25,
	height: 27,
	color: 'red',
	// Methods - a function contained within an object
	eat: function () {
		"Eat the apple.";
	},
	throw: function () {
		"Throw the apple away.";
	}
}
				</code>
			</pre>
		</div>
		<!-- / Code example -->

		<p>Images on a canvas are objects. So if we had three images, we would have three objects on the canvas. Objects are important because they allow you to group information together. Let's create an object of a fridge:</p>

		<!-- Code example -->
		<div class="code" rel="js" data-title="JS">
			<pre>
				<code>
<!-- Leave this line empty -->
{
	make: 'fridgeTastic',
	width: 2400,
	height: 4400,
	open: function () {
		...
	}
}
				</code>
			</pre>
		</div>
		<!-- / Code example -->

		<blockquote>
			<p>Objects are just nouns and verbs.</p>
		</blockquote>

		<h3>Embedded objects</h3>

		<p>Objects can contain other objects. A fridge can contain food. Multiple objects can be encapsulated into a single object. A parent object will contain child objects. If you think about a car engine, you can go into some depth. Encapsulation - grouping data together, a 'capsule'.</p>

		<h3>Primitive Date</h3>

		<p>Basic data. like a String. You may need to escape certain chracters.</p>

		<!-- Code example -->
		<div class="code" rel="js" data-title="JS">
			<pre>
				<code>
<!-- Leave this line empty -->
// This is a String
"hello"
// This is also a String
'hello'

// This will create a syntax error, as it's looking for JS variable of 'hello' that doesn't exist
"he said "hello""
// How to fix - escape the " characters by putting \ before the character itself
"he said \"hello\" thats it"
// This also works
'he said "hello" thats it'
				</code>
			</pre>
		</div>
		<!-- / Code example -->

		<p>A number type in JS is a primitive data type. Whole integers e.g. 100, 200, 1. We also have floating point numbers which are fractional numbers like: 1.1 or 100.256 (decimal numbers).</p>

		<p>Boolean is either true or false. This is not a string as it does not have quotation marks. null and undefined are also primitive types and not strings (again, because no quotation marks). null could mean no value it is empty and void (has nothing). null is the same as undefined. You have a variable that is empty, it can use null as it's a value, but the variable is empty. NaN (Not a Number) check if variable has a number stored. If it is not a number, NaN will be returned. Useful for mathematical expressions.</p>

		<h3>Variables &amp; Constants</h3>

		<p>var keyword is used to create a variable, you are creating a 'box' to store a value. The name of the variable is a 'memory address', an alias. Assignment operator is a command to the JIT compiler. The semi-colon ends the JS statement.</p>

		<!-- Code example -->
		<div class="code" rel="js" data-title="JS">
			<pre>
				<code>
<!-- Leave this line empty -->
// A variable does not need to a value to be assigned right away - wait for the value
// may return null or undefined (no value/hollow - waiting for a value - empty box).
var blank;

var name = "Dan";
var first_name = "Dan";

// Variable can change, so we can assign a new value
name = "James";

// Boolean
blank = true;

// Array
blank = [];

// Object
blank = {};
				</code>
			</pre>
		</div>
		<!-- / Code example -->

		<p>JavaScript is a loosely typed language, it is loose on its data types. In some programming languages, once a variable is declared with a certain data type, like a String, it cannot be used for anything other than a String. JS allows the variable to change the data type being used, hence why its referred to as a loosely typed language, and that the data type does not need to be declared also. A constant is something that doesn't change once it has been declared and cannot be declared without a value (a sealed 'box').</p>

		<p>In the console, if you open the window object (type window into the console), you will see a list of 'names' we can access either a function or value. A symbols table stores all of these names that allows us to access these values - 'warehouse to store warehouse' the window object is essentially the 'warehouse' and the list within the window object is all the 'boxes' we can have access to (symbol names within the symbol table). If you keep scrolling down within the window object, eventually you will find any variables that you have declared using var or const in the code. Essentially, you have added your 'box' to the window 'warehouse' when you declared a variable.</p> 

		<h3>Operators</h3>

		<p>You need operators within programming language. = in a variable is assignment operator. An operator is a pre-defined function of the language. It is a function within the JIT compiler. When the JIT reaches the operator, it will run the function. See javascript operator prcedence in Google.</p>

		<!-- Code example -->
		<div class="code" rel="js" data-title="JS">
			<pre>
				<code>
<!-- Leave this line empty -->
// Would expect 21 but is actually 11 due to precedence
// Two operators '+' and '*'
// Multiplication gets executed first.
// B O DM AS
// 2 * 3 = 6 + 5 = 11
5 + 2 * 3

// This will fix the issue because the parenthesis will be done first
// Output: 21
(5 + 2) * 3

// Math.pow is invoking a Math function and is a power
Math.pow(2,4) / 2 + 1 - 5 + ( 2 * 12 );
// Output: 28

// 2 x 2 x 2 x 2 - this is 2 to the power of 4
Math.pow(2, 4);

// Brackets are the same as parenthesis - these are done first.

// Use Modulus operator for find remainder
9 % 5
// output: 4
10 % 2
// output: 0 - no remainder (finding odd and even numbers)
				</code>
			</pre>
		</div>
		<!-- / Code example -->

		<!-- https://www.udemy.com/javascript-essentials/learn/v4/t/lecture/4275876?start=0 -->

		<p>You don't read the code left to right, there is an operator precedence to consider (the higher the precedence value, the greater the importance). BODMAS (Brackets (Grouping/Parenthesis), pOwers (Function call), DivisionMultiplication (same precedence), AdditionSubtraction (same precedence).  </p>

		<h3>Assignment Operators</h3>

		<p>Has precendence of 3</p>

		<!-- Code example -->
		<div class="code" rel="js" data-title="JS">
			<pre>
				<code>
<!-- Leave this line empty -->
var number = 20;
// Adding to the existing value
number += 30;		// Output: 50

number -= 10;		// Output: 10

number *= 2

number /= 4
				</code>
			</pre>
		</div>
		<!-- / Code example -->

		<h3>Codebar: HTTP Requests, AJAX and APIs</h3>

		<p>In this tutorial we are going to look at: The HTTP protocol, APIs, JSON, Loading API data into web pages, Using jQuery AJAX functionality. By the end of this tutorial, you will have built: a webpage that can retrieve information about a specified GitHub user and a webpage that can show the upcoming schedule for BBC shows.</p>

		<p>What are HTTP Requests?</p>

		<p>Every time the browser fetches data from a server (which could be a page, an image, a script etc), it does it using HTTP. HTTP is the HyperText Transport Protocol. The server sends back a response. An API is an easy way of fetching information from a remote server, in a way that's easy for a computer to understand.</p>

		<p>GitHub offers a simple API for viewing it's current and historical server availability.</p>

		<p>You can access an API in your web browser. Just pop the following into the address bar:</p>

		<!-- Code example -->
		<pre>
			<code>
<!-- Leave this line empty -->
https://status.github.com/api.json
			</code>
		</pre>
		<!-- / Code example -->

		<p>If you are on a Mac or Linux/Unix machine, you can access the API using curl using your terminal:</p>

		<!-- Code example -->
		<pre>
			<code>
<!-- Leave this line empty -->
curl https://status.github.com/api.json
			</code>
		</pre>
		<!-- / Code example -->

		<p>The GET request, or any requests issues by a website, can be viewed using the browser inspector and selecting the Network (or Net) tab. If we view the request when using the GitHub API above in the address bar, it will display api.json as the document returned. The 200 status shows that it was a successful request and the message is OK.</p>

		<p>As part of the response, the request gives back a status code. You can use this to identify if the request was successful or not.</p>

		<p>HTTP verbs are sent by the browser/client, and along with the URL and data transmitted, form part of the instruction to the API. There are several verbs, but in our example we will mostly be using GET. GET is used to fecth information from an API. Another common verb is POST, which is used to create a new object on the remote service.</p>

		<h3>Using GitHub API</h3>

		<p>We will create a small application that will give us back information about a GitHub user using the GitHub API. We want to show their username, information and their picture. If you enter the following in the address bar:</p>

		<!-- Code example -->
		<pre>
			<code>
<!-- Leave this line empty -->
https://api.github.com/users/codebar
			</code>
		</pre>
		<!-- / Code example -->	
		
		<p>The response will look something like the JSON data below:</p>

		<!-- Code example -->
		<div class="code" rel="js" data-title="JS">
			<pre>
				<code>
<!-- Leave this line empty -->
{
  "login": "codebar",
  "id": 5642384,
  "avatar_url": "https://avatars3.githubusercontent.com/u/5642384?v=4",
  "gravatar_id": "",
  "url": "https://api.github.com/users/codebar",
  "html_url": "https://github.com/codebar",
  "followers_url": "https://api.github.com/users/codebar/followers",
  "following_url": "https://api.github.com/users/codebar/following{/other_user}",
  "gists_url": "https://api.github.com/users/codebar/gists{/gist_id}",
  "starred_url": "https://api.github.com/users/codebar/starred{/owner}{/repo}",
  "subscriptions_url": "https://api.github.com/users/codebar/subscriptions",
  "organizations_url": "https://api.github.com/users/codebar/orgs",
  "repos_url": "https://api.github.com/users/codebar/repos",
  "events_url": "https://api.github.com/users/codebar/events{/privacy}",
  "received_events_url": "https://api.github.com/users/codebar/received_events",
  "type": "Organization",
  "site_admin": false,
  "name": "codebar",
  "company": null,
  "blog": "http://codebar.io",
  "location": "UK",
  "email": "hello@codebar.io",
  "hireable": null,
  "bio": "Learn to code in a friendly and inclusive environment",
  "public_repos": 24,
  "public_gists": 0,
  "followers": 0,
  "following": 0,
  "created_at": "2013-10-08T22:31:46Z",
  "updated_at": "2016-09-12T21:38:14Z"
}
				</code>
			</pre>
		</div>
		<!-- / Code example -->		

		<p>This data is what's called key value pairs, meaning that the name of the field is displayed immediately before the value. As you can see, the URL of the avatar (the user's icon) is in the avatar_url field, and is: https://avatars.githubusercontent.com/u/9906?v=2</p>

		<h3>Getting Started</h3>
		<!-- http://tutorials.codebar.io/js/lesson4/tutorial.html -->
		<p>First open the HTML page provided. As you can see, there is a box to type in a username. When the user has typed in the username, they should be able to trigger the API call to GitHub by pressing &lt;enter&gt;.</p>

		<!-- Code example -->
		<div class="code" rel="html" data-title="HTML">
			<pre>
				<code>
<!-- Leave this line empty -->
&lt;html&gt;
  &lt;head&gt;
    &lt;link rel="stylesheet" href="style.css"&gt;
    &lt;script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"&gt;&lt;/script&gt;
    &lt;script type="text/javascript" src="script.js"&gt;&lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;header&gt;
    &lt;img id="logo" src='https://raw.github.com/codebar/planner/master/app/assets/images/logo.png' width='200' /&gt;
    &lt;/header&gt;
    &lt;div id="container"&gt;
      &lt;div class="search"&gt;
        &lt;input id="username" placeholder="enter a github username..." type="text"&gt;&lt;/input&gt;
      &lt;/div&gt;

      &lt;div id="profile"&gt;
        &lt;h2&gt;&lt;/h2&gt;
        &lt;div class="avatar"&gt;&lt;/div&gt;
        &lt;div class="information"&gt;&lt;/div&gt;
      &lt;/div&gt;

    &lt;/div&gt;

  &lt;/body&gt;
&lt;/html&gt;
				</code>
			</pre>
		</div>
		<!-- / Code example -->		

		<p>Here is the CSS code also:</p>

		<!-- Code example -->
		<div class="code" rel="css" data-title="CSS">
			<pre>
				<code>
<!-- Leave this line empty -->
body {
  font-family: Helvetica, Arial, sans-serif;
  border-top: 5px solid #4c4066;
  margin: 0px auto;
  font-size: 14px;
  color: #666666;
  font-size: 16px;
}

header {
  text-align: center;
  background-color: #fdfdfd;
  border-bottom: 1px solid #e5e2e0;
}

#logo {
  position: relative;
  top: -2px;
}

#container {
  width: 1040px;
  margin: 0px auto;
  min-height: 750px;
  text-align: center;
}

input[type='text'] {
  height: 2.2em;
  font-size: 2em;
  width: 50%;
  padding: 5px;
}

.information, .avatar {
  vertical-align: top;
  display: inline-block;
}

.information {
  text-align: center;
  border-top-left-radius: 5px;
  border-bottom-left-radius: 5px;
}

.search {
  text-align: center;
  margin: 50px auto;
}

h2 {
  padding: 5px;
}

.profile {
  height: 130px;
  width: 150px;
  padding: 90px 30px 0;
  display: block;
  background-color: purple;
  text-decoration: none;
  color: white;
  font-width: bold;
}

.profile:hover {
  background-color: #b300b3;
}
				</code>
			</pre>
		</div>
		<!-- / Code example -->	

		<p>Within the JavaScript file (script.js), the following code allows you to listen for a keypress on the input field and see if it was the &lt;enter&gt; key that was pressed.</p>	

		<!-- Code example -->
		<div class="code" rel="js" data-title="JS">
			<pre>
				<code>
<!-- Leave this line empty -->
$(document).ready(function() {
  $(document).on('keypress', '#username', function() {
    if (event.which === 13) { // check the key was <enter>
      // do something
    }
  });
});
				</code>
			</pre>
		</div>
		<!-- / Code example -->

		<p>We will need to pass the username to GitHub, so we need to extract if from the input text box. To show that we can do this, let's first extract the data using jQuery's val(), and log it to the console.</p>

		<!-- Code example -->
		<div class="code" rel="js" data-title="JS">
			<pre>
				<code>
<!-- Leave this line empty -->
$(document).ready(function() {
  $(document).on('keypress', '#username', function(event) {
    if (event.which === 13) { // check the key was <enter>
      var input = $(this);
      var username = input.val();

      console.log('username was: ' + username);
    }
  });
});
				</code>
			</pre>
		</div>
		<!-- / Code example -->

		<p>Now we're ready to pass this through to GitHub. Let's make another function. This will be placed below the initial JavaScript code and we will call the function and pass through the value of username.</p>

		<!-- Code example -->
		<div class="code" rel="js" data-title="JS">
			<pre>
				<code>
<!-- Leave this line empty -->
// github user finder example
$(document).ready(function() {
  $(document).on('keypress', '#username', function(event) {
    if (event.which === 13) { // check the key was <enter>
      var input = $(this);
      var username = input.val();

      // Call the new function
      getGithubInfo(username);

      console.log('username was: ' + username);

    }
  });

  // New function
  function getGithubInfo(username) {
  var url = 'https://api.github.com/users/' + username;

  var xmlhttp = new XMLHttpRequest();
  xmlhttp.open('GET', url, false);
  xmlhttp.send();

  return xmlhttp;
}
	
});
				</code>
			</pre>
		</div>
		<!-- / Code example -->

		<p>XMLHttpRequest is the object we use in JavaScript to perform an HTTP or API request. Although it has XML in the name (XML is a data format), it can be used for other formats such as JSON, which is what is being used here. We create an XMLHttpRequest object and then call the open method, passing three arguments to the GitHub API.</p>

		<ul>
			<li>The verb - in the case, GET</li>
			<li>The URL - in this case the URL is: https://api.github.com/users/codebar</li>
			<li>Whether or not to run this request synchronously or asynchronously.</li>
		</ul>

		<p>In this case, we'll specify synchronously by passing false. This means the browser will wait for the call to the GitHub API to finish before continuing.</p>

		<blockquote>
			<p>Making requests synchronously is not good practice, but we're doing it for now to keep things simple. Your browser may show a deprecation warning but the request will still work. We'll move onto asynchronous requests further down once we have the basics of APIs covered.</p>
		</blockquote>

		<p>You can now call getGithubInfo, passing the username from the keypress block above. This will log the data to the console. Next, we need to pass this back to the web page via the DOM.</p>

		<p>If the request was successful, the status code will be 200. If we check that this code is 200, we know we can proceed to read the data. If you enter 'justtoconfirm' the status will be 200. If you however enter 'justtoconfirmx' in the input field, the status in the network tab of the console will be a 404 as it cannot be found in GitHub.</p>

		<p>Next, we create a new method called showUser() that will handle the responses from the API and perform this check on the xmlhttp variable we just returned from our getGithubInfo method. Once the keypress block has called getGithubInfo, it should pass the result to showUser.</p>

		<!-- Code example -->
		<div class="code" rel="js" data-title="JS">
			<pre>
				<code>
<!-- Leave this line empty -->
function showUser(xmlhttp) {
  if(xmlhttp.status === 200) {
    // show the user details
  } else {
    // show an error
  }
}
				</code>
			</pre>
		</div>
		<!-- / Code example -->

		<p>Once we've checked the status, we need to decode the data which is stored in xmlhttp.responseText. This data is in JSON format, which is a string, so we need to turn it into a native JavaScript object. We do this using JSON.parse(data).</p>

		<!-- Code example -->
		<div class="code" rel="js" data-title="JS">
			<pre>
				<code>
<!-- Leave this line empty -->
function showUser(xmlhttp) {
  if(xmlhttp.status === 200) {
    // show the user details
    var json = xmlhttp.responseText;
    var user = JSON.parse(json);
  } else {
    // show an error
  }
}
				</code>
			</pre>
		</div>
		<!-- / Code example -->

		<p>Now the user variable will contain all the information we need to update the page.</p>

		<h3>Udemy: OOP JavaScript</h3>

		<p>Building a digital clock</p>

		<!-- Code example -->
		<div class="code" rel="js" data-title="JS">
			<pre>
				<code>
<!-- Leave this line empty -->
// Function job is to start our code
function onReady () {
	console.log('Hello Chapter 1');
}

// Call the onReady function following page load
window.onload = onReady;
				</code>
			</pre>
		</div>
		<!-- / Code example -->

		<p>In order to use our JavaScript, we have to check that our document is completely loaded. To do that we are going to use the onload callback. If we try to use JS before the document has completely loaded, things will not work as you would expect. We can use a function - to be called something like onReady - that will only be called one the document and it's assets have been completely loaded so we can target specific elements on the page.</p>

		<p>We will use the window object to check that it is ready following the page load which will call our onReady function on the page load. Now whenever we refresh the page, the onReady function will be called.</p>

		<p>We are working with a callback that is sending in our funtion onReady which we are then telling the window that when it has finished loading, to call the onReady function. The onReady function will be where the code will start and initialise from. We have so far seen the window object but have not created a new object yet.</p>

		<p>We can get the date() built-in JavaScript object, and this will allow us to apply date/time. This date() object has methods and properties. When you view the date object it has a number of properties we can use such as: getHours, getMinutes, getFullYear etc. For a clock, you want to get the minutes and hours. We use a method to get the hours from the date object. If it were a function it would not know where to get those hours from, but because it belongs to the date, it's going to get those hours from that specific date object.</p>

		<!-- Code example -->
		<div class="code" rel="js" data-title="JS">
			<pre>
				<code>
<!-- Leave this line empty -->
// Function job is to start our code
function onReady () {
	console.log('Hello Chapter 1');

	var date = new Date();

	console.log(date.getHours());
	console.log(date.getMinutes());
	console.log(date.getSeconds());
}

// Call the onReady function following page load
window.onload = onReady;
				</code>
			</pre>
		</div>
		<!-- / Code example -->

		<p>The next step is to integrate this into our clock. We create a function to format the digits in the clock if the value is less than 10 to add a 0 before.</p>

		<!-- Code example -->
		<div class="code" rel="js" data-title="JS">
			<pre>
				<code>
<!-- Leave this line empty -->
// Function job is to start our code
function onReady () {
	console.log('Hello Chapter 1');

	var date = new Date();

	// Output the properties of the Date object using methods
	console.log(date.getHours());
	console.log(date.getMinutes());
	console.log(date.getSeconds());

	// Get the clock element from the DOM using the document object
	var clock = document.getElementById('clock');

	// Display the current time in the clock
	clock.innerHTML = date.getHours() + ":" + date.getMinutes() + ":" + date.getSeconds();
}

// Add '0' before any value in the clock less than 10
function formatDigits ( val ) {

	if (val > 10) val = "0" + val;

	// Need return to send value back otherwise will be undefined
	return val;

}

// Call the onReady function following page load
window.onload = onReady;
				</code>
			</pre>
		</div>
		<!-- / Code example -->

		<p>We then want to wrap the formatDigits function around our digits we are actually outputting. We need to return the value in this new function to avoid the value being undefined, so does need a return statement to allow the value to be used outside of the function.</p>

		<!-- Code example -->
		<div class="code" rel="js" data-title="JS">
			<pre>
				<code>
<!-- Leave this line empty -->
// Function job is to start our code
function onReady () {
	console.log('Hello Chapter 1');

	var date = new Date();

	// Output the properties of the Date object using methods
	console.log(date.getHours());
	console.log(date.getMinutes());
	console.log(date.getSeconds());

	// Get the clock element from the DOM using the document object
	var clock = document.getElementById('clock');

	// Display the current time in the clock
	clock.innerHTML = formatDigits(date.getHours()) + ":" + formatDigits(date.getMinutes()) + ":" + formatDigits(date.getSeconds());
}

// Add '0' before any value in the clock less than 10
function formatDigits ( val ) {

	if (val < 10) val = "0" + val;

	// need return value
	return val;

}

// Call the onReady function following page load
window.onload = onReady;
				</code>
			</pre>
		</div>
		<!-- / Code example -->

		<p>The next part is to make the time change in real-time. We will use a setInterval() function that is a function that will repeat call a specific function for a duration of time we want. We want to use the setInterval function to call the updateClock function once a second.</p>

		<!-- Code example -->
		<div class="code" rel="js" data-title="JS">
			<pre>
				<code>
<!-- Leave this line empty -->
// Function job is to start our code
function onReady () {
	//console.log('Hello Chapter 1');

	// Call the updateClock function once every second
	setInterval(updateClock, 1000);

}

// Function to update the time in real-time
function updateClock () {

	var date = new Date();

	// Output the properties of the Date object using methods
	// console.log(date.getHours());
	// console.log(date.getMinutes());
	// console.log(date.getSeconds());

	// Get the clock element from the DOM using the document object
	var clock = document.getElementById('clock');

	// Display the current time in the clock
	clock.innerHTML = formatDigits(date.getHours()) + ":" + formatDigits(date.getMinutes()) + ":" + formatDigits(date.getSeconds());

}

// Add '0' before any value in the clock less than 10
function formatDigits ( val ) {

	if (val < 10) val = "0" + val;

	// need return value
	return val;

}

// Call the onReady function following page load
window.onload = onReady;
				</code>
			</pre>
		</div>
		<!-- / Code example -->

		<p>The problem with the code above initially is that on the initial page load, the value of the clock shows as: 00:00 because this is what is placed within the HTML document. So we want to call the updateClock function first before a single second has passed.</p>

		<!-- Code example -->
		<div class="code" rel="js" data-title="JS">
			<pre>
				<code>
<!-- Leave this line empty -->
// Function job is to start our code
function onReady () {
	//console.log('Hello Chapter 1');

	// Call the updateClock function once every second
	setInterval(updateClock, 1000);
	// Call the updateClock function before the first second has passed
	// This will prevent 00:00 from showing on the page load
	updateClock();

}

// Function to update the time in real-time
function updateClock () {

	var date = new Date();

	// Output the properties of the Date object using methods
	// console.log(date.getHours());
	// console.log(date.getMinutes());
	// console.log(date.getSeconds());

	// Get the clock element from the DOM using the document object
	var clock = document.getElementById('clock');

	// Display the current time in the clock
	clock.innerHTML = formatDigits(date.getHours()) + ":" + formatDigits(date.getMinutes()) + ":" + formatDigits(date.getSeconds());

}

// Add '0' before any value in the clock less than 10
function formatDigits ( val ) {

	if (val < 10) val = "0" + val;

	// need return value
	return val;

}

// Call the onReady function following page load
window.onload = onReady;
				</code>
			</pre>
		</div>
		<!-- / Code example -->

		<p>Again this code is not the most efficient. Every time we call the updateClock function, we are calling the Date object, fetching our element from the document. We could use external variables outside of the function itself, but this adds more variables to the global scope and the code becomes less optimised as a result, potentially causing conflicts with other JS code. Objects is a much better solution to this.</p>

		<!-- Code example -->
		<div class="code" rel="js" data-title="JS">
			<pre>
				<code>
<!-- Leave this line empty -->
&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
	&lt;meta charset="utf-8" /&gt;
	&lt;title&gt;Learning JavaScript OOP&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;div id="content"&gt;
	&lt;div id="clock"&gt;
		00:00
	&lt;/div&gt;
&lt;/div&gt;

&lt;script&gt;
// Function job is to start our code
function onReady () {
	//console.log('Hello Chapter 1');

	// Call the updateClock function once every second
	setInterval(updateClock, 1000);
	// Call the updateClock function before the first second has passed
	// This will prevent 00:00 from showing on the page load
	updateClock();

}

// Function to update the time in real-time
function updateClock () {

	var date = new Date();

	// Output the properties of the Date object using methods
	// console.log(date.getHours());
	// console.log(date.getMinutes());
	// console.log(date.getSeconds());

	// Get the clock element from the DOM using the document object
	var clock = document.getElementById('clock');

	// Display the current time in the clock
	clock.innerHTML = formatDigits(date.getHours()) + ":" + formatDigits(date.getMinutes()) + ":" + formatDigits(date.getSeconds());

}

// Add '0' before any value in the clock less than 10
function formatDigits ( val ) {

	if (val < 10) val = "0" + val;

	// need return value
	return val;

}

// Call the onReady function following page load
window.onload = onReady;
&lt;/script&gt;

&lt;/body&gt;
&lt;/html&gt;
				</code>
			</pre>
		</div>
		<!-- / Code example -->

		<h3>Create our own objects</h3>

		<p>The earlier code had a problem in that everything is very tied together. If we abstract the code more, the code will become more reusable.</p>

		<!-- Code example -->
		<div class="code" rel="js" data-title="JS">
			<pre>
				<code>
<!-- Leave this line empty -->
// Function job is to start our code
function onReady () {
	//console.log('Hello Chapter 1');

	var clock = createClock();

	// Call the updateClock function once every second
	////setInterval(updateClock, 1000);  // Now moved inside of the object
	// Call the updateClock function before the first second has passed
	// This will prevent 00:00 from showing on the page load
	////updateClock();		// Now moved inside of the object

}

// This is a function not a method because it doesn't belong to anything
function createClock () {

	// Create a new object
	var c = new Object();  // {} creates a new object also
		// Call variable and write the name of function to use
		// This function is now living inside of the object
		// This function is uniquely of this object
		// If you create a new clock, each clock will have this function (it can be reused)
		// This is now called a method as it's a function within an object - it belongs to this object
		c.updateClock = function () {
			var date = new Date();

			// Output the properties of the Date object using methods
			// console.log(date.getHours());
			// console.log(date.getMinutes());
			// console.log(date.getSeconds());

			// Get the clock element from the DOM using the document object
			var clock = document.getElementById('clock');

			// Display the current time in the clock
			clock.innerHTML = formatDigits(date.getHours()) + ":" + formatDigits(date.getMinutes()) + ":" + formatDigits(date.getSeconds());

		};	// Semicolon terminates the method inside the object

	// setInterval is now moved to be within the object
	// 'c' is used to reference the object which is named 'c'
	setInterval(c.updateClock, 1000);
	c.updateClock();

	return c;

}

// Add '0' before any value in the clock less than 10
function formatDigits ( val ) {

	if (val < 10) val = "0" + val;

	// need return value
	return val;

}

// Call the onReady function following page load
window.onload = onReady;
				</code>
			</pre>
		</div>
		<!-- / Code example -->

		<p>This update to our code will now allow us to create more than one clock, as the code is now within an object. By wrapping up our functions within objects we can create multiple instances of an object that contains the methods we require.</p>

		<!-- Code example -->
		<div class="code" rel="js" data-title="JS">
			<pre>
				<code>
<!-- Leave this line empty -->
&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
	&lt;meta charset="utf-8" /&gt;
	&lt;title&gt;Learning JavaScript OOP&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;div id="content"&gt;
	&lt;div id="clock"&gt;
		00:00
	&lt;/div&gt;
	&lt;div id="clock2"&gt;
		00:00
	&lt;/div&gt;
&lt;/div&gt;

&lt;script&gt;
// Function job is to start our code
function onReady () {
	//console.log('Hello Chapter 1');

	// Create clock one - div with id of 'clock'
	// Id attribute from div gets passed into createClock function
	var clock = createClock('clock');
	// Create clock two - div with id of 'clock2'
	var clock2 = createClock('clock2');

	// Call the updateClock function once every second
	////setInterval(updateClock, 1000);  // Now moved inside of the object
	// Call the updateClock function before the first second has passed
	// This will prevent 00:00 from showing on the page load
	////updateClock();		// Now moved inside of the object

}

// This is a function not a method because it doesn't belong to anything
// id parameter added so we can create multiple clocks
function createClock (id) {

	// Create a new object
	var c = new Object();  // {} creates a new object also
		// Call variable and write the name of function to use
		// This function is now living inside of the object
		// This function is uniquely of this object
		// If you create a new clock, each clock will have this function (it can be reused)
		// This is now called a method as it's a function within an object - it belongs to this object
		c.updateClock = function () {
			var date = new Date();

			// Output the properties of the Date object using methods
			// console.log(date.getHours());
			// console.log(date.getMinutes());
			// console.log(date.getSeconds());

			// Get the clock element from the DOM using the document object
			// 'id' value is taken from the value passed to the function parameter
			var clock = document.getElementById(id);

			// Display the current time in the clock
			clock.innerHTML = formatDigits(date.getHours()) + ":" + formatDigits(date.getMinutes()) + ":" + formatDigits(date.getSeconds());

		};	// Semicolon terminates the method inside the object

	// setInterval is now moved to be within the object
	// 'c' is used to reference the object which is named 'c'
	setInterval(c.updateClock, 1000);
	c.updateClock();

	return c;

}

// Add '0' before any value in the clock less than 10
function formatDigits ( val ) {

	if (val < 10) val = "0" + val;

	// need return value
	return val;

}

// Call the onReady function following page load
window.onload = onReady;
&lt;/script&gt;

&lt;/body&gt;
&lt;/html&gt;
				</code>
			</pre>
		</div>
		<!-- / Code example -->

		<!-- https://egghead.io/courses/how-to-write-an-open-source-javascript-library -->

		<!-- There is an abundance of resources out there that can help you out, but all you need to get started is an idea. Over-thinking and over-engineering what you want to do, can make things a lot harder for you so always remember to keep things simple and evolve the project gradually. -->

		<!-- http://tutorials.codebar.io/ -->

		<p>The next step is to allow clocks to be in different time zones. We need to refer to another method within the same object. To do this we use the keyword of this. By using the keyword of this, it will allow the object to use any method within itself. The less we hardcode things inside of our methods, the better. The keyword this will allow the object to find the methods within itself.</p>

		<!-- Code example -->
		<div class="code" rel="js" data-title="JS">
			<pre>
				<code>
<!-- Leave this line empty -->
// Function job is to start our code
function onReady () {
	//console.log('Hello Chapter 1');

	// Create clock one - div with id of 'clock'
	// Id attribute from div gets passed into createClock function
	var clock = createClock('clock');
	// Create clock two - div with id of 'clock2'
	var clock2 = createClock('clock2');

	// Call the updateClock function once every second
	////setInterval(updateClock, 1000);  // Now moved inside of the object
	// Call the updateClock function before the first second has passed
	// This will prevent 00:00 from showing on the page load
	////updateClock();		// Now moved inside of the object

}

// This is a function not a method because it doesn't belong to anything
// id parameter added so we can create multiple clocks
function createClock (id) {

	// Create a new object
	var c = new Object();  // {} creates a new object also
		// Call variable and write the name of function to use
		// This function is now living inside of the object
		// This function is uniquely of this object
		// If you create a new clock, each clock will have this function (it can be reused)
		// This is now called a method as it's a function within an object - it belongs to this object
		c.updateClock = function () {
			var date = new Date();

			// Output the properties of the Date object using methods
			// console.log(date.getHours());
			// console.log(date.getMinutes());
			// console.log(date.getSeconds());

			// Get the clock element from the DOM using the document object
			// 'id' value is taken from the value passed to the function parameter
			var clock = document.getElementById(id);

			// Display the current time in the clock
			// Now uses 'this' so the object can use any methods within itself
			// Without 'this' this method cannot locate the formatDigits method.
			clock.innerHTML = this.formatDigits(date.getHours()) + ":" + this.formatDigits(date.getMinutes()) + ":" + this.formatDigits(date.getSeconds());

		};	// Semicolon terminates the method inside the object

		// formatDigits has been moved into the object and becomes a method
		c.formatDigits = function ( val ) {

			if (val < 10) val = "0" + val;

			// need return value
			return val;

		};

	// setInterval is now moved to be within the object
	// 'c' is used to reference the object which is named 'c'
	//////////setInterval(c.updateClock, 1000);
	// Use an anonymous function to allow 'c' to be available - as it's currently calling it as a function not a method, so 'this' cannot be used - which is what we want to use.
	// Idea: sending the function to call the updateClock as a method (as calling as a function will break). This is an anonymous function.
	// Now has access to the 'c' scope forever
	// This solution will solve any console errors from occuring as happens with using the original code - function not method.
	// It needs to be a method to work
	// The reason it is wrapped in an anonymous function is to make sure that setInterval calls it as a function.
	setInterval(function() { c.updateClock(); }, 1000);
	c.updateClock();

	return c;

}

// Add '0' before any value in the clock less than 10
/*function formatDigits ( val ) {

	if (val < 10) val = "0" + val;

	// need return value
	return val;

}*/

// Call the onReady function following page load
window.onload = onReady;
				</code>
			</pre>
		</div>
		<!-- / Code example -->

		<h3>Constructing a Constructor</h3>

		<p>In JavaScript, functions that create things, are named with an uppercase letter, such as 'Clock'. Working with a constructor, we don't need to return anything, it gets returned by itself. The constructor will return itself when we create a new clock.</p>

		<!-- Code example -->
		<div class="code" rel="js" data-title="JS">
			<pre>
				<code>
<!-- Leave this line empty -->
// Function job is to start our code
function onReady () {
	//console.log('Hello Chapter 1');

	// Create clock one - div with id of 'clock'
	// Id attribute from div gets passed into createClock function
	var clock = new Clock('clock');
	// Create clock two - div with id of 'clock2'
	var clock2 = new Clock('clock2');

	// Call the updateClock function once every second
	////setInterval(updateClock, 1000);  // Now moved inside of the object
	// Call the updateClock function before the first second has passed
	// This will prevent 00:00 from showing on the page load
	////updateClock();		// Now moved inside of the object

}

// This is a function not a method because it doesn't belong to anything
// id parameter added so we can create multiple clocks
// CONSTRUCTOR
function Clock (id) {

	// Create a new object
	//var c = new Object();  // {} creates a new object also
		// Call variable and write the name of function to use
		// This function is now living inside of the object
		// This function is uniquely of this object
		// If you create a new clock, each clock will have this function (it can be reused)
		// This is now called a method as it's a function within an object - it belongs to this object

		// When we want to reference the method within the object, we can now use this
		this.updateClock = function () {
			var date = new Date();

			// Output the properties of the Date object using methods
			// console.log(date.getHours());
			// console.log(date.getMinutes());
			// console.log(date.getSeconds());

			// Get the clock element from the DOM using the document object
			// 'id' value is taken from the value passed to the function parameter
			var clock = document.getElementById(id);

			// Display the current time in the clock
			// Now uses 'this' so the object can use any methods within itself
			// Without 'this' this method cannot locate the formatDigits method.
			clock.innerHTML = this.formatDigits(date.getHours()) + ":" + this.formatDigits(date.getMinutes()) + ":" + this.formatDigits(date.getSeconds());

		};	// Semicolon terminates the method inside the object

		// formatDigits has been moved into the object and becomes a method
		this.formatDigits = function ( val ) {

			if (val < 10) val = "0" + val;

			// need return value
			return val;

		};

	// setInterval is now moved to be within the object
	// 'c' is used to reference the object which is named 'c'
	//////////setInterval(c.updateClock, 1000);
	// Use an anonymous function to allow 'c' to be available - as it's currently calling it as a function not a method, so 'this' cannot be used - which is what we want to use.
	// Idea: sending the function to call the updateClock as a method (as calling as a function will break). This is an anonymous function.
	// Now has access to the 'c' scope forever
	// This solution will solve any console errors from occuring as happens with using the original code - function not method.
	// It needs to be a method to work
	// The reason it is wrapped in an anonymous function is to make sure that setInterval calls it as a function.
	////setInterval(function() { c.updateClock(); }, 1000);
	////c.updateClock();

	// variable created so we can use this within a function that is out of scope
	var that = this;

	// This function has access to that but not this
	setInterval(function() { 
		that.updateClock(); }, 1000);
	this.updateClock();

	//return c;		// Not needed if using a constructor
}

// Add '0' before any value in the clock less than 10
/*function formatDigits ( val ) {

	if (val < 10) val = "0" + val;

	// need return value
	return val;

}*/

// Call the onReady function following page load
window.onload = onReady;
				</code>
			</pre>
		</div>
		<!-- / Code example -->

		<h3>Reusing Objects</h3>

		<p>JavaScript has two times, the user's own time and UTC time.</p>

		<!-- Code example -->
		<div class="code" rel="js" data-title="JS">
			<pre>
				<code>
<!-- Leave this line empty -->
&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
	&lt;meta charset="utf-8" /&gt;
	&lt;title&gt;Learning JavaScript OOP&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;div id="content"&gt;
	&lt;div id="clock"&gt;
		00:00
	&lt;/div&gt;
	&lt;div id="clock2"&gt;
		00:00
	&lt;/div&gt;
	&lt;div id="clock3"&gt;
		00:00
	&lt;/div&gt;
&lt;/div&gt;

&lt;script&gt;
// Function job is to start our code
function onReady () {
	//console.log('Hello Chapter 1');

	/* CREATE THE CLOCKS AND TIME ZONES HERE */
	// Create clock one - div with id of 'clock'
	// Id attribute from div gets passed into createClock function
	var clock = new Clock('clock');
	// Create clock two - div with id of 'clock2'
	// Second parameter is how many minutes behind UTC time - (time zone) = 5 hours (new york)
	// ETC is the easter time
	var clock2 = new Clock('clock2', -300, 'ETC');
	var clock3 = new Clock('clock3', 60, 'GMT');

	// Call the updateClock function once every second
	////setInterval(updateClock, 1000);  // Now moved inside of the object
	// Call the updateClock function before the first second has passed
	// This will prevent 00:00 from showing on the page load
	////updateClock();		// Now moved inside of the object

}

// This is a function not a method because it doesn't belong to anything
// id parameter added so we can create multiple clocks
// CONSTRUCTOR
function Clock (id, offset, label) {

	// set offset value of 0 for time zone unless value is provided
	offset = offset || 0;
	// set default label value to UTC
	label = label || 'UTC';

	/* Time zone */
	var d = new Date();
	// offset of the user's time from UTC - get the user's timezone offset 300 minutes (5 hours).
	console.log(d.getTimezoneOffset());
	// offser of the user's time from UTC - in hours
	console.log(d.getTimezoneOffset()/60);
	// offser of the user's time from UTC - in seconds
	console.log(d.getTimezoneOffset()*60);
	// offser of the user's time from UTC - in miliseconds
	console.log(d.getTimezoneOffset()*60*1000);
	// By calculating the difference between the UTC and the user's time, we can change the clock to be a certain time zone

	// Get time in millseconds from 1970 - epoch time - form midnight of that year - getTime()
	// This allows our time to be pushed locally to a time zone
	// UTC time. (1 hour behind GMT)
	//d = new Date(d.getTimezoneOffset()*60*1000 + d.getTime());
	//console.log(d);
	/* Time zone END */

	// store the time offset
	this.offset = (offset + d.getTimezoneOffset())*60*1000;

	// Create a new object
	//var c = new Object();  // {} creates a new object also
		// Call variable and write the name of function to use
		// This function is now living inside of the object
		// This function is uniquely of this object
		// If you create a new clock, each clock will have this function (it can be reused)
		// This is now called a method as it's a function within an object - it belongs to this object

		// When we want to reference the method within the object, we can now use this
		this.updateClock = function () {
			var date = new Date();
				// This could be refactored as we are creating a date object twice
				date = new Date(this.offset + date.getTime());
			// Output the properties of the Date object using methods
			// console.log(date.getHours());
			// console.log(date.getMinutes());
			// console.log(date.getSeconds());

			// Get the clock element from the DOM using the document object
			// 'id' value is taken from the value passed to the function parameter
			var clock = document.getElementById(id);

			// Display the current time in the clock
			// Now uses 'this' so the object can use any methods within itself
			// Without 'this' this method cannot locate the formatDigits method.
			// Improve: The hours only update every hour, so does it need to be updated every second.
			clock.innerHTML = this.formatDigits(date.getHours()) + ":" + this.formatDigits(date.getMinutes()) + ":" + this.formatDigits(date.getSeconds()) + " " + label;

		};	// Semicolon terminates the method inside the object

		// formatDigits has been moved into the object and becomes a method
		this.formatDigits = function ( val ) {

			if (val < 10) val = "0" + val;

			// need return value
			return val;

		};

	// setInterval is now moved to be within the object
	// 'c' is used to reference the object which is named 'c'
	//////////setInterval(c.updateClock, 1000);
	// Use an anonymous function to allow 'c' to be available - as it's currently calling it as a function not a method, so 'this' cannot be used - which is what we want to use.
	// Idea: sending the function to call the updateClock as a method (as calling as a function will break). This is an anonymous function.
	// Now has access to the 'c' scope forever
	// This solution will solve any console errors from occuring as happens with using the original code - function not method.
	// It needs to be a method to work
	// The reason it is wrapped in an anonymous function is to make sure that setInterval calls it as a function.
	////setInterval(function() { c.updateClock(); }, 1000);
	////c.updateClock();

	// variable created so we can use this within a function that is out of scope
	var that = this;

	// This function has access to that but not this
	setInterval(function() { 
		that.updateClock(); }, 1000);
	this.updateClock();

	//return c;		// Not needed if using a constructor
}

// Add '0' before any value in the clock less than 10
/*function formatDigits ( val ) {

	if (val < 10) val = "0" + val;

	// need return value
	return val;

}*/

// Call the onReady function following page load
window.onload = onReady;
&lt;/script&gt;

&lt;/body&gt;
&lt;/html&gt;
				</code>
			</pre>
		</div>
		<!-- / Code example -->

		<h3>Creating Methods with Prototype</h3>

		<p>The previous code has an issue in that everything is within the constructor. The problem with our current code is that all the methods are built into the constructor itself. This makes it extreamly difficult to use the clock elsewhere and use inheritance. We can begin by removing the method from the constructor itself, to stand alone on there own.</p>

		<!-- Code example -->
		<div class="code" rel="js" data-title="JS">
			<pre>
				<code>
<!-- Leave this line empty -->
// Function job is to start our code
function onReady () {

	var clock = new Clock('clock');
	var clock2 = new Clock('clock2', -300, 'ETC');
	var clock3 = new Clock('clock3', 60, 'GMT');

}

// Constructor
// Cannot use 'this' if outside of the constructor
function Clock (id, offset, label) {

	// set offset value of 0 for time zone unless value is provided
	offset = offset || 0;
	// set default label value to UTC
	label = label || 'UTC';

	var d = new Date();

	// define parameters so we can use them outside the constructor in the functions.
	// In the functions, we can use 'this' in the function if we need to use.
	// e.g. this.label
	this.offset = (offset + d.getTimezoneOffset())*60*1000;
	this.id = id;
	this.label = label;

	var that = this;

	setInterval(function() { 
		that.updateClock(); }, 1000);
	this.updateClock();

}

Clock.prototype.updateClock = function () {
	var date = new Date();
		date = new Date(this.offset + date.getTime());

	var clock = document.getElementById(this.id);
		clock.innerHTML = this.formatDigits(date.getHours()) + ":" + this.formatDigits(date.getMinutes()) + ":" + this.formatDigits(date.getSeconds()) + " " + this.label;

};

Clock.prototype.formatDigits = function ( val ) {

	if (val < 10) val = "0" + val;

	return val;

};

window.onload = onReady;
				</code>
			</pre>
		</div>
		<!-- / Code example -->

		<h3>Augmenting Built-in Objects</h3>

		<!-- Code example -->
		<div class="code" rel="js" data-title="JS">
			<pre>
				<code>
<!-- Leave this line empty -->
// Function job is to start our code
function onReady () {

	var clock = new Clock('clock');
	var clock2 = new Clock('clock2', -300, 'ETC');
	var clock3 = new Clock('clock3', 60, 'GMT');

}

// Add a new function to the data object
// Update the date seconds using this function
// This is done using prototype
// prototype can be used to add functions to existing JS pre-built objects, like date
// By adding a function to the date object, we don't have to then add this to the constructor internally
Date.prototype.updateSeconds = function () {

	// Can use this as we are using a method thats part of the date object itself
	// We are referencing the date object
	// get seconds + 1
	this.setSeconds(this.getSeconds() + 1);

}

Date.prototype.autoClock = function (isAuto) {

	// If function is called more than once, don't trigger more than once
	// Clear the interval
	clearInterval(this.clockInterval);

	// To re-trigger this function, set isAuto
	if (isAuto) {
		var that = this;
		// Call the updateSeconds function every second
		// Creating a clock that will automatically count
		this.clockInterval = setInterval(function(){that.updateSeconds()}, 1000);
	}

}

// Constructor
// Cannot use 'this' if outside of the constructor
function Clock (id, offset, label) {

	// set offset value of 0 for time zone unless value is provided
	offset = offset || 0;
	// set default label value to UTC
	label = label || 'UTC';

	var d = new Date();

	// define parameters so we can use them outside the constructor in the functions.
	// In the functions, we can use 'this' in the function if we need to use.
	// e.g. this.label
	var offset = (offset + d.getTimezoneOffset())*60*1000;
	// Global variable for the date itself
	this.d = new Date(offset + d.getTime());
	// Create an interval that will run once a second
	// Run our clock and run it automatically - refresh the view
	this.d.autoClock(true);
	this.id = id;
	this.label = label;

	var that = this;

	setInterval(function() { 
		that.updateClock(); }, 1000);
	this.updateClock();

}

// With this method of OOP, updateClock just becomes the 'face' of the clock
Clock.prototype.updateClock = function () {
	var date = this.d;
		// Call the updateSeconds function to update the clock every second
		//date.updateSeconds();
		// REMOVED as this is created within the constructor
		//date = new Date(this.offset + date.getTime());

	var clock = document.getElementById(this.id);
		clock.innerHTML = this.formatDigits(date.getHours()) + ":" + this.formatDigits(date.getMinutes()) + ":" + this.formatDigits(date.getSeconds()) + " " + this.label;

};

Clock.prototype.formatDigits = function ( val ) {

	if (val < 10) val = "0" + val;

	return val;

};

window.onload = onReady;
				</code>
			</pre>
		</div>
		<!-- / Code example -->

		<h3>Static Properties &amp; Methods</h3>

		<p>Classes are blue prints that enable us to duplicate things. They do not exist in JavaScript, functions are used to create objects. We can achieve the same functionality by tweaking objects.</p>

		<p>Static variables belong to the constructor, and never get passed onto the object. The Math object is one of the most common static variables.</p>

		<p>In this next update of the code, created static properties/methods, and using and not-using the prototype.</p>

		<!-- Code example -->
		<div class="code" rel="js" data-title="JS">
			<pre>
				<code>
<!-- Leave this line empty -->
// Function job is to start our code
function onReady () {

	var clock = new Clock('clock');
	var clock2 = new Clock('clock2', -300, 'ETC');
	var clock3 = new Clock('clock3', 60, 'GMT');

}

// Properties
// Underscore identifies the properties as not being public
// Properties belong to the date object
Date.__interval = 0;
Date.__aDates = [];

// Static method
// Accept the date 
Date.addToInterval = function (date) {
	// Will return the Date() constructor itself
	//console.log(this);
	//console.log(this.__interval);

	// Add to the array - automatically update
	this.__aDates.push(date);

	// If no interval
	if (!Date.__interval) {
		Date.__interval = setInterval(function(){Date.updateDates()}, 1000);
	}
}
Date.updateDates = function () {
	// Get back the amount of dates that I have added in
	//console.log(this.__aDates.length);

	// Loop through
	for (var i = 0; i < this.__aDates.length; i++) {
		this.__aDates[i].updateSeconds();
	}
}

// Add a new function to the data object
// Update the date seconds using this function
// This is done using prototype
// prototype can be used to add functions to existing JS pre-built objects, like date
// By adding a function to the date object, we don't have to then add this to the constructor internally
Date.prototype.updateSeconds = function () {

	// Can use this as we are using a method thats part of the date object itself
	// We are referencing the date object
	// get seconds + 1
	this.setSeconds(this.getSeconds() + 1);

	// Won't get access
	//console.log(this.__interval);
	// Will get access
	//console.log(Date.__interval);

}

Date.prototype.autoClock = function (isAuto) {

	// If function is called more than once, don't trigger more than once
	// Clear the interval
	//clearInterval(this.clockInterval);

	// To re-trigger this function, set isAuto
	if (isAuto) {
		/*
		var that = this;
		// Call the updateSeconds function every second
		// Creating a clock that will automatically count
		this.clockInterval = setInterval(function(){that.updateSeconds()}, 1000);
		*/
		Date.addToInterval(this);
	}

}

// Constructor
// Cannot use 'this' if outside of the constructor
function Clock (id, offset, label) {

	// set offset value of 0 for time zone unless value is provided
	offset = offset || 0;
	// set default label value to UTC
	label = label || 'UTC';

	var d = new Date();

	// define parameters so we can use them outside the constructor in the functions.
	// In the functions, we can use 'this' in the function if we need to use.
	// e.g. this.label
	var offset = (offset + d.getTimezoneOffset())*60*1000;
	// Global variable for the date itself
	this.d = new Date(offset + d.getTime());
	// Create an interval that will run once a second
	// Run our clock and run it automatically - refresh the view
	this.d.autoClock(true);
	this.id = id;
	this.label = label;

	var that = this;

	setInterval(function() { 
		that.updateClock(); }, 1000);
	this.updateClock();

}

// Setting a property
// This can be referred to anywhere in the application
// Does not need to be declared in the constructor
Clock.prototype.version = '1.0';

// With this method of OOP, updateClock just becomes the 'face' of the clock
Clock.prototype.updateClock = function () {
	// Access the version property
	//console.log(this.version);
	var date = this.d;
		// Call the updateSeconds function to update the clock every second
		//date.updateSeconds();
		// REMOVED as this is created within the constructor
		//date = new Date(this.offset + date.getTime());

	var clock = document.getElementById(this.id);
		clock.innerHTML = this.formatDigits(date.getHours()) + ":" + this.formatDigits(date.getMinutes()) + ":" + this.formatDigits(date.getSeconds()) + " " + this.label;

};

Clock.prototype.formatDigits = function ( val ) {

	if (val < 10) val = "0" + val;

	return val;

};

window.onload = onReady;
				</code>
			</pre>
		</div>
		<!-- / Code example -->	

		<h3>Moving our code into a Namespace</h3>

		<p>Avoids conflicting with other libraries and code. Namespace is a solution to this. Basically we want to hide our code behind a name unique to our code that nobody will use. As an example, our constructor is called 'Clock' which is very generic. By using namespacing, we can avoid a conflict if a library we use also has a method called 'Clock'.</p>

		<p>Currently, our code - like our methods and properties - are created on the global scope.</p>

		<!-- Code example -->
		<div class="code" rel="js" data-title="JS">
			<pre>
				<code>
<!-- Leave this line empty -->
// Function job is to start our code
function onReady () {

	var clock = new com.o2GEEK.Clock('clock');
	var clock2 = new com.o2GEEK.Clock('clock2', -300, 'ETC');
	var clock3 = new com.o2GEEK.Clock('clock3', 60, 'GMT');

}

// Properties
// Underscore identifies the properties as not being public
// Properties belong to the date object
Date.__interval = 0;
Date.__aDates = [];

// Static method
// Accept the date 
Date.addToInterval = function (date) {
	// Will return the Date() constructor itself
	//console.log(this);
	//console.log(this.__interval);

	// Add to the array - automatically update
	this.__aDates.push(date);

	// If no interval
	if (!Date.__interval) {
		Date.__interval = setInterval(function(){Date.updateDates()}, 1000);
	}
}
Date.updateDates = function () {
	// Get back the amount of dates that I have added in
	//console.log(this.__aDates.length);

	// Loop through
	for (var i = 0; i < this.__aDates.length; i++) {
		this.__aDates[i].updateSeconds();
	}
}

// Add a new function to the data object
// Update the date seconds using this function
// This is done using prototype
// prototype can be used to add functions to existing JS pre-built objects, like date
// By adding a function to the date object, we don't have to then add this to the constructor internally
Date.prototype.updateSeconds = function () {

	// Can use this as we are using a method thats part of the date object itself
	// We are referencing the date object
	// get seconds + 1
	this.setSeconds(this.getSeconds() + 1);

	// Won't get access
	//console.log(this.__interval);
	// Will get access
	//console.log(Date.__interval);

}

Date.prototype.autoClock = function (isAuto) {

	// If function is called more than once, don't trigger more than once
	// Clear the interval
	//clearInterval(this.clockInterval);

	// To re-trigger this function, set isAuto
	if (isAuto) {
		/*
		var that = this;
		// Call the updateSeconds function every second
		// Creating a clock that will automatically count
		this.clockInterval = setInterval(function(){that.updateSeconds()}, 1000);
		*/
		Date.addToInterval(this);
	}

}

// CREATE A NAMESPACE
// Create a new object and check if it already exists
// This will check to see if a third party code is also using this object
// Do you exist, if you don't exist, create a new object
// This is creating our 'com' folder - but we can rename it something else if we wish (unique)
// This prevents us from overriding an existing object
var com = com || {};
	// Go to the com folder and create o2GEEK
	// This creates the file and checks if it exists (as above)
	// com.o2GEEK is just an example name
	com.o2GEEK = com.o2GEEK || {};

// Constructor
// Cannot use 'this' if outside of the constructor
//function Clock (id, offset, label) {
// The constructor now belongs to our new object
com.o2GEEK.Clock = function (id, offset, label) {

	// set offset value of 0 for time zone unless value is provided
	offset = offset || 0;
	// set default label value to UTC
	label = label || 'UTC';

	var d = new Date();

	// define parameters so we can use them outside the constructor in the functions.
	// In the functions, we can use 'this' in the function if we need to use.
	// e.g. this.label
	var offset = (offset + d.getTimezoneOffset())*60*1000;
	// Global variable for the date itself
	this.d = new Date(offset + d.getTime());
	// Create an interval that will run once a second
	// Run our clock and run it automatically - refresh the view
	this.d.autoClock(true);
	this.id = id;
	this.label = label;

	var that = this;

	setInterval(function() { 
		that.updateClock(); }, 1000);
	this.updateClock();

}

// Setting a property
// This can be referred to anywhere in the application
// Does not need to be declared in the constructor
com.o2GEEK.Clock.prototype.version = '1.0';

// With this method of OOP, updateClock just becomes the 'face' of the clock
com.o2GEEK.Clock.prototype.updateClock = function () {
	// Access the version property
	//console.log(this.version);
	var date = this.d;
		// Call the updateSeconds function to update the clock every second
		//date.updateSeconds();
		// REMOVED as this is created within the constructor
		//date = new Date(this.offset + date.getTime());

	var clock = document.getElementById(this.id);
		clock.innerHTML = this.formatDigits(date.getHours()) + ":" + this.formatDigits(date.getMinutes()) + ":" + this.formatDigits(date.getSeconds()) + " " + this.label;

};

com.o2GEEK.Clock.prototype.formatDigits = function ( val ) {

	if (val < 10) val = "0" + val;

	return val;

};

window.onload = onReady;
				</code>
			</pre>
		</div>
		<!-- / Code example -->	

		<h2>Speed up CSS</h2>
		<!-- http://www.creativebloq.com/how-to/5-tips-for-super-fast-css -->

		<p>Tips to speed up your CSS code.</p>

		<h3>Shorthand CSS</h3>

		<p>Longhand properties are often used in CSS, however, this can often be used needlessly and a shorthand property is a much better solution to help with performance and code readability. Below is an example of a longhand property:</p>

		<!-- Code example -->
		<div class="code" rel="css" data-title="CSS">
			<pre>
				<code>
<!-- Leave this line empty -->
font-size: 1.5rem;
line-height: 1.618;
font-family: "Arial", "Helvetica", sans-serif;
				</code>
			</pre>
		</div>
		<!-- / Code example -->

		<p>The shorthand method for the above code:</p>

		<!-- Code example -->
		<div class="code" rel="css" data-title="CSS">
			<pre>
				<code>
<!-- Leave this line empty -->
font: 1.5rem/1.618 "Arial", "Helvetica", sans-serif;
				</code>
			</pre>
		</div>
		<!-- / Code example -->

		<p>The font shorthand property condenses several declarations into a handy one-liner that takes up much less space. Another example of a possible shorthand property could be margin that can be used in place of longer properties such as: margin-top, margin-right and so on.</p>

		<blockquote>
			<p>Using the shorthand property has it's benefits, but should only be used if it's necessary.</p>
		</blockquote>

		<h3>Preload</h3>

		<p>The preload resource hint can give the browser a head start on loading your site's CSS. The preload resource hint tells the browser to initiate an early fetch for an asset. This can be set as a &lt;link&gt; tag in HTML:</p>

		<!-- Code example -->
		<div class="code" rel="css" data-title="CSS">
			<pre>
				<code>
<!-- Leave this line empty -->
&lt;link rel="preload" href="styles/stylesheet.css" as="style" /&gt;
				</code>
			</pre>
		</div>
		<!-- / Code example -->	

		<p>This can also be applied as an HTTP header in your server configuration:</p>

		<!-- Code example -->
		<pre>
			<code>
<!-- Leave this line empty -->
Link: &lt;styles/stylesheet.css&gt;; rel=preload; as=style
			</code>
		</pre>
		<!-- / Code example -->	

		<p>In both of these scenarios, preload gives the browser a head start on loading the stylesheet. Using preload in an HTTP header is preferable, since this means the browser will discover the hint earlier (in the response headers, instead of later in the response body).</p>

		<p>Another reason to use preload in an HTTP header is that it will initiate a server push event on most HTTP/2 implementations. Server push is a mechanism by which assets are preemptively pushed to the client when requests for content are made. It also offers performance benefits similar to using inline CSS.</p>

		<blockquote>
			<p>Server push is not available on HTTP/1, however, using preload in an HTTP/1 environment can still improve performance.</p>
		</blockquote>

		<h2>JavaScript Project: Breakout Game</h2>

		<p>The logic behind breakout is simple. If you miss the ball with the paddle and let it reach the bottom edge of the screen, then you lose the game. The game will be constructed using the HTML5 &lt;canvas&gt; element and JavaScript.</p>

		<blockquote>
			<p>This documentation was taken from the MDN (Mozilla Developer Network) example: <a class="link" href="https://developer.mozilla.org/en-US/docs/Games/Tutorials/2D_Breakout_game_pure_JavaScript/Create_the_Canvas_and_draw_on_it" target="open_mdn">MDN Breakout Game tutorial</a></p>
		</blockquote>

		<h3>Create the Canvas</h3>

		<p>To begin, we need to canvas element to our HTML document. We will provide the width and height of the canvas and create some CSS code to style the canvas.</p>

		<!-- Code example -->
		<div class="code" rel="html" data-title="HTML: index.html">
			<pre>
				<code>
<!-- Leave this line empty -->
&lt;canvas id="myCanvas" width="480" height="320"&gt;&lt;/canvas&gt;
				</code>
			</pre>
		</div>
		<!-- / Code example -->	

		<p>The id of myCanvas allows us to easily reference the canvas element in the CSS and JavaScript code.</p>

		<!-- Code example -->
		<div class="code" rel="css" data-title="CSS: styles/breakout.css">
			<pre>
				<code>
<!-- Leave this line empty -->
* {
	padding: 0;
	margin: 0;
}

canvas {
	background: #eee;
	display: block;
	margin: 0 auto;
}
				</code>
			</pre>
		</div>
		<!-- / Code example -->	

		<h3>Adding the JavaScript</h3>

		<p>To actually render graphics onto the &lt;canvas&gt; element, we need to reference it within our JavaScript code. Here we are storing the reference to the &lt;canvas&gt; element to a variable named canvas. To allow us to paint onto the canvas, we need to use the getContext method to create the 2D rendering content and store it in a variable named ctx.</p>	

		<!-- Code example -->
		<div class="code" rel="js" data-title="JS: scripts/breakout.js">
			<pre>
				<code>
<!-- Leave this line empty -->
// Reference the canvas in the HTML document
var canvas = document.getElementById('myCanvas');
// Create the 2D rendering content
var ctx = canvas.getContext('2d');
				</code>
			</pre>
		</div>
		<!-- / Code example -->		

		<p>We want to create a ball that will be rendered on the canvas. This will designed to move, so we will be painting the ball on the screen, clearing it and then painting it again in a slightly different position every frame. This provides the impression of movement, just like how movement works in animation.</p>

		<p>To keep constantly updating the canvas drawing on each frame, we need to define a drawing function that will run over and over again, with a different set of variable values each time this function runs. The variable values will change the position of the ball. A JavaScript function can be run over and over again using a JavaScript timing functon such as setInterval() or requestAnimationFrame().</p>

		<p>Update your JavaScript code to include the draw() function. This will be executed every 10 milliseconds using setInterval. The function will be called every 10 milliseconds until we stop it.</p>

		<!-- Code example -->
		<div class="code" rel="js" data-title="JS: scripts/breakout.js">
			<pre>
				<code>
<!-- Leave this line empty -->
// Reference the canvas in the HTML document
var canvas = document.getElementById('myCanvas');
// Create the 2D rendering content
var ctx = canvas.getContext('2d');

function draw () {
	
	// Drawing code

}

// Call the function every 10 milliseconds
setInterval( draw, 10 );
				</code>
			</pre>
		</div>
		<!-- / Code example -->	

		<p>Within the draw function, we will now create the ball.</p>

		<!-- Code example -->
		<div class="code" rel="js" data-title="JS: scripts/breakout.js">
			<pre>
				<code>
<!-- Leave this line empty -->
// Reference the canvas in the HTML document
var canvas = document.getElementById('myCanvas');
// Create the 2D rendering content
var ctx = canvas.getContext('2d');

function draw () {
	
	/*
	Lets create the ball
	*/

	ctx.beginPath();
	/*
	param 1: x coordinates of the circle
	param 2: y coordinates of the circle
	param 3: arc radius
	param 4: start angle to start drawing the circle, in radians
	param 5: end angle to finish drawing the circle, in radians
	param 6: direction of drawing - false is clockwise, true is anti-clockwise (optional)
	*/
	ctx.arc( 50, 50, 10, 0, Math.PI*2, false );
	// fillStyle property to specify the colour of the circle
	ctx.fillStyle = "#0095dd";
	// Fill the shape with the colour specified in the fillStyle property
	ctx.fill();
	ctx.closePath();

}

// Call the function every 10 milliseconds
setInterval( draw, 10 );
				</code>
			</pre>
		</div>
		<!-- / Code example -->	

		<p>The interval will fire and the ball will be repainted on every frame, but the position of the ball will not change, so it will appear to not move.</p>

		<blockquote>
			<p>All instructions to render the ball are between the beginPath () and closePath () methods.</p>
		</blockquote>

		<h3>Making the ball move</h3>

		<p>To make the ball move, we are going to change the hardcoded coordinate values - 50, 50 - and instead, define a starting point at the bottom center of the Canvas in variables called x and y. These two variables will be used to define the position the circle is drawn at.</p>

		<p>The following two lines of code will be added above the draw() function. This will define x and y.</p>

		<!-- Code example -->
		<div class="code" rel="js" data-title="JS: scripts/breakout.js">
			<pre>
				<code>
<!-- Leave this line empty -->
var x = canvas.width / 2;
var y = canvas.height -30;
				</code>
			</pre>
		</div>
		<!-- / Code example -->	

		<p>The draw function is then updated so that the arc method will use the x and y variables. This will become the starting position of the ball.</p>

		<!-- Code example -->
		<div class="code" rel="js" data-title="JS: scripts/breakout.js">
			<pre>
				<code>
<!-- Leave this line empty -->
// Reference the canvas in the HTML document
var canvas = document.getElementById('myCanvas');
// Create the 2D rendering content
var ctx = canvas.getContext('2d');

var x = canvas.width / 2;
var y = canvas.height -30;

function draw () {
	
	/*
	Lets create the ball
	*/

	ctx.beginPath();
	/*
	param 1: x coordinates of the circle
	param 2: y coordinates of the circle
	param 3: arc radius
	param 4: start angle to start drawing the circle, in radians
	param 5: end angle to finish drawing the circle, in radians
	param 6: direction of drawing - false is clockwise, true is anti-clockwise (optional)
	*/
	ctx.arc( x, y, 10, 0, Math.PI*2, false );
	// fillStyle property to specify the colour of the circle
	ctx.fillStyle = "#0095dd";
	// Fill the shape with the colour specified in the fillStyle property
	ctx.fill();
	ctx.closePath();

}

// Call the function every 10 milliseconds
setInterval( draw, 10 );
				</code>
			</pre>
		</div>
		<!-- / Code example -->	

		<p>The ball will now be positioned at the bottom of the canvas and is now centered. This is the ball's starting position.</p>

		<p>We want to add a small value to x and y after every frame to provide movement. Each time the interval runs the draw function, the ball will move. To do this, let's define two move variables - dx and dy - and set their values to be 2 and -2.</p>

		<!-- Code example -->
		<div class="code" rel="js" data-title="JS: scripts/breakout.js">
			<pre>
				<code>
<!-- Leave this line empty -->
var dx = 2;
var dy = -2;
				</code>
			</pre>
		</div>
		<!-- / Code example -->	

		<p>Within the draw() function, we update our x and y variable values (ball's starting position), with the values of dx and dy each time the interval runs the draw() function, which is every millisecond. The ball will be painted in a new position each time the function runs.</p>

		<!-- Code example -->
		<div class="code" rel="js" data-title="JS: scripts/breakout.js">
			<pre>
				<code>
<!-- Leave this line empty -->
// Reference the canvas in the HTML document
var canvas = document.getElementById('myCanvas');
// Create the 2D rendering content
var ctx = canvas.getContext('2d');

var x = canvas.width / 2;
var y = canvas.height -30;

var dx = 2;
var dy = -2;

function draw () {
	
	/*
	Lets create the ball
	*/

	ctx.beginPath();
	/*
	param 1: x coordinates of the circle
	param 2: y coordinates of the circle
	param 3: arc radius
	param 4: start angle to start drawing the circle, in radians
	param 5: end angle to finish drawing the circle, in radians
	param 6: direction of drawing - false is clockwise, true is anti-clockwise (optional)
	*/
	ctx.arc( x, y, 10, 0, Math.PI*2, false );
	// fillStyle property to specify the colour of the circle
	ctx.fillStyle = "#0095dd";
	// Fill the shape with the colour specified in the fillStyle property
	ctx.fill();
	ctx.closePath();

	// Update the ball's position each time this function runs
	x += dx;
	y += dy;

}

// Call the function every 10 milliseconds
setInterval( draw, 10 );
				</code>
			</pre>
		</div>
		<!-- / Code example -->	

		<p>The code works, however, each time the ball moves, it appears that the ball is leaving a trail behind it. The ball is leaving a trail because we are painting a new circl on every frame without removing the previous one. Canvas has a method called clearRect that can be used to fix this issue. By placing this method at the top of our draw function, each time the function runs, the current position of the ball will be cleared, before the new position of the ball is created.</p>

		<!-- Code example -->
		<div class="code" rel="js" data-title="JS: scripts/breakout.js">
			<pre>
				<code>
<!-- Leave this line empty -->
function draw () {
	
	/*
	Lets create the ball
	*/

	/*
	Clear the canvas content
	This method takes four parameters:
	The x and y coordinates of the top left corner of a rectangle, and the x and y coordinates of the bottom right corner of a rectangle 
	*/
	ctx.clearRect( 0, 0, canvas.width, canvas.height );

	ctx.beginPath();
	/*
	param 1: x coordinates of the circle
	param 2: y coordinates of the circle
	param 3: arc radius
	param 4: start angle to start drawing the circle, in radians
	param 5: end angle to finish drawing the circle, in radians
	param 6: direction of drawing - false is clockwise, true is anti-clockwise (optional)
	*/
	ctx.arc( x, y, 10, 0, Math.PI*2, false );
	// fillStyle property to specify the colour of the circle
	ctx.fillStyle = "#0095dd";
	// Fill the shape with the colour specified in the fillStyle property
	ctx.fill();
	ctx.closePath();

	// Update the ball's position each time this function runs
	x += dx;
	y += dy;

}
				</code>
			</pre>
		</div>
		<!-- / Code example -->	

		<p>The ball should now be moving without a trail. Every 10 milliseconds, the canvas is cleared. The ball is now moving, however, it quickly disappears from the screen. To fix this issue, we will add some simple collision detection to make the ball bounce off the four edges of the Canvas. To detect the collision we will check whether the ball is touching (colliding) the wall, and if so, change the direction of it's movement.</p>

		<p>We begin by defining a variable called ballRadius that will hold the radius of the ball and we can then use this value for our calculations.</p>

		<!-- Code example -->
		<div class="code" rel="js" data-title="JS: scripts/breakout.js">
			<pre>
				<code>
<!-- Leave this line empty -->
var ballRadius = 10;
				</code>
			</pre>
		</div>
		<!-- / Code example -->

		<p>Now, we update the arc method inside the drawBall function that is used to draw the ball.</p>

		<!-- Code example -->
		<div class="code" rel="js" data-title="JS: scripts/breakout.js">
			<pre>
				<code>
<!-- Leave this line empty -->
ctx.arc( x, y, ballRadius, 0, Math.PI*2 );
				</code>
			</pre>
		</div>
		<!-- / Code example -->

		<p>There are four walls for the ball to bounce off. We need to check on each frame - each movement of the ball - whether the ball is touching the edge of the canvas (the walls). If the ball is touching the wall, we'll reverse the ball movemebr so it will start to move in the opposite direction.</p>

		<p>Coordinates start from the top left, so we can use something like this:</p>

		<!-- Code example -->
		<div class="code" rel="js" data-title="JS: scripts/breakout.js">
			<pre>
				<code>
<!-- Leave this line empty -->
if ( y + dy < 0 ) {
	
	dy = -dy;

}
				</code>
			</pre>
		</div>
		<!-- / Code example -->

		<p>This code above would deal with the ball bouncing off the top edge.</p>

		<blockquote>
			<p>If the y value of the ball position is lower than 0, change the direction of the movement on the y axis by setting it be equal to itself, reversed. If the ball was moving upwards with a speed of 2 pixels per frame, now it will be moving "up" with a speed of -2 pixels, which actually equals to moving down at a speed of 2 pixels per frame.</p>
		</blockquote>

		<p>Now lets write the code that will deal with the ball bouncing off the bottom edge:</p>

		<!-- Code example -->
		<div class="code" rel="js" data-title="JS: scripts/breakout.js">
			<pre>
				<code>
<!-- Leave this line empty -->
if ( y + dy > canvas.height ) {
	
	dy = -dy;

}
				</code>
			</pre>
		</div>
		<!-- / Code example -->

		<blockquote>
			<p>If the ball's y position is greater than the height of the Canvas (remember, we count the y values from the top left, so the top edge starts at 0 and the bottom edge is 480 pixels for the Canvas' height), then to bounce the ball off the bottom edge, we reverse the y axis movement as before.</p>
		</blockquote>

		<p>We can improve the code further to combine both statements to make it easier to understand:</p>

		<!-- Code example -->
		<div class="code" rel="js" data-title="JS: scripts/breakout.js">
			<pre>
				<code>
<!-- Leave this line empty -->
if ( y + dy > canvas.height || y + dy < 0 ) {
	
	dy = -dy;

}
				</code>
			</pre>
		</div>
		<!-- / Code example -->

		<p>If either of the above statements are true, reverse the ball in the other direction.</p>

		<p>Now we have the top and bottom edge covered, let's think about the left and right walls. All we have to do is replace the statements for y with that of x and change height to width.</p>

		<!-- Code example -->
		<div class="code" rel="js" data-title="JS: scripts/breakout.js">
			<pre>
				<code>
<!-- Leave this line empty -->
// Collision detection left/right
if ( x + dx > canvas.width || x + dx < 0 ) {
	
	dx = -dx;

}

// Collision detection top/bottom
if ( y + dy > canvas.height || y + dy < 0 ) {
	
	dy = -dy;

}
				</code>
			</pre>
		</div>
		<!-- / Code example -->

		<p>We're going to tidy up our JavaScript code slightly. We will have two functions, one to draw the ball, named drawBall, the other, called draw, will handle the movement of the ball within the canvas. The updated code should now look something like this:</p>

		<!-- Code example -->
		<div class="code" rel="js" data-title="JS: scripts/breakout.js">
			<pre>
				<code>
<!-- Leave this line empty -->
// Reference the canvas in the HTML document
var canvas = document.getElementById('myCanvas');
// Create the 2D rendering content
var ctx = canvas.getContext('2d');

var x = canvas.width / 2;
var y = canvas.height -30;

var dx = 2;
var dy = -2;

var ballRadius = 10;

// Function to create the ball
function drawBall () {
	
	ctx.beginPath();
	/*
	param 1: x coordinates of the circle
	param 2: y coordinates of the circle
	param 3: arc radius
	param 4: start angle to start drawing the circle, in radians
	param 5: end angle to finish drawing the circle, in radians
	param 6: direction of drawing - false is clockwise, true is anti-clockwise (optional)
	*/
	ctx.arc( x, y, 10, 0, Math.PI*2, false );
	// fillStyle property to specify the colour of the circle
	ctx.fillStyle = "#0095dd";
	// Fill the shape with the colour specified in the fillStyle property
	ctx.fill();
	ctx.closePath();
	
}

function draw () {
	
	/*
	Clear the canvas content
	This method takes four parameters:
	The x and y coordinates of the top left corner of a rectangle, and the x and y coordinates of the bottom right corner of a rectangle 
	*/
	ctx.clearRect( 0, 0, canvas.width, canvas.height );

	// Call the drawBall function
	drawBall();

	// Collision detection left/right
	if ( x + dx > canvas.width || x + dx < 0 ) {
	
		dx = -dx;

	}

	// Collision detection top/bottom
	if ( y + dy > canvas.height || y + dy < 0 ) {
	
		dy = -dy;

	}

	// Update the ball's position each time this function runs
	x += dx;
	y += dy;

}

// Call the function every 10 milliseconds
setInterval( draw, 10 );
				</code>
			</pre>
		</div>
		<!-- / Code example -->	

		<p>Now when the code runs, the ball will bounce off all four walls. The problem, however, is that when the ball hits any off the walls, it sinks into it slightly before changing direction. This is because the collision point is being calculated as the center of the ball, but we should really be using the circumference (the edge of the ball). The ball should bounce right after it touches the wall. Let's update the code to fix this.</p>

		<!-- Code example -->
		<div class="code" rel="js" data-title="JS: scripts/breakout.js">
			<pre>
				<code>
<!-- Leave this line empty -->
// Collision detection left/right
if ( x + dx > canvas.width-ballRadius || x + dx < ballRadius ) {
	
	dx = -dx;

}

// Collision detection top/bottom
if ( y + dy > canvas.height-ballRadius || y + dy < ballRadius ) {
	
	dy = -dy;

}
				</code>
			</pre>
		</div>
		<!-- / Code example -->

		<p>When the distance between the center of the ball and the edge of the wall is exactly the same as the radius of the ball, it wiill change the direction of the ball. Subtracting the radius from one edge's width and adding it to the other, gives us the impression of proper collision detection. This causes the ball to bounce off the walls as it should do.</p>

		<h3>Padding &amp; Keyboard controls</h3>
		<!-- https://developer.mozilla.org/en-US/docs/Games/Tutorials/2D_Breakout_game_pure_JavaScript/Paddle_and_keyboard_controls -->
		<p>To allow the game to be played, you need to add interactivity. We will now add a paddle to allow the user to hit the ball.</p>

		<p>We begin by defining a few variables that will define the paddle, such as it's height, width and starting point on the x axis.</p>

		<!-- Code example -->
		<div class="code" rel="js" data-title="JS: scripts/breakout.js">
			<pre>
				<code>
<!-- Leave this line empty -->
var paddleHeight = 10;
var paddleWidth = 75;
var paddleX = (canvas.width-paddleWidth) / 2;
				</code>
			</pre>
		</div>
		<!-- / Code example -->

		<p>A function can now be created that will draw the paddle on the screen. This function will be very similar to the drawBall function used to create the ball.</p>

		<!-- Code example -->
		<div class="code" rel="js" data-title="JS: scripts/breakout.js">
			<pre>
				<code>
<!-- Leave this line empty -->
// Function to create the paddle
function drawPaddle () {
	
	ctx.beginPath();
	ctx.rect( paddleX, canvas.height-paddleHeight, paddleWidth, paddleHeight );
	// fillStyle property to specify the colour of the circle
	ctx.fillStyle = "#0095dd";
	// Fill the shape with the colour specified in the fillStyle property
	ctx.fill();
	ctx.closePath();
	
}
				</code>
			</pre>
		</div>
		<!-- / Code example -->

		<p>We then need to call the drawPaddle function under the drawBall function within the draw function.</p>

		<!-- Code example -->
		<div class="code" rel="js" data-title="JS: scripts/breakout.js">
			<pre>
				<code>
<!-- Leave this line empty -->
function draw () {
	
	/*
	Clear the canvas content
	This method takes four parameters:
	The x and y coordinates of the top left corner of a rectangle, and the x and y coordinates of the bottom right corner of a rectangle 
	*/
	ctx.clearRect( 0, 0, canvas.width, canvas.height );

	// Call the drawBall function
	drawBall();
	// Call the drawPaddle function
	drawPaddle();

	// Collision detection left/right
	if ( x + dx > canvas.width || x + dx < 0 ) {
	
		dx = -dx;

	}
	
}
				</code>
			</pre>
		</div>
		<!-- / Code example -->

		<p>The paddle will appear on the bottom of the canvas, center aligned. The paddle cannot yet be controlled by the user. To implement paddle controls that respond to the user's actions, we will need:</p>

		<ul>
			<li>Two variables for storing information on whether the left or right control button is pressed.</li>
			<li>Two event listeners for keydown and keyup events - we want to run some code to handle the paddle movements when the buttons are pressed.</li>
			<li>Two functions handling the keydown and keyup events the code that will be run when the buttons are pressed.</li>
			<li>The ability to move the paddle left and right.</li>
		</ul>

		<p>Pressed buttons can be defined and initialized with boolean variables, like so.</p>

		<!-- Code example -->
		<div class="code" rel="js" data-title="JS: scripts/breakout.js">
			<pre>
				<code>
<!-- Leave this line empty -->
var rightPressed = false;
var leftPressed = false;
				</code>
			</pre>
		</div>
		<!-- / Code example -->	

		<p>The default value for both is false because at the beginning of the game, the control buttons are not pressed. To listen for key presses, we will set up two event listener. The following code will be placed just above the setInterval() function:</p>

		<!-- Code example -->
		<div class="code" rel="js" data-title="JS: scripts/breakout.js">
			<pre>
				<code>
<!-- Leave this line empty -->
document.addEventListener('keydown', keyDownHandler, false);
document.addEventListener('keyup', keyUpHandler, false);
				</code>
			</pre>
		</div>
		<!-- / Code example -->	

		<p>When the keydown event is fired on any of the keys on your keyboard, the keyDownHandler() function will be executed. When the keys stop being pressed, the keyUpHandler() function will fire. The following code will be added below the addEventListener() function.</p>

		<!-- Code example -->
		<div class="code" rel="js" data-title="JS: scripts/breakout.js">
			<pre>
				<code>
<!-- Leave this line empty -->
// Function called when key is pressed
function keyDownHandler( e ) {
	
	if ( e.keyCode == 39 ) {
		rightPressed = true;
	} else if ( e.keyCode == 37 ) {
		leftPressed = true;
	}

}

// Function called when key is released
function keyUpHandler( e ) {
	
	if ( e.keyCode == 39 ) {
		rightPressed = false;
	} else if ( e.keyCode == 37 ) {
		leftPressed = false;
	}

}
				</code>
			</pre>
		</div>
		<!-- / Code example -->	

		<blockquote>
			<p>When we press a key down, the value is set to be true and stored in the variable of rightPressed or leftPressed. When the key is released, the variable is set back to false.</p>
		</blockquote>

		<p>Both functions take an event as a parameter, represented by the e variable. From that, we can get useful information such as the keyCode that holds the information about the key that was pressed. For example, key code 37 is the left cursor key and 39 is the right cursor key.</p>

		<p>If the left cursor is pressed, then the leftPressed variable is set to be true, and when released the variable is set to be false. The same pattern follows with the right cursor key and the rightPressed variable.</p>

		<p>We can now add the actual code that will cause the paddle to move when the user uses the left or right keyboard keys. Inside the draw() function, we will check if the left or right cursor keys are pressed when each frame is rendered.</p>

		<!-- Code example -->
		<div class="code" rel="js" data-title="JS: scripts/breakout.js">
			<pre>
				<code>
<!-- Leave this line empty -->
/*
If rightPressed is true, move the paddle right
Else if leftPressed is true, move the paddle left
*/
if ( rightPressed ) {

	paddleX += 7;

} else if ( leftPressed ) {

	paddleX -= 7;

}
				</code>
			</pre>
		</div>
		<!-- / Code example -->	

		<blockquote>
			<p>If the left cursor is pressed, the paddle will move 7 pixels to the left, and if the right cursor is pressed, the paddle will move 7 pixels to the right.</p>
		</blockquote>

		<p>Lets update the JavaScript code and see it in action.</p>

		<!-- Code example -->
		<div class="code" rel="js" data-title="JS: scripts/breakout.js">
			<pre>
				<code>
<!-- Leave this line empty -->
// Reference the canvas in the HTML document
var canvas = document.getElementById('myCanvas');
// Create the 2D rendering content
var ctx = canvas.getContext('2d');

var x = canvas.width / 2;
var y = canvas.height -30;

var dx = 2;
var dy = -2;

var ballRadius = 10;

var paddleHeight = 10;
var paddleWidth = 75;
var paddleX = (canvas.width-paddleWidth) / 2;

var rightPressed = false;
var leftPressed = false;

// Function to create the ball
function drawBall () {
	
	ctx.beginPath();
	/*
	param 1: x coordinates of the circle
	param 2: y coordinates of the circle
	param 3: arc radius
	param 4: start angle to start drawing the circle, in radians
	param 5: end angle to finish drawing the circle, in radians
	param 6: direction of drawing - false is clockwise, true is anti-clockwise (optional)
	*/
	ctx.arc( x, y, 10, 0, Math.PI*2, false );
	// fillStyle property to specify the colour of the circle
	ctx.fillStyle = "#0095dd";
	// Fill the shape with the colour specified in the fillStyle property
	ctx.fill();
	ctx.closePath();
	
}

// Function to create the paddle
function drawPaddle () {
	
	ctx.beginPath();
	ctx.rect( paddleX, canvas.height-paddleHeight, paddleWidth, paddleHeight );
	// fillStyle property to specify the colour of the circle
	ctx.fillStyle = "#0095dd";
	// Fill the shape with the colour specified in the fillStyle property
	ctx.fill();
	ctx.closePath();
	
}

function draw () {
	
	/*
	Clear the canvas content
	This method takes four parameters:
	The x and y coordinates of the top left corner of a rectangle, and the x and y coordinates of the bottom right corner of a rectangle 
	*/
	ctx.clearRect( 0, 0, canvas.width, canvas.height );

	// Call the drawBall function
	drawBall();
	// Call the drawPaddle function
	drawPaddle();

	// Collision detection left/right
	if ( x + dx > canvas.width-ballRadius || x + dx < ballRadius ) {
	
		dx = -dx;

	}

	// Collision detection top/bottom
	if ( y + dy > canvas.height-ballRadius || y + dy < ballRadius ) {
	
		dy = -dy;

	}

	// Update the ball's position each time this function runs
	x += dx;
	y += dy;

	/*
	If rightPressed is true, move the paddle right
	Else if leftPressed is true, move the paddle left
	*/
	if ( rightPressed ) {

		paddleX += 7;

	} else if ( leftPressed ) {

		paddleX -= 7;

	}

}

document.addEventListener('keydown', keyDownHandler, false);
document.addEventListener('keyup', keyUpHandler, false);

// Function called when key is pressed
function keyDownHandler( e ) {
	
	if ( e.keyCode == 39 ) {

		rightPressed = true;

	} else if ( e.keyCode == 37 ) {

		leftPressed = true;

	}

}

// Function called when key is released
function keyUpHandler( e ) {
	
	if ( e.keyCode == 39 ) {

		rightPressed = false;

	} else if ( e.keyCode == 37 ) {

		leftPressed = false;

	}

}

// Call the function every 10 milliseconds
setInterval( draw, 10 );
				</code>
			</pre>
		</div>
		<!-- / Code example -->	

		<p>Now that the paddle moves, it has created a new issue. If the paddle is pressed to move left or right, it will eventually disappear off the edge of the canvas. We can improve this by only allowing the paddle to move within the boundaries of the Canvas.</p>

		<!-- Code example -->
		<div class="code" rel="js" data-title="JS: scripts/breakout.js">
			<pre>
				<code>
<!-- Leave this line empty -->
/*
If rightPressed is true, move the paddle right
Else if leftPressed is true, move the paddle left
*/
if ( rightPressed &amp;&amp; paddleX < canvas.width-paddleWidth ) {

	paddleX += 7;

} else if ( leftPressed &amp;&amp; paddleX > 0 ) {

	paddleX -= 7;

}
				</code>
			</pre>
		</div>
		<!-- / Code example -->	

		<blockquote>
			<p>The paddleX position we're using will move between 0 on the left side of the Canvas and canvas.width-paddleWidth on the right hand side, which is what we want.</p>
		</blockquote>

		<h3>Demo</h3>

		<!-- Canvas added to allow the demo to be displayed -->
		<canvas id="myCanvas" width="480" height="320"></canvas>
		<!-- / Demo -->

	</div>
</div>

<footer>
	<div class="row">
		<div class="small-12 medium-6 large-2 columns">
			<h3>Languages</h3>

			<ul class="no-bullets">
				<li><a href="index.html" class="footer__link">HTML</a></li>
				<li><a href="dev-css.html" class="footer__link">CSS</a></li>
				<li><a href="dev-scss.html" class="footer__link">SCSS &amp; Sass</a></li>
				<li><a href="dev-js.html" class="footer__link">JavaScript</a></li>
				<li><a href="dev-php.html" class="footer__link">PHP</a></li>
				<li><a href="dev-python.html" class="footer__link">Python</a></li>
				<li><a href="dev-ruby.html" class="footer__link">Ruby</a></li>
			</ul>
		</div>

		<div class="small-12 medium-6 large-2 columns">
			<h3>Tools</h3>

			<ul class="no-bullets">
				<li><a href="dev-node.html" class="footer__link">Node</a></li>
				<li><a href="dev-babel.html" class="footer__link">Babel</a></li>
				<li><a href="dev-webpack.html" class="footer__link">Webpack</a></li>
			</ul>
		</div>

		<div class="small-12 medium-6 large-2 columns">
			<h3>Frameworks</h3>

			<ul class="no-bullets">
				<li><a href="dev-jquery.html" class="footer__link">jQuery</a></li>
				<li><a href="dev-react.html" class="footer__link">React</a></li>
				<li><a href="dev-angular.html" class="footer__link">Angular</a></li>
				<li><a href="dev-express.html" class="footer__link">Express</a></li>
			</ul>
		</div>

		<div class="small-12 medium-6 large-2 columns">
			<h3>Other</h3>

			<ul class="no-bullets">
				<li><a href="dev-wordpress.html" class="footer__link">WordPress</a></li>
				<li><a href="dev-bem.html" class="footer__link">BEM</a></li>
			</ul>
		</div>

		<div class="small-2 medium-2 large-2 columns">
			<!-- Empty column -->
		</div>
	</div>
</footer>

<!-- Breakout JS -->
<script>
// Reference the canvas in the HTML document
var canvas = document.getElementById('myCanvas');
// Create the 2D rendering content
var ctx = canvas.getContext('2d');

var x = canvas.width / 2;
var y = canvas.height -30;

var dx = 2;
var dy = -2;

var ballRadius = 10;

var paddleHeight = 10;
var paddleWidth = 75;
var paddleX = (canvas.width-paddleWidth) / 2;

var rightPressed = false;
var leftPressed = false;

// Function to create the ball
function drawBall () {
	
	ctx.beginPath();
	/*
	param 1: x coordinates of the circle
	param 2: y coordinates of the circle
	param 3: arc radius
	param 4: start angle to start drawing the circle, in radians
	param 5: end angle to finish drawing the circle, in radians
	param 6: direction of drawing - false is clockwise, true is anti-clockwise (optional)
	*/
	ctx.arc( x, y, 10, 0, Math.PI*2, false );
	// fillStyle property to specify the colour of the circle
	ctx.fillStyle = "#0095dd";
	// Fill the shape with the colour specified in the fillStyle property
	ctx.fill();
	ctx.closePath();
	
}

// Function to create the paddle
function drawPaddle () {
	
	ctx.beginPath();
	ctx.rect( paddleX, canvas.height-paddleHeight, paddleWidth, paddleHeight );
	// fillStyle property to specify the colour of the circle
	ctx.fillStyle = "#0095dd";
	// Fill the shape with the colour specified in the fillStyle property
	ctx.fill();
	ctx.closePath();
	
}

function draw () {
	
	/*
	Clear the canvas content
	This method takes four parameters:
	The x and y coordinates of the top left corner of a rectangle, and the x and y coordinates of the bottom right corner of a rectangle 
	*/
	ctx.clearRect( 0, 0, canvas.width, canvas.height );

	// Call the drawBall function
	drawBall();
	// Call the drawPaddle function
	drawPaddle();

	// Collision detection left/right
	if ( x + dx > canvas.width-ballRadius || x + dx < ballRadius ) {
	
		dx = -dx;

	}

	// Collision detection top/bottom
	if ( y + dy > canvas.height-ballRadius || y + dy < ballRadius ) {
	
		dy = -dy;

	}

	// Update the ball's position each time this function runs
	x += dx;
	y += dy;

	/*
	If rightPressed is true, move the paddle right
	Else if leftPressed is true, move the paddle left
	*/
	if ( rightPressed && paddleX < canvas.width-paddleWidth ) {

		paddleX += 7;

	} else if ( leftPressed && paddleX > 0 ) {

		paddleX -= 7;

	}	

}

document.addEventListener('keydown', keyDownHandler, false);
document.addEventListener('keyup', keyUpHandler, false);

// Function called when key is pressed
function keyDownHandler( e ) {
	
	if ( e.keyCode == 39 ) {

		rightPressed = true;

	} else if ( e.keyCode == 37 ) {

		leftPressed = true;

	}

}

// Function called when key is released
function keyUpHandler( e ) {
	
	if ( e.keyCode == 39 ) {

		rightPressed = false;

	} else if ( e.keyCode == 37 ) {

		leftPressed = false;

	}

}

// Call the function every 10 milliseconds
setInterval( draw, 10 );
</script>
<!-- / Breakout JS -->

</body>
</html>